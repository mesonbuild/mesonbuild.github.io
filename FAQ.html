<html lang="en">
<head>

<base href=".">

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>FAQ</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">

<link rel="stylesheet" href="assets/css/prism.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/jquery.touchSwipe.min.js"></script>
<script src="assets/js/anchor.min.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>

<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>
<script src="assets/js/trie.js"></script>

<link rel="icon" type="image/png" href="assets/images/favicon.png">
<link rel="shortcut icon" href="assets/images/favicon.png">

</head>

<body class="no-script
" data-spy="scroll" data-target="#toc" data-offset="70">

<script>
$('body').removeClass('no-script');
</script>

<nav class="navbar navbar-fixed-top navbar-default" id="topnav">
	<div class="container-fluid">
		<div class="navbar-right">
			<a id="toc-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<form action="" class="navbar-form pull-right" id="navbar-search-form">
                               <div class="form-group has-feedback">
                                       <input type="text" class="form-control input-sm" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
				       <span class="glyphicon glyphicon-search form-control-feedback" id="search-mgn-glass"></span>
                               </div>
                        </form>
		</div>
		<div class="navbar-header">
			<a id="sidenav-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<a id="home-link" href="index.html" class="hotdoc-navbar-brand">
				<img src="assets/images/meson_logo.png" alt="Home" id="home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
				
<li class="dropdown">
	<a class="dropdown-toggle" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
		Modules <span class="caret"></span>
	</a>
	<ul class="dropdown-menu" id="modules-menu">
					<li>
				<a href="Gnome-module.html">GNOME</a>
			</li>
					<li>
				<a href="i18n-module.html">i18n</a>
			</li>
					<li>
				<a href="Pkgconfig-module.html">Pkgconfig</a>
			</li>
					<li>
				<a href="Python-3-module.html">Python 3</a>
			</li>
					<li>
				<a href="Qt4-module.html">Qt4</a>
			</li>
					<li>
				<a href="Qt5-module.html">Qt5</a>
			</li>
					<li>
				<a href="RPM-module.html">RPM</a>
			</li>
					<li>
				<a href="Windows-module.html">Windows</a>
			</li>
			</ul>
</li>
<li class="dropdown">
	<a class="dropdown-toggle" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
		Quick References <span class="caret"></span>
	</a>
	<ul class="dropdown-menu" id="quick-refs-menu">
					<li>
				<a href="Reference-manual.html">Functions</a>
			</li>
					<li>
				<a href="Build-options.html">Options</a>
			</li>
					<li>
				<a href="Configuration.html">Configuration</a>
			</li>
					<li>
				<a href="Dependencies.html">Dependencies</a>
			</li>
					<li>
				<a href="Unit-tests.html">Tests</a>
			</li>
					<li>
				<a href="Syntax.html">Syntax</a>
			</li>
			</ul>
</li>
			</ul>
			<div class="hidden-xs hidden-sm navbar-text navbar-center">
				<p><b>The Meson Build System</b></p>
			</div>
		</div>
	</div>
</nav>

<main>
<div data-extension="core" data-hotdoc-in-toplevel="True" data-hotdoc-project="Meson-documentation-1.0" data-hotdoc-ref="FAQ.html" class="page_container" id="page-wrapper">
<script src="assets/js/utils.js"></script>

<div class="panel panel-collapse oc-collapsed" id="sidenav" data-hotdoc-role="navigation">
	<script src="assets/js/navigation.js"></script>
	<script src="assets/js/sitemap.js"></script>
</div>

<div id="body">
	<div id="main">
				
<div id="page-description" data-hotdoc-source="FAQ.md" data-hotdoc-role="main">
<h1 id="meson-frequently-asked-questions">Meson Frequently Asked Questions</h1>
<p>See also <a href="howtox.html">How do I do X in Meson</a>.</p>
<h2 id="why-is-it-called-meson">Why is it called Meson?</h2>
<p>When the name was originally chosen, there were two main limitations:
there must not exist either a Debian package or a Sourceforge project
of the given name. This ruled out tens of potential project names. At
some point the name Gluon was considered. Gluons are elementary
particles that hold protons and neutrons together, much like a build
system's job is to take pieces of source code and a compiler and bind
them to a complete whole.</p>
<p>Unfortunately this name was taken, too. Then the rest of subatomic
particles were examined and Meson was found to be available.</p>
<h2 id="what-is-the-correct-way-to-use-threads-such-as-pthreads">What is the correct way to use threads (such as pthreads)?</h2>
<pre><code class="language-meson">thread_dep = dependency('threads')
</code></pre>
<p>This will set up everything on your behalf. People coming from
Autotools or CMake want to do this by looking for <code>libpthread.so</code>
manually. Don't do that, it has tricky corner cases especially when
cross compiling.</p>
<h2 id="how-to-use-meson-on-a-host-where-it-is-not-available-in-system-packages">How to use Meson on a host where it is not available in system packages?</h2>
<p>Starting from version 0.29.0, Meson is available from the <a href="https://pypi.python.org/pypi/meson/">Python
Package Index</a>, so installing it
simply a matter of running this command:</p>
<pre><code class="language-console">$ pip3 install &lt;your options here&gt; meson
</code></pre>
<p>If you don't have access to PyPI, that is not a problem either. Meson
has been designed to be easily runnable from an extracted source
tarball or even a git checkout. First you need to download Meson. Then
use this command to set up you build instead of plain <code>meson</code>.</p>
<pre><code class="language-console">$ /path/to/meson.py &lt;options&gt;
</code></pre>
<p>After this you don't have to care about invoking Meson any more. It
remembers where it was originally invoked from and calls itself
appropriately. As a user the only thing you need to do is to <code>cd</code> into
your build directory and invoke <code>ninja</code>.</p>
<h2 id="why-cant-i-specify-target-files-with-a-wildcard">Why can't I specify target files with a wildcard?</h2>
<p>Instead of specifying files explicitly, people seem to want to do this:</p>
<pre><code class="language-meson">executable('myprog', sources : '*.cpp') # This does NOT work!
</code></pre>
<p>Meson does not support this syntax and the reason for this is
simple. This can not be made both reliable and fast. By reliable we
mean that if the user adds a new source file to the subdirectory,
Meson should detect that and make it part of the build automatically.</p>
<p>One of the main requirements of Meson is that it must be fast. This
means that a no-op build in a tree of 10 000 source files must take no
more than a fraction of a second. This is only possible because Meson
knows the exact list of files to check. If any target is specified as
a wildcard glob, this is no longer possible. Meson would need to
re-evaluate the glob every time and compare the list of files produced
against the previous list. This means inspecting the entire source
tree (because the glob pattern could be <code>src/\*/\*/\*/\*.cpp</code> or
something like that). This is impossible to do efficiently.</p>
<p>The main backend of Meson is Ninja, which does not support wildcard
matches either, and for the same reasons.</p>
<p>Because of this, all source files must be specified explicitly.</p>
<h2 id="but-i-really-want-to-use-wildcards">But I really want to use wildcards!</h2>
<p>If the tradeoff between reliability and convenience is acceptable to
you, then Meson gives you all the tools necessary to do wildcard
globbing. You are allowed to run arbitrary commands during
configuration. First you need to write a script that locates the files
to compile. Here's a simple shell script that writes all <code>.c</code> files in
the current directory, one per line.</p>
<pre><code class="language-bash">#!/bin/sh

for i in *.c; do
  echo $i
done
</code></pre>
<p>Then you need to run this script in your Meson file, convert the output into a string array and use the result in a target.</p>
<pre><code class="language-meson">c = run_command('grabber.sh')
sources = c.stdout().strip().split('\n')
e = executable('prog', sources)
</code></pre>
<p>The script can be any executable, so it can be written in shell,
Python, Lua, Perl or whatever you wish.</p>
<p>As mentioned above, the tradeoff is that just adding new files to the
source directory does <em>not</em> add them to the build automatically. To
add them you need to tell Meson to reinitialize itself. The simplest
way is to touch the <code>meson.build</code> file in your source root. Then Meson
will reconfigure itself next time the build command is run. Advanced
users can even write a small background script that utilizes a
filesystem event queue, such as
<a href="https://en.wikipedia.org/wiki/Inotify">inotify</a>, to do this
automatically.</p>
<h2 id="should-i-use-subdir-or-subproject">Should I use <code>subdir</code> or <code>subproject</code>?</h2>
<p>The answer is almost always <code>subdir</code>. Subproject exists for a very
specific use case: embedding external dependencies into your build
process. As an example, suppose we are writing a game and wish to use
SDL. Let us further suppose that SDL comes with a Meson build
definition. Let us suppose even further that we don't want to use
prebuilt binaries but want to compile SDL for ourselves.</p>
<p>In this case you would use <code>subproject</code>. The way to do it would be to
grab the source code of SDL and put it inside your own source
tree. Then you would do <code>sdl = subproject('sdl')</code>, which would cause
Meson to build SDL as part of your build and would then allow you to
link against it or do whatever else you may prefer.</p>
<p>For every other use you would use <code>subdir</code>. As an example, if you
wanted to build a shared library in one dir and link tests against it
in another dir, you would do something like this:</p>
<pre><code class="language-meson">project('simple', 'c')
subdir('src')   # library is built here
subdir('tests') # test binaries would link against the library here
</code></pre>
<h2 id="why-is-there-not-a-make-backend">Why is there not a Make backend?</h2>
<p>Because Make is slow. This is not an implementation issue, Make simply
can not be made fast. For further info we recommend you read <a href="http://neugierig.org/software/chromium/notes/2011/02/ninja.html">this
post</a>
by Evan Martin, the author of Ninja. Makefiles also have a syntax that
is very unpleasant to write which makes them a big maintenance burden.</p>
<p>The only reason why one would use Make instead of Ninja is working on
a platform that does not have a Ninja port. Even in this case it is an
order of magnitude less work to port Ninja than it is to write a Make
backend for Meson.</p>
<p>Just use Ninja, you'll be happier that way. I guarantee it.</p>
<h2 id="why-is-meson-not-just-a-python-module-so-i-could-code-my-build-setup-in-python">Why is Meson not just a Python module so I could code my build setup in Python?</h2>
<p>A related question to this is <em>Why is Meson's configuration language
not Turing-complete?</em></p>
<p>There are many good reasons for this, most of which are summarized on
this web page: <a href="https://taint.org/2011/02/18/001527a.html">Against The Use Of Programming Languages in
Configuration Files</a>.</p>
<p>In addition to those reasons, not exposing Python or any other "real"
programming language makes it possible to port Meson's implementation
to a different language. This might become necessary if, for example,
Python turns out to be a performance bottleneck. This is an actual
problem that has caused complications for GNU Autotools and SCons.</p>
<h2 id="how-do-i-do-the-equivalent-of-libtools-exportsymbol-and-exportregex">How do I do the equivalent of Libtools export-symbol and export-regex?</h2>
<p>Either by using <a href="https://gcc.gnu.org/wiki/Visibility">GCC symbol
visibility</a> or by writing a
<a href="https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_mono/ld.html">linker
script</a>. This
has the added benefit that your symbol definitions are in a standalone
file instead of being buried inside your build definitions. An example
can be found
<a href="https://github.com/jpakkane/meson/tree/master/test%20cases/linuxlike/3%20linker%20script">here</a>.</p>
<h2 id="my-project-works-fine-on-linux-and-mingw-but-fails-with-msvc-due-to-a-missing-lib-file">My project works fine on Linux and MinGW but fails with MSVC due to a missing .lib file</h2>
<p>With GCC, all symbols on shared libraries are exported automatically
unless you specify otherwise. With MSVC no symbols are exported by
default. If your shared library exports no symbols, MSVC will silently
not produce an import library file leading to failures. The solution
is to add symbol visibility definitions <a href="https://gcc.gnu.org/wiki/Visibility">as specified in GCC
wiki</a>.</p>
<h2 id="i-added-some-compiler-flags-and-now-the-build-fails-with-weird-errors-what-is-happening">I added some compiler flags and now the build fails with weird errors. What is happening?</h2>
<p>You probably did the equivalent to this:</p>
<pre><code class="language-meson">executable('foobar', ...
           c_args : '-some_arg -other_arg')
</code></pre>
<p>Meson is <em>explicit</em>. In this particular case it will <strong>not</strong>
automatically split your strings at whitespaces, instead it will take
it as is and work extra hard to pass it to the compiler unchanged,
including quoting it properly over shell invocations. This is
mandatory to make e.g. files with spaces in them work flawlessly. To
pass multiple command line arguments, you need to explicitly put them
in an array like this:</p>
<pre><code class="language-meson">executable('foobar', ...
           c_args : ['-some_arg', '-other_arg'])
</code></pre>
<h2 id="why-are-changes-to-default-project-options-ignored">Why are changes to default project options ignored?</h2>
<p>You probably had a project that looked something like this:</p>
<pre><code class="language-meson">project('foobar', 'cpp')
</code></pre>
<p>This defaults to <code>c++11</code> on GCC compilers. Suppose you want to use
<code>c++14</code> instead, so you change the definition to this:</p>
<pre><code class="language-meson">project('foobar', 'cpp', default_options : ['cpp_std=c++14'])
</code></pre>
<p>But when you recompile, it still uses <code>c++11</code>. The reason for this is
that default options are only looked at when you are setting up a
build directory for the very first time. After that the setting is
considered to have a value and thus the default value is ignored. To
change an existing build dir to <code>c++14</code>, either reconfigure your build
dir with <code>meson configure</code> or delete the build dir and recreate it
from scratch.</p>
<p>The reason we don't automatically change the option value when the
default is changed is that it is impossible to know to do that
reliably. The actual question that we need to solve is "if the
option's value is foo and the default value is bar, should we change
the option value to bar also". There are many choices:</p>
<ul>
<li>
<p>if the user has changed the value themselves from the default, then
we must not change it back</p>
</li>
<li>
<p>if the user has not changed the value, but changes the default
value, then this section's premise would seem to indicate that the
value should be changed</p>
</li>
<li>
<p>suppose the user changes the value from the default to foo, then
back to bar and then changes the default value to bar, the correct
step to take is ambiguous by itself</p>
</li>
</ul>
<p>In order to solve the latter question we would need to remember not
only the current and old value, but also all the times the user has
changed the value and from which value to which other value. Since
people don't remember their own actions that far back, toggling
between states based on long history would be confusing.</p>
<p>Because of this we do the simple and understandable thing: default
values are only defaults and will never affect the value of an option
once set.</p>
<h2 id="does-wrap-download-sources-behind-my-back">Does wrap download sources behind my back?</h2>
<p>It does not. In order for Meson to download anything from the net
while building, two conditions must be met.</p>
<p>First of all there needs to be a <code>.wrap</code> file with a download URL in
the <code>subprojects</code> directory. If one does not exist, Meson will not
download anything.</p>
<p>The second requirement is that there needs to be an explicit
subproject invocation in your <code>meson.build</code> files. Either
<code>subproject('foobar')</code> or <code>dependency('foobar', fallback : ['foobar', 'foo_dep'])</code>. If these declarations either are not in any build file
or they are not called (due to e.g. <code>if/else</code>) then nothing is
downloaded.</p>
<p>If this is not sufficient for you, starting from release 0.40.0 Meson
has a option called <code>wrap-mode</code> which can be used to disable wrap
downloads altogether with <code>--wrap-mode=nodownload</code>. You can also
disable dependency fallbacks altogether with <code>--wrap-mode=nofallback</code>,
which also implies the <code>nodownload</code> option.</p>
<p>If on the other hand, you want meson to always use the fallback
for dependencies, even when an external dependency exists and could
satisfy the version requirements, for example in order to make
sure your project builds when fallbacks are used, you can use
<code>--wrap-mode=forcefallback</code> since 0.46.0.</p>
<h2 id="why-is-meson-implemented-in-python-rather-than-programming-language-x">Why is Meson implemented in Python rather than [programming language X]?</h2>
<p>Because build systems are special in ways normal applications aren't.</p>
<p>Perhaps the biggest limitation is that because Meson is used to build
software at the very lowest levels of the OS, it is part of the core
bootstrap for new systems. Whenever support for a new CPU architecture
is added, Meson must run on the system before software using it can be
compiled natively. This requirement adds two hard limitations.</p>
<p>The first one is that Meson must have the minimal amount of
dependencies, because they must all be built during the bootstrap to
get Meson to work.</p>
<p>The second is that Meson must support all CPU architectures, both
existing and future ones. As an example many new programming languages
have only an LLVM based compiler available. LLVM has limited CPU
support compared to, say, GCC, and thus bootstrapping Meson on such
platforms would first require adding new processor support to
LLVM. This is in most cases unfeasible.</p>
<p>A further limitation is that we want developers on as many platforms
as possible to submit to Meson development using the default tools
provided by their operating system. In practice what this means is
that Windows developers should be able to contribute using nothing but
Visual Studio.</p>
<p>At the time of writing (April 2018) there are only three languages
that could fullfill these requirements:</p>
<ul>
<li>C</li>
<li>C++</li>
<li>Python</li>
</ul>
<p>Out of these we have chosen Python because it is the best fit for our
needs.</p>

</div>


		
	</div>
	<div id="search_results">
		<p>The results of the search are</p>
	</div>
	<div id="footer">
		

<hr>

<div class="license-description">
    Website licensing information are available on the <a href="legal.html">Legal</a> page.
</div>


	</div>
</div>

<div id="toc-column">
	
		<div class="edit-button">
		<a href="https://github.com/mesonbuild/meson//edit/master/docs/markdown/FAQ.md" data-hotdoc-role="edit-button">Edit on github</a>

	</div>
		<div id="toc-wrapper">
		<nav id="toc"></nav>
	</div>
</div>
</div>
</main>

</body>

<script src="assets/js/navbar_offset_scroller.js"></script>
</html>
