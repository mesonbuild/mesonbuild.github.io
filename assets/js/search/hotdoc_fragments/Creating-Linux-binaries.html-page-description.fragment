fragment_downloaded_cb({"url":"Creating-Linux-binaries.html#page-description","fragment":"Creating Linux binaries that can be downloaded and run on any distro\n(like .dmg packages for OSX or .exe installers for Windows) has\ntraditionally been difficult. This is even more tricky if you want to\nuse modern compilers and features, which is especially desired in game\ndevelopment. There is still no simple turn-key solution for this\nproblem but with a bit of setup it can be relatively straightforward.\nFirst you need to do a fresh operating system install. You can use\nspare hardware, VirtualBox, cloud or whatever you want. Note that the\ndistro you install must be at least as old as the oldest release you\nwish to support. Debian stable is usually a good choice, though\nimmediately after its release you might want to use Debian oldstable\nor the previous Ubuntu LTS. The oldest supported version of CentOS is\nalso a good choice.\nOnce you have installed the system, you need to install\nbuild-dependencies for GCC. In Debian-based distros this can be done\nwith the following commands:\nThen create a src subdirectory in your home directory. Copy-paste\nthe following into install_gcc.sh and execute it.\nThen finally add the following lines to your .bashrc.\nLog out and back in and now your build environment is ready to use.\nOld distros might have too old versions of some tools. For Meson this\ncould include Python 3 and Ninja. If this is the case you need to\ndownload, build and install new versions into ~/devroot in the usual\nway.\nYou want to embed and statically link every dependency you can\n(especially C++ dependencies). Meson's Wrap package\nmanager might be of use here. This\nis equivalent to what you would do on Windows, OSX, Android etc.\nSometimes static linking is not possible. In these cases you need to\ncopy the .so files inside your package. Let's use SDL2 as an example.\nFirst we download and install it as usual giving it our custom install\nprefix (that is, ./configure --prefix=${HOME}/devroot). This makes\nMeson's dependency detector pick it up automatically.\nBuilding happens in much the same way as normally. There are just two\nthings to note. First, you must tell GCC to link the C++ standard\nlibrary statically. If you don't then your app is guaranteed to break\nas different distros have binary-incompatible C++ libraries. The\nsecond thing is that you need to point your install prefix to some\nempty staging area. Here's the meson command to do that:\nThe aim is to put the executable in /tmp/myapp/bin and shared\nlibraries to /tmp/myapp/lib. The next thing you need is the\nembedder. It takes your dependencies (in this case only\nlibSDL2-2.0.so.0) and copies them in the lib directory. Depending on\nyour use case you can either copy the files by hand or write a script\nthat parses the output of ldd binary_file. Be sure not to copy\nsystem libraries (libc, libpthread, libm etc). For an example,\nsee the sample\nproject.\nMake the script run during install with this:\nIf you try to run the program now it will most likely fail to start or\ncrashes. The reason for this is that the system does not know that the\nexecutable needs libraries from the lib directory. The solution for\nthis is a simple wrapper script. Create a script called myapp.sh\nwith the following content:\nInstall it with this Meson snippet:\nAnd now you are done. Zip up your /tmp/myapp directory and you have\na working binary ready for deployment. To run the program, just unzip\nthe file and run myapp.sh.\n"});