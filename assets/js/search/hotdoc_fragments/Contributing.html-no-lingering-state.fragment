fragment_downloaded_cb({"url":"Contributing.html#no-lingering-state","fragment":"No lingering state\nMeson operates in much the same way as functional programming\nlanguages. It has inputs, which include meson.build files, values of\noptions, compilers and so on. These are passed to a function, which\ngenerates output build definition. This function is pure, which means that:\nThe latter one is important, because it enforces that there is no way\nfor \"secret state\" to pass between consecutive invocations of\nMeson. This is the reason why, for example, there is no set_option\nfunction even though there is a get_option one.\nIf this were not the case, we could never know if the build output is\n\"stable\". For example suppose there were a set_option function and a\nboolean variable flipflop. Then you could do this:\nThis piece of code would never converge. Every Meson run would change\nthe value of the option and thus the output you get out of this build\ndefinition would be random.\nMeson does not permit this by forbidding these sorts of covert\nchannels.\nThere is one exception to this rule. Users can call into external\ncommands with run_command. If the output of that command does not\nbehave like a pure function, this problem arises. Meson does not try\nto guard against this case, it is the responsibility of the user to\nmake sure the commands they run behave like pure functions.\n\nfor any given input the output is always the same\nrunning Meson twice in a row always produce the same output in both runs\n\n"});