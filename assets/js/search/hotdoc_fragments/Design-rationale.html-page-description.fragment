fragment_downloaded_cb({"url": "Design-rationale.html#page-description", "fragment": "This is the original design rationale for Meson. The syntax it describes does not match the released version \nMust do the right thing by default \nMust enforce established best practices \nMust have native support for platforms that are in common use \nMust not add complexity due to obsolete platforms \nMust provide easy to use support for modern sw development features \nMust allow override of default values \nA software developer s most important tool is the editor. If you talk to coders about the editors they use you are usually met with massive enthusiasm and praise. You will hear how Emacs is the greatest thing ever or how vi is so elegant or how Eclipse s integration features make you so much more productive. You can sense the enthusiasm and affection that the people feel towards these programs. \nThe second most important tool even more important than the compiler is the build system. \nThose are pretty much universally despised. \nThe most positive statement on build systems you can usually get and it might require some coaxing is something along the lines of well it s a terrible system but all other options are even worse. It is easy to see why this is the case. For starters commonly used free build systems have obtuse syntaxes. They use for the most part global variables that are set in random locations so you can never really be sure what a given line of code does. They do strange and unpredictable things at every turn. \nLet s illustrate this with a simple example. Suppose we want to run a program built with GNU Autotools under GDB. The instinctive thing to do is to just run gdb programname. The problem is that this may or may not work. In some cases the executable file is a binary whereas at other times it is a wrapper shell script that invokes the real binary which resides in a hidden subdirectory. GDB invocation fails if the binary is a script but succeeds if it is not. The user has to remember the type of each one of his executables which is an implementation detail of the build system just to be able to debug them. Several other such pain points can be found in this blog post. \nGiven these idiosyncrasies it is no wonder that most people don t want to have anything to do with build systems. They ll just copy paste code that works somewhat in one place to another and hope for the best. They actively go out of their way not to understand the system because the mere thought of it is repulsive. Doing this also provides a kind of inverse job security. If you don t know tool X there s less chance of finding yourself responsible for its use in your organisation. Instead you get to work on more enjoyable things. \nThis leads to a vicious circle. Since people avoid the tools and don t want to deal with them very few work on improving them. The result is apathy and stagnation. \nMost builds are done by developers working on the code. Therefore the defaults must be tailored towards that use case. As an example the system shall build objects without optimization and with debug information. It shall make binaries that can be run directly from the build directory without linker tricks shell scripts or magic environment variables. \nThere really is no reason to compile source code without the equivalent of Wall. So enable it by default. A different kind of best practice is the total separation of source and build directories. All build artifacts must be stored in the build directory. Writing stray files in the source directory is not permitted under any circumstances. \nA lot of free software projects can be used on non free platforms such as Windows or OSX. The system must provide native support for the tools of choice on those platforms. In practice this means native support for Visual Studio and XCode. Having said IDEs invoke external builder binaries does not count as native support. \nWork on this build system started during the Christmas holidays of This provides a natural hard cutoff line of Any platform tool or library that was not in active use at that time is explicitly not supported. These include Unixes such as IRIX SunOS OSF Ubuntu versions older than GCC versions older than and so on. If these old versions happen to work great. If they don t not a single line of code will be added to the system to work around their bugs. \nAn example is precompiled headers. Currently no free software build system provides native support for them. Other examples could include easy integration of Valgrind and unit tests test coverage reporting and so on. \nSometimes you just have to compile files with only given compiler flags and no others or install files in weird places. The system must allow the user to do this if he really wants to. \n"});