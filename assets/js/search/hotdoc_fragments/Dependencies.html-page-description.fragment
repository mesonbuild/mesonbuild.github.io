fragment_downloaded_cb({"url":"Dependencies.html#page-description","fragment":"Very few applications are fully self-contained, but rather they use\nexternal libraries and frameworks to do their work. Meson makes it\nvery easy to find and use external dependencies. Here is how one would\nuse the zlib compression library.\nFirst Meson is told to find the external library zlib and error out\nif it is not found. The version keyword is optional and specifies a\nversion requirement for the dependency. Then an executable is built\nusing the specified dependency. Note how the user does not need to\nmanually handle compiler or linker flags or deal with any other\nminutiae.\nIf you have multiple dependencies, pass them as an array:\nIf the dependency is optional, you can tell Meson not to error out if\nthe dependency is not found and then do further configuration.\nYou can pass the opt_dep variable to target construction functions\nwhether the actual dependency was found or not. Meson will ignore\nnon-found dependencies.\nMeson also allows to get variables that are defined in the\npkg-config file. This can be done by using the\nget_pkgconfig_variable function.\nThese variables can also be redefined by passing the define_variable\nparameter, which might be useful in certain situations:\nThe dependency detector works with all libraries that provide a\npkg-config file. Unfortunately several packages don't provide\npkg-config files. Meson has autodetection support for some of these,\nand they are described later in this\npage.\nNote new in 0.51.0\nnew in 0.54.0, the internal keyword\nWhen you need to get an arbitrary variables from a dependency that can\nbe found multiple ways and you don't want to constrain the type you\ncan use the generic get_variable method. This currently supports\ncmake, pkg-config, and config-tool based variables.\nIt accepts the keywords 'cmake', 'pkgconfig', 'pkgconfig_define',\n'configtool', 'internal', and 'default_value'. 'pkgconfig_define'\nworks just like the 'define_variable' argument to\nget_pkgconfig_variable. When this method is invoked the keyword\ncorresponding to the underlying type of the dependency will be used to\nlook for a variable. If that variable cannot be found or if the caller\ndoes not provide an argument for the type of dependency, one of the\nfollowing will happen: If 'default_value' was provided that value will\nbe returned, if 'default_value' was not provided then an error will be\nraised.\nYou can declare your own dependency objects that can be used\ninterchangeably with dependency objects obtained from the system. The\nsyntax is straightforward:\nThis declares a dependency that adds the given include directories and\nstatic library to any target you use it in.\nMany platforms do not provide a system package manager. On these\nsystems dependencies must be compiled from source. Meson's subprojects\nmake it simple to use system dependencies when they are available and\nto build dependencies manually when they are not.\nTo make this work, the dependency must have Meson build definitions\nand it must declare its own dependency like this:\nThen any project that wants to use it can write out the following\ndeclaration in their main meson.build file.\nWhat this declaration means is that first Meson tries to look up the\ndependency from the system (such as by using pkg-config). If it is not\navailable, then it builds subproject named foo and from that\nextracts a variable foo_dep. That means that the return value of\nthis function is either an external or an internal dependency object.\nSince they can be used interchangeably, the rest of the build\ndefinitions do not need to care which one it is. Meson will take care\nof all the work behind the scenes to make this work.\nYou can use the keyword method to let Meson know what method to use\nwhen searching for the dependency. The default value is auto.\nAdditional dependencies methods are pkg-config, config-tool, cmake,\nsystem, sysconfig, qmake, extraframework and dub.\nThe dependency method order for auto is:\nMeson can use the CMake find_package() function to detect\ndependencies with the builtin Find<NAME>.cmake modules and exported\nproject configurations (usually in /usr/lib/cmake). Meson is able to\nuse both the old-style <NAME>_LIBRARIES variables as well as\nimported targets.\nIt is possible to manually specify a list of CMake targets that should\nbe used with the modules property. However, this step is optional\nsince Meson tries to automatically guess the correct target based on\nthe name of the dependency.\nDepending on the dependency it may be necessary to explicitly specify\na CMake target with the modules property if Meson is unable to guess\nit automatically.\nSupport for adding additional COMPONENTS for the CMake\nfind_package lookup is provided with the components kwarg\n(introduced in 0.54.0). All specified componets will be passed\ndirectly to find_package(COMPONENTS).\nSupport for packages which require a specified version for CMake\nfind_package to succeed is provided with the cmake_package_version\nkwarg (introduced in 0.57.0). The specified cmake_package_version\nwill be passed directly as the second parameter to find_package.\nIt is also possible to reuse existing Find<name>.cmake files with\nthe cmake_module_path property. Using this property is equivalent to\nsetting the CMAKE_MODULE_PATH variable in CMake. The path(s) given\nto cmake_module_path should all be relative to the project source\ndirectory. Absolute paths should only be used if the CMake files are\nnot stored in the project itself.\nAdditional CMake parameters can be specified with the cmake_args\nproperty.\nPlease understand that Meson is only able to find dependencies that\nexist in the local Dub repository. You need to manually fetch and\nbuild the target dependencies.\nFor urld.\nOther thing you need to keep in mind is that both Meson and Dub need\nto be using the same compiler. This can be achieved using Dub's\n-compiler argument and/or manually setting the DC environment\nvariable when running Meson.\nSome dependencies have specific detection logic.\nGeneric dependency names are case-sensitive1,\nbut these dependency names are matched case-insensitively. The\nrecommended style is to write them in all lower-case.\nIn some cases, more than one detection method exists, and the method\nkeyword may be used to select a detection method to use. The auto\nmethod uses any checking mechanisms in whatever order Meson thinks is\nbest.\ne.g. libwmf and CUPS provide both pkg-config and config-tool support.\nYou can force one or another via the method keyword:\nCUPS, LLVM, pcap, WxWidgets,\nlibwmf, GCrypt, GPGME, and GnuStep either do not provide pkg-config\nmodules or additionally can be detected via a config tool\n(cups-config, llvm-config, libgcrypt-config, etc). Meson has native support for these\ntools, and they can be found like other dependencies:\nSince 0.55.0 Meson won't search $PATH any more for a config tool\nbinary when cross compiling if the config tool did not have an entry\nin the cross file.\nUse the modules keyword to list frameworks required, e.g.\nThese dependencies can never be found for non-OSX hosts.\nEnable support for Clang's blocks extension.\n(added 0.52.0)\nBoost is not a single dependency but rather a group of different\nlibraries. To use Boost headers-only libraries, simply add Boost as a\ndependency.\nTo link against boost with Meson, simply list which libraries you\nwould like to use.\nYou can call dependency multiple times with different modules and\nuse those to link against your targets.\nIf your boost headers or libraries are in non-standard locations you\ncan set the BOOST_ROOT, or the BOOST_INCLUDEDIR and\nBOOST_LIBRARYDIR environment variables. (added in 0.56.0) You can\nalso set these parameters as boost_root, boost_include, and\nboost_librarydir in your native or cross machine file. Note that\nmachine file variables are preferred to environment variables, and\nthat specifying any of these disables system-wide search for boost.\nYou can set the argument threading to single to use boost\nlibraries that have been compiled for single-threaded use instead.\n(added 0.53.0)\nEnables compiling and linking against the CUDA Toolkit. The version\nand modules keywords may be passed to request the use of a specific\nCUDA Toolkit version and/or additional CUDA libraries, correspondingly:\nNote that explicitly adding this dependency is only necessary if you are\nusing CUDA Toolkit from a C/C++ file or project, or if you are utilizing\nadditional toolkit libraries that need to be explicitly linked to.\nmethod may be auto, config-tool, pkg-config, cmake or extraframework.\n(added 0.50.0)\nCoarrays are a Fortran language intrinsic feature, enabled by\ndependency('coarray').\nGCC will use OpenCoarrays if present to implement coarrays, while Intel and NAG\nuse internal coarray support.\nThis finds the OpenGL library in a way appropriate to the platform.\nmethod may be auto, pkg-config or system.\nGTest and GMock come as sources that must be compiled as part of your\nproject. With Meson you don't have to care about the details, just\npass gtest or gmock to dependency and it will do everything for\nyou. If you want to use GMock, it is recommended to use GTest as well,\nas getting it to work standalone is tricky.\nYou can set the main keyword argument to true to use the main()\nfunction provided by GTest:\n(added 0.50.0)\nHDF5 is supported for C, C++ and Fortran. Because dependencies are\nlanguage-specific, you must specify the requested language using the\nlanguage keyword argument, i.e.,\nMeson uses pkg-config to find HDF5. The standard low-level HDF5\nfunction and the HL high-level HDF5 functions are linked for each\nlanguage.\nmethod may be auto, config-tool or pkg-config.\nNew in 0.56.0 the config-tool method.\nNew in 0.56.0 the dependencies now return proper dependency types\nand get_variable and similar methods should work as expected.\n(added 0.44.0)\nmethod may be auto, config-tool or pkg-config.\nMeson has native support for LLVM going back to version LLVM version\n3.5. It supports a few additional features compared to other\nconfig-tool based dependencies.\nAs of 0.44.0 Meson supports the static keyword argument for LLVM.\nBefore this LLVM >= 3.9 would always dynamically link, while older\nversions would statically link, due to a quirk in llvm-config.\nmethod may be auto, config-tool, or cmake.\nMeson wraps LLVM's concept of components in it's own modules concept.\nWhen you need specific components you add them as modules as Meson\nwill do the right thing:\nAs of 0.44.0 it can also take optional modules (these will affect the arguments\ngenerated for a static link):\nWhen using LLVM as library but also needing its tools, it is often\nbeneficial to use the same version. This can partially be achieved\nwith the version argument of find_program(). However,\ndistributions tend to package different LLVM versions in rather\ndifferent ways. Therefore, it is often better to use the llvm\ndependency directly to retrieve the tools:\n(added 0.42.0)\nMPI is supported for C, C++ and Fortran. Because dependencies are\nlanguage-specific, you must specify the requested language using the\nlanguage keyword argument, i.e.,\nMeson prefers pkg-config for MPI, but if your MPI implementation does\nnot provide them, it will search for the standard wrapper executables,\nmpic, mpicxx, mpic++, mpifort, mpif90, mpif77. If these\nare not in your path, they can be specified by setting the standard\nenvironment variables MPICC, MPICXX, MPIFC, MPIF90, or\nMPIF77, during configuration. It will also try to use the Microsoft\nimplementation on windows via the system method.\nmethod may be auto, config-tool, pkg-config or system.\nNew in 0.54.0 The config-tool and system method values. Previous\nversions would always try pkg-config, then config-tool, then system.\n(added 0.50.0)\nNetCDF is supported for C, C++ and Fortran. Because NetCDF dependencies are\nlanguage-specific, you must specify the requested language using the\nlanguage keyword argument, i.e.,\nMeson uses pkg-config to find NetCDF.\n(added 0.46.0)\nThis dependency selects the appropriate compiler flags and/or libraries to use\nfor OpenMP support.\nThe language keyword may used.\n(added 0.42.0)\nmethod may be auto, config-tool or pkg-config.\n(added 0.49.0)\nmethod may be auto, config-tool or pkg-config.\n(added 0.51.0)\nmethod may be auto, config-tool or pkg-config.\nPython3 is handled specially by Meson:\nNote that python3 found by this dependency might differ from the one\nused in python3 module because modules uses the current interpreter,\nbut dependency tries pkg-config first.\nmethod may be auto, extraframework, pkg-config or sysconfig\nMeson has native Qt support. Its usage is best demonstrated with an\nexample.\nHere we have an UI file created with Qt Designer and one source and\nheader file each that require preprocessing with the moc tool. We\nalso define a resource file to be compiled with rcc. We just have to\ntell Meson which files are which and it will take care of invoking all\nthe necessary tools in the correct order, which is done with the\npreprocess method of the qt5 module. Its output is simply put in\nthe list of sources for the target. The modules keyword of\ndependency works just like it does with Boost. It tells which\nsubparts of Qt the program uses.\nYou can set the main keyword argument to true to use the\nWinMain() function provided by qtmain static library (this argument\ndoes nothing on platforms other than Windows).\nSetting the optional private_headers keyword to true adds the\nprivate header include path of the given module(s) to the compiler\nflags. (since v0.47.0)\nNote using private headers in your project is a bad idea, do so at\nyour own risk.\nmethod may be auto, pkg-config or qmake.\nSDL2 can be located using pkg-confg, the sdl2-config config tool,\nor as an OSX framework.\nmethod may be auto, config-tool, extraframework or\npkg-config.\nThis dependency selects the appropriate compiler flags and/or\nlibraries to use for thread support.\nSee threads.\nMeson will find valgrind using pkg-config, but only uses the\ncompilation flags and avoids trying to link with it's non-PIC static\nlibs.\n(added 0.42.0)\nVulkan can be located using pkg-config, or the VULKAN_SDK\nenvironment variable.\nmethod may be auto, pkg-config or system.\nSimilar to Boost, WxWidgets is not a single library but rather\na collection of modules. WxWidgets is supported via wx-config.\nMeson substitutes modules to wx-config invocation, it generates\n(added 0.51.0)\nShaderc currently does not ship with any means of detection.\nNevertheless, Meson can try to detect it using pkg-config, but will\ndefault to looking for the appropriate library manually. If the\nstatic keyword argument is true, shaderc_combined is preferred.\nOtherwise, shaderc_shared is preferred. Note that it is not possible\nto obtain the shaderc version using this method.\nmethod may be auto, pkg-config or system.\nZlib ships with pkg-config and cmake support, but on some operating\nsystems (windows, macOs, FreeBSD, dragonflybsd), it is provided as\npart of the base operating system without pkg-config support. The new\nSystem finder can be used on these OSes to link with the bundled\nversion.\nmethod may be auto, pkg-config, cmake, or system.\nNew in 0.54.0 the system method.\n(Since 0.54.0)\nCurses (and ncurses) are a cross platform pain in the butt. Meson\nwraps up these dependencies in the curses dependency. This covers\nboth ncurses (preferred) and other curses implementations.\nmethod may be auto, pkg-config, config-tool, or system.\nNew in 0.56.0 The config-tool and system methods.\n\n\ndependency('hdf5', language: 'c') for the C HDF5 headers and libraries\n\ndependency('hdf5', language: 'cpp') for the C++ HDF5 headers and libraries\n\ndependency('hdf5', language: 'fortran') for the Fortran HDF5 headers and libraries\n\n\n\ndependency('mpi', language: 'c') for the C MPI headers and libraries\n\ndependency('mpi', language: 'cpp') for the C++ MPI headers and libraries\n\ndependency('mpi', language: 'fortran') for the Fortran MPI headers and libraries\n\n\n\ndependency('netcdf', language: 'c') for the C NetCDF headers and libraries\n\ndependency('netcdf', language: 'cpp') for the C++ NetCDF headers and libraries\n\ndependency('netcdf', language: 'fortran') for the Fortran NetCDF headers and libraries\n\n\nOn Windows the fallback is the current python3 interpreter.\nOn OSX the fallback is a framework dependency from /Library/Frameworks.\n\n\n\ncompile_args using wx-config --cxxflags $modules...\n\n\nlink_args using wx-config --libs $modules...\n\n\n"});