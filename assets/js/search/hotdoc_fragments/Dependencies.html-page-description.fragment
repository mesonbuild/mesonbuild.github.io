fragment_downloaded_cb({"url":"Dependencies.html#page-description","fragment":"Very few applications are fully self-contained, but rather they use\nexternal libraries and frameworks to do their work. Meson makes it\nvery easy to find and use external dependencies. Here is how one would\nuse the zlib compression library.\nFirst Meson is told to find the external library zlib and error out\nif it is not found. The version keyword is optional and specifies a\nversion requirement for the dependency. Then an executable is built\nusing the specified dependency. Note how the user does not need to\nmanually handle compiler or linker flags or deal with any other\nminutiae.\nIf you have multiple dependencies, pass them as an array:\nIf the dependency is optional, you can tell Meson not to error out if\nthe dependency is not found and then do further configuration.\nYou can pass the opt_dep variable to target construction functions\nwhether the actual dependency was found or not. Meson will ignore\nnon-found dependencies.\nMeson also allows to get variables that are defined in the\npkg-config file. This can be done by using the\nget_pkgconfig_variable function.\nThese variables can also be redefined by passing the define_variable\nparameter, which might be useful in certain situations:\nThe dependency detector works with all libraries that provide a\npkg-config file. Unfortunately several packages don't provide\npkg-config files. Meson has autodetection support for some of these,\nand they are described later in this\npage.\nNote new in 0.51.0\nnew in 0.54.0, the internal keyword\nWhen you need to get an arbitrary variables from a dependency that can be\nfound multiple ways and you don't want to constrain the type you can use\nthe generic get_variable method. This currently supports cmake, pkg-config,\nand config-tool based variables.\nIt accepts the keywords 'cmake', 'pkgconfig', 'pkgconfig_define',\n'configtool', 'internal', and 'default_value'. 'pkgconfig_define' works just\nlike the 'define_variable' argument to get_pkgconfig_variable. When this\nmethod is invoked the keyword corresponding to the underlying type of the\ndependency will be used to look for a variable. If that variable cannot be\nfound or if the caller does not provide an argument for the type of\ndependency, one of the following will happen: If 'default_value' was provided\nthat value will be returned, if 'default_value' was not provided then an\nerror will be raised.\nYou can declare your own dependency objects that can be used\ninterchangeably with dependency objects obtained from the system. The\nsyntax is straightforward:\nThis declares a dependency that adds the given include directories and\nstatic library to any target you use it in.\nMany platforms do not provide a system package manager. On these\nsystems dependencies must be compiled from source. Meson's subprojects\nmake it simple to use system dependencies when they are available and\nto build dependencies manually when they are not.\nTo make this work, the dependency must have Meson build definitions\nand it must declare its own dependency like this:\nThen any project that wants to use it can write out the following\ndeclaration in their main meson.build file.\nWhat this declaration means is that first Meson tries to look up the\ndependency from the system (such as by using pkg-config). If it is not\navailable, then it builds subproject named foo and from that\nextracts a variable foo_dep. That means that the return value of\nthis function is either an external or an internal dependency\nobject. Since they can be used interchangeably, the rest of the build\ndefinitions do not need to care which one it is. Meson will take care\nof all the work behind the scenes to make this work.\nYou can use the keyword method to let meson know what method to use\nwhen searching for the dependency. The default value is auto.\nAdditional dependencies methods are pkg-config, config-tool, cmake,\nsystem, sysconfig, qmake, extraframework and dub.\nThe dependency method order for auto is:\nMeson can use the CMake find_package() function to detect\ndependencies with the builtin Find<NAME>.cmake modules and exported\nproject configurations (usually in /usr/lib/cmake). Meson is able\nto use both the old-style <NAME>_LIBRARIES variables as well as\nimported targets.\nIt is possible to manually specify a list of CMake targets that should\nbe used with the modules property. However, this step is optional\nsince meson tries to automatically guess the correct target based on the\nname of the dependency.\nDepending on the dependency it may be necessary to explicitly specify\na CMake target with the modules property if meson is unable to guess\nit automatically.\nSupport for adding additional COMPONENTS for the CMake find_package lookup\nis provided with the components kwarg (introduced in 0.54.0). All specified\ncomponets will be passed directly to find_package(COMPONENTS).\nIt is also possible to reuse existing Find<name>.cmake files with the\ncmake_module_path property. Using this property is equivalent to setting the\nCMAKE_MODULE_PATH variable in CMake. The path(s) given to cmake_module_path\nshould all be relative to the project source directory. Absolute paths\nshould only be used if the CMake files are not stored in the project itself.\nAdditional CMake parameters can be specified with the cmake_args property.\nPlease understand that meson is only able to find dependencies that\nexist in the local Dub repository. You need to manually fetch and\nbuild the target dependencies.\nFor urld.\nOther thing you need to keep in mind is that both meson and Dub need\nto be using the same compiler. This can be achieved using Dub's\n-compiler argument and/or manually setting the DC environment\nvariable when running meson.\nSome dependencies have specific detection logic.\nGeneric dependency names are case-sensitive1,\nbut these dependency names are matched case-insensitively.  The\nrecommended style is to write them in all lower-case.\nIn some cases, more than one detection method exists, and the method keyword\nmay be used to select a detection method to use.  The auto method uses any\nchecking mechanisms in whatever order meson thinks is best.\ne.g. libwmf and CUPS provide both pkg-config and config-tool support. You can\nforce one or another via the method keyword:\nCUPS, LLVM, pcap, WxWidgets,\nlibwmf, GCrypt, GPGME, and GnuStep either do not provide pkg-config\nmodules or additionally can be detected via a config tool\n(cups-config, llvm-config, libgcrypt-config, etc). Meson has native support for these\ntools, and they can be found like other dependencies:\nSince 0.55.0 Meson won't search $PATH any more for a config tool binary when\ncross compiling if the config tool did not have an entry in the cross file.\nUse the modules keyword to list frameworks required, e.g.\nThese dependencies can never be found for non-OSX hosts.\nEnable support for Clang's blocks extension.\n(added 0.52.0)\nBoost is not a single dependency but rather a group of different\nlibraries. To use Boost headers-only libraries, simply add Boost as a\ndependency.\nTo link against boost with Meson, simply list which libraries you\nwould like to use.\nYou can call dependency multiple times with different modules and\nuse those to link against your targets.\nIf your boost headers or libraries are in non-standard locations you\ncan set the BOOST_ROOT, or the BOOST_INCLUDEDIR and BOOST_LIBRARYDIR\nenvironment variables. (added in 0.56.0) You can also set these\nparameters as boost_root, boost_include, and boost_librarydir in your\nnative or cross machine file. Note that machine file variables are\npreferred to environment variables, and that specifying any of these\ndisables system-wide search for boost.\nYou can set the argument threading to single to use boost\nlibraries that have been compiled for single-threaded use instead.\n(added 0.53.0)\nEnables compiling and linking against the CUDA Toolkit. The version\nand modules keywords may be passed to request the use of a specific\nCUDA Toolkit version and/or additional CUDA libraries, correspondingly:\nNote that explicitly adding this dependency is only necessary if you are\nusing CUDA Toolkit from a C/C++ file or project, or if you are utilizing\nadditional toolkit libraries that need to be explicitly linked to.\nmethod may be auto, config-tool, pkg-config, cmake or extraframework.\n(added 0.50.0)\nCoarrays are a Fortran language intrinsic feature, enabled by\ndependency('coarray').\nGCC will use OpenCoarrays if present to implement coarrays, while Intel and NAG\nuse internal coarray support.\nThis finds the OpenGL library in a way appropriate to the platform.\nmethod may be auto, pkg-config or system.\nGTest and GMock come as sources that must be compiled as part of your\nproject. With Meson you don't have to care about the details, just\npass gtest or gmock to dependency and it will do everything for\nyou. If you want to use GMock, it is recommended to use GTest as well,\nas getting it to work standalone is tricky.\nYou can set the main keyword argument to true to use the main()\nfunction provided by GTest:\n(added 0.50.0)\nHDF5 is supported for C, C++ and Fortran. Because dependencies are\nlanguage-specific, you must specify the requested language using the\nlanguage keyword argument, i.e.,\nMeson uses pkg-config to find HDF5. The standard low-level HDF5 function and the HL high-level HDF5 functions are linked for each language.\nmethod may be auto, config-tool or pkg-config.\nNew in 0.56.0 the config-tool method.\nNew in 0.56.0 the dependencies now return proper dependency types and get_variable and similar methods should work as expected.\n(added 0.44.0)\nmethod may be auto, config-tool or pkg-config.\nMeson has native support for LLVM going back to version LLVM version 3.5.\nIt supports a few additional features compared to other config-tool based\ndependencies.\nAs of 0.44.0 Meson supports the static keyword argument for\nLLVM. Before this LLVM >= 3.9 would always dynamically link, while\nolder versions would statically link, due to a quirk in llvm-config.\nmethod may be auto, config-tool, or cmake.\nMeson wraps LLVM's concept of components in it's own modules concept.\nWhen you need specific components you add them as modules as meson\nwill do the right thing:\nAs of 0.44.0 it can also take optional modules (these will affect the arguments\ngenerated for a static link):\nWhen using LLVM as library but also needing its tools, it is often beneficial to use the same version.\nThis can partially be achieved with the version argument of find_program().\nHowever, distributions tend to package different LLVM versions in rather different ways.\nTherefore, it is often better to use the llvm dependency directly to retrieve the tools:\n(added 0.42.0)\nMPI is supported for C, C++ and Fortran. Because dependencies are\nlanguage-specific, you must specify the requested language using the\nlanguage keyword argument, i.e.,\nMeson prefers pkg-config for MPI, but if your MPI implementation does\nnot provide them, it will search for the standard wrapper executables,\nmpic, mpicxx, mpic++, mpifort, mpif90, mpif77. If these\nare not in your path, they can be specified by setting the standard\nenvironment variables MPICC, MPICXX, MPIFC, MPIF90, or\nMPIF77, during configuration. It will also try to use the Microsoft\nimplementation on windows via the system method.\nmethod may be auto, config-tool, pkg-config or system.\nNew in 0.54.0 The config-tool and system method values. Previous\nversions would always try pkg-config, then config-tool, then system.\n(added 0.50.0)\nNetCDF is supported for C, C++ and Fortran. Because NetCDF dependencies are\nlanguage-specific, you must specify the requested language using the\nlanguage keyword argument, i.e.,\nMeson uses pkg-config to find NetCDF.\n(added 0.46.0)\nThis dependency selects the appropriate compiler flags and/or libraries to use\nfor OpenMP support.\nThe language keyword may used.\n(added 0.42.0)\nmethod may be auto, config-tool or pkg-config.\n(added 0.49.0)\nmethod may be auto, config-tool or pkg-config.\n(added 0.51.0)\nmethod may be auto, config-tool or pkg-config.\nPython3 is handled specially by meson:\nNote that python3 found by this dependency might differ from the one used in\npython3 module because modules uses the current interpreter, but dependency tries\npkg-config first.\nmethod may be auto, extraframework, pkg-config or sysconfig\nMeson has native Qt support. Its usage is best demonstrated with an\nexample.\nHere we have an UI file created with Qt Designer and one source and\nheader file each that require preprocessing with the moc tool. We\nalso define a resource file to be compiled with rcc. We just have to\ntell Meson which files are which and it will take care of invoking all\nthe necessary tools in the correct order, which is done with the\npreprocess method of the qt5 module. Its output is simply put in\nthe list of sources for the target. The modules keyword of\ndependency works just like it does with Boost. It tells which\nsubparts of Qt the program uses.\nYou can set the main keyword argument to true to use the WinMain()\nfunction provided by qtmain static library (this argument does nothing on platforms\nother than Windows).\nSetting the optional private_headers keyword to true adds the private header\ninclude path of the given module(s) to the compiler flags.  (since v0.47.0)\nNote using private headers in your project is a bad idea, do so at your own\nrisk.\nmethod may be auto, pkg-config or qmake.\nSDL2 can be located using pkg-confg, the sdl2-config config tool, or as an\nOSX framework.\nmethod may be auto, config-tool, extraframework or pkg-config.\nThis dependency selects the appropriate compiler flags and/or libraries to use\nfor thread support.\nSee threads.\nMeson will find valgrind using pkg-config, but only uses the compilation flags\nand avoids trying to link with it's non-PIC static libs.\n(added 0.42.0)\nVulkan can be located using pkg-config, or the VULKAN_SDK environment variable.\nmethod may be auto, pkg-config or system.\nSimilar to Boost, WxWidgets is not a single library but rather\na collection of modules. WxWidgets is supported via wx-config.\nMeson substitutes modules to wx-config invocation, it generates\n(added 0.51.0)\nShaderc currently does not ship with any means of detection. Nevertheless, Meson\ncan try to detect it using pkg-config, but will default to looking for the\nappropriate library manually. If the static keyword argument is true,\nshaderc_combined is preferred. Otherwise, shaderc_shared is preferred. Note\nthat it is not possible to obtain the shaderc version using this method.\nmethod may be auto, pkg-config or system.\nZlib ships with pkg-config and cmake support, but on some operating systems\n(windows, macOs, FreeBSD, dragonflybsd), it is provided as part of the base\noperating system without pkg-config support. The new System finder can be used\non these OSes to link with the bundled version.\nmethod may be auto, pkg-config, cmake, or system.\nNew in 0.54.0 the system method.\n(Since 0.54.0)\nCurses (and ncurses) are a cross platform pain in the butt. Meson wraps up\nthese dependencies in the curses dependency. This covers both ncurses\n(preferred) and other curses implementations.\nmethod may be auto, pkg-config, config-tool, or system.\nNew in 0.56.0 The config-tool and system methods.\n\n\ndependency('hdf5', language: 'c') for the C HDF5 headers and libraries\n\ndependency('hdf5', language: 'cpp') for the C++ HDF5 headers and libraries\n\ndependency('hdf5', language: 'fortran') for the Fortran HDF5 headers and libraries\n\n\n\ndependency('mpi', language: 'c') for the C MPI headers and libraries\n\ndependency('mpi', language: 'cpp') for the C++ MPI headers and libraries\n\ndependency('mpi', language: 'fortran') for the Fortran MPI headers and libraries\n\n\n\ndependency('netcdf', language: 'c') for the C NetCDF headers and libraries\n\ndependency('netcdf', language: 'cpp') for the C++ NetCDF headers and libraries\n\ndependency('netcdf', language: 'fortran') for the Fortran NetCDF headers and libraries\n\n\nOn Windows the fallback is the current python3 interpreter.\nOn OSX the fallback is a framework dependency from /Library/Frameworks.\n\n\n\ncompile_args using wx-config --cxxflags $modules...\n\n\nlink_args using wx-config --libs $modules...\n\n\n"});