fragment_downloaded_cb({"url":"SourceSet-module.html#page-description","fragment":"This module provides support for building many targets against a\nsingle set of files; the choice of which files to include in each\ntarget depends on the contents of a dictionary or a\nconfiguration_data object. The module can be loaded with:\nA simple example of using the module looks like this:\nand it would be equivalent to\nSourcesets can be used with a single invocation of the apply method,\nsimilar to the example above, but the module is especially useful when\nmultiple executables are generated by applying the same rules to many\ndifferent configurations.\nAdded 0.51.0\nCreate and return a new source set object.\nReturns: a source set\nThe source_set object provides methods to add files to a source set\nand to query it. The source set becomes immutable after any method but\nadd is called.\nAdd a rule to a source set. A rule determines the conditions under\nwhich some source files or dependency objects are included in a build\nconfiguration. All source files must be present in the source tree or\nthey can be created in the build tree via configure_file,\ncustom_target or generator.\nvarnames_and_deps is a list of conditions for the rule, which can be\neither strings or dependency objects (a dependency object is anything\nthat has a found() method). If all the strings evaluate to true\nand all dependencies are found, the rule will evaluate to true;\napply() will then include the contents of the if_true keyword\nargument in its result. Otherwise, that is if any of the strings in\nthe positional arguments evaluate to false or any dependency is not\nfound, apply() will instead use the contents of the if_false\nkeyword argument.\nDependencies can also appear in sources_and_deps. In this case, a\nmissing dependency will simply be ignored and will not disable the\nrule, similar to how the dependencies keyword argument works in\nbuild targets.\nNote: It is generally better to avoid mixing source sets and\ndisablers. This is because disablers will cause the rule to be dropped\naltogether, and the list_of_alt_sources would not be taken into\naccount anymore.\nAdd one or more source sets to another.\nFor each source set listed in the arguments, apply() will consider\ntheir rules only if the conditions in varnames_and_deps are\nevaluated positively. For example, the following:\nis equivalent to:\nReturns a list of all sources that were placed in the source set using\nadd (including nested source sets) and that do not have a not-found\ndependency. If a rule has a not-found dependency, only the if_false\nsources are included (if any).\nReturns: a list of file objects\nReturns a list of all dependencies that were placed in the source set\nusing add (including nested source sets) and that were found.\nReturns: a list of dependencies\nMatch the source set against a dictionary or a configuration_data\nobject and return a source configuration object. A source\nconfiguration object allows you to retrieve the sources and\ndependencies for a specific configuration.\nBy default, all the variables that were specified in the rules have to\nbe present in conf_data. However, in some cases the convention is\nthat false configuration symbols are absent in conf_data; this is\nthe case for example when the configuration was loaded from a Kconfig\nfile. In that case you can specify the strict: false keyword\nargument, which will treat absent variables as false.\nReturns: a source configuration\nThe source_configuration object provides methods to query the result of an\napply operation on a source set.\nReturn the source files corresponding to the applied configuration.\nReturns: a list of file objects\nReturn the dependencies corresponding to the applied configuration.\nReturns: a list of dependency objects\n"});