fragment_downloaded_cb({"url":"Design-rationale.html#overview-of-the-solution","fragment":"Overview of the solution\nGoing over these requirements it becomes quite apparent that the only\nviable approach is roughly the same as taken by CMake: having a domain\nspecific language to declare the build system. Out of this declaration\na configuration is generated for the backend build system. This can be\na Makefile, Visual Studio or XCode project or anything else.\nThe difference between the proposed DSL and existing ones is that the\nnew one is declarative. It also tries to work on a higher level of\nabstraction than existing systems. As an example, using external\nlibraries in current build systems means manually extracting and\npassing around compiler flags and linker flags. In the proposed system\nthe user just declares that a given build target uses a given external\ndependency. The build system then takes care of passing all flags and\nsettings to their proper locations. This means that the user can focus\non their own code rather than marshalling command line arguments from\none place to another.\nA DSL is more work than the approach taken by SCons, which is to\nprovide the system as a Python library. However it allows us to make\nthe syntax more expressive and prevent certain types of bugs by\ne.g. making certain objects truly immutable. The end result is again\nthe same: less work for the user.\nThe backend for Unix requires a bit more thought. The default choice\nwould be Make. However it is extremely slow. It is not uncommon on\nlarge code bases for Make to take several minutes just to determine\nthat nothing needs to be done. Instead of Make we use\nNinja, which is extremely fast. The\nbackend code is abstracted away from the core, so other backends can\nbe added with relatively little effort.\n"});