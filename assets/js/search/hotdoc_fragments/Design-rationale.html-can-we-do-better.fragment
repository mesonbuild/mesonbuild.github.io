fragment_downloaded_cb({"url": "Design-rationale.html#can-we-do-better", "fragment": "Can we do better \nAt its core building C and C code is not a terribly difficult task. In fact writing a text editor is a lot more complicated and takes more effort. Yet we have lots of very high quality editors but only few build systems with questionable quality and usability. \nSo in the grand tradition of own itch scratching I decided to run a scientific experiment. The purpose of this experiment was to explore what would it take to build a good build system. What kind of syntax would suit this problem What sort of problems would this application need to solve What sort of solutions would be the most appropriate \nTo get things started here is a list of requirements any modern cross platform build system needs to provide. \nMust be simple to use \nOne of the great virtues of Python is the fact that it is very readable. It is easy to see what a given block of code does. It is concise clear and easy to understand. The proposed build system must be syntactically and semantically clean. Side effects global state and interrelations must be kept at a minimum or if possible eliminated entirely. \nMust do the right thing by default \nMost builds are done by developers working on the code. Therefore the defaults must be tailored towards that use case. As an example the system shall build objects without optimization and with debug information. It shall make binaries that can be run directly from the build directory without linker tricks shell scripts or magic environment variables. \nMust enforce established best practices \nThere really is no reason to compile source code without the equivalent of Wall. So enable it by default. A different kind of best practice is the total separation of source and build directories. All build artifacts must be stored in the build directory. Writing stray files in the source directory is not permitted under any circumstances. \nMust have native support for platforms that are in common use \nA lot of free software projects can be used on non free platforms such as Windows or OSX. The system must provide native support for the tools of choice on those platforms. In practice this means native support for Visual Studio and XCode. Having said IDEs invoke external builder binaries does not count as native support. \nMust not add complexity due to obsolete platforms \nWork on this build system started during the Christmas holidays of This provides a natural hard cutoff line of Any platform tool or library that was not in active use at that time is explicitly not supported. These include Unixes such as IRIX SunOS OSF Ubuntu versions older than GCC versions older than and so on. If these old versions happen to work great. If they don t not a single line of code will be added to the system to work around their bugs. \nMust be fast \nRunning the configuration step on a moderate sized project must not take more than five seconds. Running the compile command on a fully up to date tree of source files must not take more than seconds. \nMust provide easy to use support for modern sw development features \nAn example is precompiled headers. Currently no free software build system provides native support for them. Other examples could include easy integration of Valgrind and unit tests test coverage reporting and so on. \nMust allow override of default values \nSometimes you just have to compile files with only given compiler flags and no others or install files in weird places. The system must allow the user to do this if he really wants to. \n"});