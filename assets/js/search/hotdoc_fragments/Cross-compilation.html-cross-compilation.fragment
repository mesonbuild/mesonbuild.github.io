fragment_downloaded_cb({"url":"Cross-compilation.html#cross-compilation","fragment":"Cross compilation\nMeson has full support for cross compilation through the use of\na cross build definition file.  An minimal example of one such\nfile x86_64-w64-mingw32.txt for a GCC/MinGW cross compiler\ntargeting 64-bit Windows could be:\nWhich is then used during the setup phase.\nSince cross compiling is\nmore complicated than native building, let's first go over some\nnomenclature. The three most important definitions are traditionally\ncalled build, host and target. This is confusing because those\nterms are used for quite many different things. To simplify the issue,\nwe are going to call these the build machine, host machine and\ntarget machine. Their definitions are the following:\nThe tl/dr summary is the following: if you are doing regular cross\ncompilation, you only care about build_machine and\nhost_machine. Just ignore target_machine altogether and you will\nbe correct 99% of the time. Only compilers and similar tools care\nabout the target machine. In fact, for so-called \"multi-target\" tools\nthe target machine need not be fixed at build-time like the others but\nchosen at runtime, so target_machine still doesn't matter. If your\nneeds are more complex or you are interested in the actual details, do\nread on.\nThis might be easier to understand through examples. Let's start with\nthe regular, not cross-compiling case. In these cases all of these\nthree machines are the same. Simple so far.\nLet's next look at the most common cross-compilation setup. Let's\nsuppose you are on a 64 bit OSX machine and you are cross compiling a\nbinary that will run on a 32 bit ARM Linux board. In this case your\nbuild machine is 64 bit OSX, your host machine is 32 bit ARM Linux\nand your target machine is irrelevant (but defaults to the same\nvalue as the host machine). This should be quite understandable as\nwell.\nThe usual mistake in this case is to call the OSX system the host\nand the ARM Linux board the target. That's because these were their\nactual names when the cross-compiler itself was compiled! Let's assume\nthe cross-compiler was created on OSX too. When that happened the\nbuild and host machines were the same OSX and different from the\nARM Linux target machine.\nIn a nutshell, the typical mistake assumes that the terms build,\nhost and target refer to some fixed positions whereas they're\nactually relative to where the current compiler is running. Think of\nhost as a child of the current compiler and target as an\noptional grand-child. Compilers don't change their terminology when\nthey're creating another compiler, that would at the very least make\ntheir user interface much more complex.\nThe most complicated case is when you cross-compile a cross compiler.\nAs an example you can, on a Linux machine, generate a cross compiler\nthat runs on Windows but produces binaries for MIPS Linux. In this case\nbuild machine is x86 Linux, host machine is x86 Windows and\ntarget machine is MIPS Linux. This setup is known as the Canadian\nCross.\nAs a side note, be careful when reading cross compilation articles on\nWikipedia or the net in general. It is very common for them to get\nbuild, host and target mixed up, even in consecutive sentences, which\ncan leave you puzzled until you figure it out.\nAgain note that when you cross-compile something, the 3 systems\n(build, host, and target) used when building the cross compiler\ndon't align with the ones used when building something with that\nnewly-built cross compiler. To take our Canadian Cross scenario from\nabove (for full generality), since its host machine is x86 Windows,\nthe build machine of anything we build with it is x86 Windows. And\nsince its target machine is MIPS Linux, the host machine of\nanything we build with it is MIPS Linux. Only the target machine\nof whatever we build with it can be freely chosen by us, say if we\nwant to build another cross compiler that runs on MIPS Linux and\ntargets Aarch64 iOS. As this example hopefully makes clear to you, the\nmachine names are relative and shifted over to the left by one\nposition.\nIf you did not understand all of the details, don't worry. For most\npeople it takes a while to wrap their head around these concepts.\nDon't panic, it might take a while to click, but you will get the hang\nof it eventually.\n\n\nbuild machine is the computer that is doing the actual compiling.\n\nhost machine is the machine on which the compiled binary will run.\n\ntarget machine is the machine on which the compiled binary's\noutput will run, only meaningful if the program produces\nmachine-specific output.\n\n"});