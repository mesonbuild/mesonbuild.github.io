fragment_downloaded_cb({"url":"IDE-integration.html#page-description","fragment":"Meson has exporters for Visual Studio and XCode, but writing a custom backend\nfor every IDE out there is not a scalable approach. To solve this problem,\nMeson provides an API that makes it easy for any IDE or build tools to\nintegrate Meson builds and provide an experience comparable to a solution\nnative to the IDE.\nAll the resources required for such a IDE integration can be found in\nthe meson-info directory in the build directory.\nThe first thing to do when setting up a Meson project in an IDE is to select\nthe source and build directories. For this example we assume that the source\nresides in an Eclipse-like directory called workspace/project and the build\ntree is nested inside it as workspace/project/build. First, we initialize\nMeson by running the following command in the source directory.\nWith this command meson will configure the project and also generate\nintrospection information that is stored in intro-*.json files in the\nmeson-info directory. The introspection dump will be automatically updated\nwhen meson is (re)configured, or the build options change. Thus, an IDE can\nwatch for changes in this directory to know when something changed. Note that\nmeson-info.json guaranteed to be the last file written.\nThe meson-info directory should contain the following files:\nThe content of the JSON files is further specified in the remainder of this document.\nThe most important file for an IDE is probably intro-targets.json. Here each\ntarget with its sources and compiler parameters is specified. The JSON format\nfor one target is defined as follows:\nIf the key installed is set to true, the key install_filename will also\nbe present. It stores the installation location for each file in filename.\nIf one file in filename is not installed, its corresponding install location\nis set to null.\nThe subproject key specifies the name of the subproject this target was\ndefined in, or null if the target was defined in the top level project.\nA target usually generates only one file. However, it is possible for custom\ntargets to have multiple outputs.\nThe intro-targets.json file also stores a list of all source objects of the\ntarget in the target_sources. With this information, an IDE can provide code\ncompletion for all source files.\nIt should be noted that the compiler parameters stored in the parameters\ndiffer from the actual parameters used to compile the file. This is because\nthe parameters are optimized for the usage in an IDE to provide autocompletion\nsupport, etc. It is thus not recommended to use this introspection information\nfor actual compilation.\nThe following table shows all valid types for a target.\nIt is also possible to get most targets without a build directory. This can be\ndone by running meson introspect --targets /path/to/meson.build.\nThe generated output is similar to running the introspection with a build\ndirectory or reading the intro-targets.json. However, there are some key\ndifferences:\nThere is no guarantee that the sources list in target_sources is correct.\nThere might be differences, due to internal limitations. It is also not\nguaranteed that all targets will be listed in the output. It might even be\npossible that targets are listed, which won't exist when meson is run normally.\nThis can happen if a target is defined inside an if statement.\nUse this feature with care.\nThe list of all build options (build type, warning level, etc.) is stored in\nthe intro-buildoptions.json file. Here is the JSON format for each option.\nThe supported types are:\nFor the type combo the key choices is also present. Here all valid values\nfor the option are stored.\nThe possible values for section are:\nThe machine key specifies the machine configuration for the option. Possible\nvalues are:\nTo set the options, use the meson configure command.\nSince Meson 0.50.0 it is also possible to get the default buildoptions\nwithout a build directory by providing the root meson.build instead of a\nbuild directory to meson introspect --buildoptions.\nRunning --buildoptions without a build directory produces the same output as\nrunning it with a freshly configured build directory.\nHowever, this behavior is not guaranteed if subprojects are present. Due to\ninternal limitations all subprojects are processed even if they are never used\nin a real meson run. Because of this options for the subprojects can differ.\nThe list of all found dependencies can be acquired from\nintro-dependencies.json. Here, the name, version, compiler and linker\narguments for a dependency are listed.\nIt is also possible to get most dependencies used without a build directory.\nThis can be done by running meson introspect --scan-dependencies /path/to/meson.build.\nThe output format is as follows:\nThe required keyword specifies whether the dependency is marked as required\nin the meson.build (all dependencies are required by default). The\nconditional key indicates whether the dependency() function was called\ninside a conditional block. In a real meson run these dependencies might not be\nused, thus they may not be required, even if the required key is set. The\nhas_fallback key just indicates whether a fallback was directly set in the\ndependency() function. The version key always contains a list of version\nrequirements from the meson.build and not the actual version of the\ndependency on disc. The version list is empty if no version was specified\nin the meson.build.\nCompilation and unit tests are done as usual by running the meson compile and\nmeson test commands. A JSON formatted result log can be found in\nworkspace/project/builddir/meson-logs/testlog.json.\nWhen these tests fail, the user probably wants to run the failing test in a\ndebugger. To make this as integrated as possible, extract the tests from the\nintro-tests.json and intro-benchmarks.json files. This provides you with\nall the information needed to run the test: what command to execute, command\nline arguments, environment variable settings and how to process the output.\nIt is also possible to get Meson build files used in your current project. This\ncan be done by running meson introspect --buildsystem-files /path/to/builddir.\nThe output format is as follows:\nMeson also provides the meson introspect for project introspection via the\ncommand line. Use meson introspect -h to see all available options.\nThis API can also work without a build directory for the --projectinfo command.\nSince meson 0.55.0 it is possible to dump the AST of a meson.build as a JSON\nobject. The interface for this is meson introspect --ast /path/to/meson.build.\nEach node of the AST has at least the following entries:\nPossible values for node with additional keys:\nWe do not guarantee the stability of this format since it is heavily linked to\nthe internal Meson AST. However, breaking changes (removal of a node type or the\nremoval of a key) are unlikely and will be announced in the release notes.\n\nThe paths in filename now are relative to the future build directory\nThe install_filename key is completely missing\nThere is only one entry in target_sources:\n\nWith the language set to unknown\n\nEmpty lists for compiler and parameters and generated_sources\n\nThe sources list should contain all sources of the target\n\n\n\n\nWith the language set to unknown\n\nEmpty lists for compiler and parameters and generated_sources\n\nThe sources list should contain all sources of the target\n\n\nstring\nboolean\ncombo\ninteger\narray\n\n\ncore\nbackend\nbase\ncompiler\ndirectory\nuser\ntest\n\n\nany\nhost\nbuild\n\n\nGnome Builder\nKDevelop\n\nEclipse CDT (experimental)\n\nMeson Cmake Wrapper (for cmake IDEs) (currently unmaintained !!)\n\nMeson-UI (Meson build GUI)\n\nMeson Syntax Highlighter plugin for JetBrains IDEs.\n\n\n\n\n File\n Description\n\n\n\n\n intro-benchmarks.json\n\n Lists all benchmarks\n\n\n intro-buildoptions.json\n\n Contains a full list of meson configuration options for the project\n\n\n intro-buildsystem_files.json\n\n Full list of all meson build files\n\n\n intro-dependencies.json\n\n Lists all dependencies used in the project\n\n\n intro-installed.json\n\n Contains mapping of files to their installed location\n\n\n intro-projectinfo.json\n\n Stores basic information about the project (name, version, etc.)\n\n\n intro-targets.json\n\n Full list of all build targets\n\n\n intro-tests.json\n\n Lists all tests with instructions how to run them\n\n\n\n\n\n\n value of type\n\n Description\n\n\n\n\n executable\n\n This target will generate an executable file\n\n\n static library\n\n Target for a static library\n\n\n shared library\n\n Target for a shared library\n\n\n shared module\n\n A shared library that is meant to be used with dlopen rather than linking into something else\n\n\n custom\n\n A custom target\n\n\n run\n\n A Meson run target\n\n\n jar\n\n A Java JAR target\n\n\n\n\n\n\n Key\n Description\n\n\n\n\n node\n\n Type of the node (see following table)\n\n\n lineno\n\n Line number of the node in the file\n\n\n colno\n\n Column number of the node in the file\n\n\n end_lineno\n\n Marks the end of the node (may be the same as lineno)\n\n\n end_colno\n\n Marks the end of the node (may be the same as colno)\n\n\n\n\n\n\n Node type\n Additional keys\n\n\n\n\n BooleanNode\n\n value: bool\n\n\n IdNode\n\n value: str\n\n\n NumberNode\n\n value: int\n\n\n StringNode\n\n value: str\n\n\n ContinueNode\n\n\n\n\n BreakNode\n\n\n\n\n ArgumentNode\n\n positional: node list; kwargs: accept_kwargs\n\n\n ArrayNode\n\n args: node\n\n\n DictNode\n\n args: node\n\n\n EmptyNode\n\n\n\n\n OrNode\n\n left: node; right: node\n\n\n AndNode\n\n left: node; right: node\n\n\n ComparisonNode\n\n left: node; right: node; ctype: str\n\n\n ArithmeticNode\n\n left: node; right: node; op: str\n\n\n NotNode\n\n right: node\n\n\n CodeBlockNode\n\n lines: node list\n\n\n IndexNode\n\n object: node; index: node\n\n\n MethodNode\n\n object: node; args: node; name: str\n\n\n FunctionNode\n\n args: node; name: str\n\n\n AssignmentNode\n\n value: node; var_name: str\n\n\n PlusAssignmentNode\n\n value: node; var_name: str\n\n\n ForeachClauseNode\n\n items: node; block: node; varnames: list\n\n\n IfClauseNode\n\n ifs: node list; else: node\n\n\n IfNode\n\n condition: node; block: node\n\n\n UMinusNode\n\n right: node\n\n\n TernaryNode\n\n condition: node; true: node; false: node\n\n\n\n"});