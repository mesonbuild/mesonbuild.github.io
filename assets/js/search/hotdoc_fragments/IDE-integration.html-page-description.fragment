fragment_downloaded_cb({"url":"IDE-integration.html#page-description","fragment":"Meson has exporters for Visual Studio and XCode, but writing a custom\nbackend for every IDE out there is not a scalable approach. To solve\nthis problem, Meson provides an API that makes it easy for any IDE or\nbuild tools to integrate Meson builds and provide an experience\ncomparable to a solution native to the IDE.\nAll the resources required for such a IDE integration can be found in\nthe meson-info directory in the build directory.\nThe first thing to do when setting up a Meson project in an IDE is to\nselect the source and build directories. For this example we assume\nthat the source resides in an Eclipse-like directory called\nworkspace/project and the build tree is nested inside it as\nworkspace/project/build. First, we initialize Meson by running the\nfollowing command in the source directory.\nWith this command meson will configure the project and also generate\nintrospection information that is stored in intro-*.json files in\nthe meson-info directory. The introspection dump will be\nautomatically updated when meson is (re)configured, or the build\noptions change. Thus, an IDE can watch for changes in this directory\nto know when something changed. Note that meson-info.json guaranteed\nto be the last file written.\nThe meson-info directory should contain the following files:\nThe content of the JSON files is further specified in the remainder of\nthis document.\nThe most important file for an IDE is probably intro-targets.json.\nHere each target with its sources and compiler parameters is\nspecified. The JSON format for one target is defined as follows:\nIf the key installed is set to true, the key install_filename\nwill also be present. It stores the installation location for each\nfile in filename. If one file in filename is not installed, its\ncorresponding install location is set to null.\nThe subproject key specifies the name of the subproject this target\nwas defined in, or null if the target was defined in the top level\nproject.\n(New in 0.56.0) The extra_files key lists all files specified via\nthe extra_files kwarg of a build target. See\nexecutable().\nA target usually generates only one file. However, it is possible for\ncustom targets to have multiple outputs.\nThe intro-targets.json file also stores a list of all source objects\nof the target in the target_sources. With this information, an IDE\ncan provide code completion for all source files.\nIt should be noted that the compiler parameters stored in the\nparameters differ from the actual parameters used to compile the\nfile. This is because the parameters are optimized for the usage in an\nIDE to provide autocompletion support, etc. It is thus not recommended\nto use this introspection information for actual compilation.\nThe following table shows all valid types for a target.\nIt is also possible to get most targets without a build directory.\nThis can be done by running meson introspect --targets /path/to/meson.build.\nThe generated output is similar to running the introspection with a\nbuild directory or reading the intro-targets.json. However, there\nare some key differences:\nThere is no guarantee that the sources list in target_sources is\ncorrect. There might be differences, due to internal limitations. It\nis also not guaranteed that all targets will be listed in the output.\nIt might even be possible that targets are listed, which won't exist\nwhen meson is run normally. This can happen if a target is defined\ninside an if statement. Use this feature with care.\nThe list of all build options (build type, warning level, etc.) is\nstored in the intro-buildoptions.json file. Here is the JSON format\nfor each option.\nThe supported types are:\nFor the type combo the key choices is also present. Here all valid\nvalues for the option are stored.\nThe possible values for section are:\nThe machine key specifies the machine configuration for the option.\nPossible values are:\nTo set the options, use the meson configure command.\nSince Meson 0.50.0 it is also possible to get the default buildoptions\nwithout a build directory by providing the root meson.build instead\nof a build directory to meson introspect --buildoptions.\nRunning --buildoptions without a build directory produces the same\noutput as running it with a freshly configured build directory.\nHowever, this behavior is not guaranteed if subprojects are present.\nDue to internal limitations all subprojects are processed even if they\nare never used in a real meson run. Because of this options for the\nsubprojects can differ.\nThe list of all found dependencies can be acquired from\nintro-dependencies.json. Here, the name, version, compiler and\nlinker arguments for a dependency are listed.\nIt is also possible to get most dependencies used without a build\ndirectory. This can be done by running meson introspect --scan-dependencies /path/to/meson.build.\nThe output format is as follows:\nThe required keyword specifies whether the dependency is marked as\nrequired in the meson.build (all dependencies are required by\ndefault). The conditional key indicates whether the dependency()\nfunction was called inside a conditional block. In a real meson run\nthese dependencies might not be used, thus they may not be required,\neven if the required key is set. The has_fallback key just\nindicates whether a fallback was directly set in the dependency()\nfunction. The version key always contains a list of version\nrequirements from the meson.build and not the actual version of\nthe dependency on disc. The version list is empty if no version was\nspecified in the meson.build.\nCompilation and unit tests are done as usual by running the meson compile and meson test commands. A JSON formatted result log can be\nfound in workspace/project/builddir/meson-logs/testlog.json.\nWhen these tests fail, the user probably wants to run the failing test\nin a debugger. To make this as integrated as possible, extract the\ntests from the intro-tests.json and intro-benchmarks.json files.\nThis provides you with all the information needed to run the test:\nwhat command to execute, command line arguments, environment variable\nsettings and how to process the output.\nThe depends entry (since 0.56.0) contains target ids; they can be\nlooked up in the targets introspection data. The executable pointed to\nby cmd is also included in the entry, as are any arguments to the\ntest that are build products.\nIt is also possible to get Meson build files used in your current\nproject. This can be done by running meson introspect --buildsystem-files /path/to/builddir.\nThe output format is as follows:\nMeson also provides the meson introspect for project introspection\nvia the command line. Use meson introspect -h to see all available\noptions.\nThis API can also work without a build directory for the\n--projectinfo command.\nSince meson 0.55.0 it is possible to dump the AST of a meson.build\nas a JSON object. The interface for this is meson introspect --ast /path/to/meson.build.\nEach node of the AST has at least the following entries:\nPossible values for node with additional keys:\nWe do not guarantee the stability of this format since it is heavily\nlinked to the internal Meson AST. However, breaking changes (removal\nof a node type or the removal of a key) are unlikely and will be\nannounced in the release notes.\n\nThe paths in filename now are relative to the future build directory\nThe install_filename key is completely missing\nThere is only one entry in target_sources:\n\nWith the language set to unknown\n\nEmpty lists for compiler and parameters and generated_sources\n\nThe sources list should contain all sources of the target\n\n\n\n\nWith the language set to unknown\n\nEmpty lists for compiler and parameters and generated_sources\n\nThe sources list should contain all sources of the target\n\n\nstring\nboolean\ncombo\ninteger\narray\n\n\ncore\nbackend\nbase\ncompiler\ndirectory\nuser\ntest\n\n\nany\nhost\nbuild\n\n\nGnome Builder\nKDevelop\n\nEclipse CDT (experimental)\n\nMeson Cmake Wrapper (for cmake IDEs) (currently unmaintained !!)\n\nMeson-UI (Meson build GUI)\n\nMeson Syntax Highlighter plugin for JetBrains IDEs.\n\nasabil.meson extension for VS Code/Codium\nQt Creator\n\n\n\n\n File\n Description\n\n\n\n\n intro-benchmarks.json\n\n Lists all benchmarks\n\n\n intro-buildoptions.json\n\n Contains a full list of meson configuration options for the project\n\n\n intro-buildsystem_files.json\n\n Full list of all meson build files\n\n\n intro-dependencies.json\n\n Lists all dependencies used in the project\n\n\n intro-installed.json\n\n Contains mapping of files to their installed location\n\n\n intro-projectinfo.json\n\n Stores basic information about the project (name, version, etc.)\n\n\n intro-targets.json\n\n Full list of all build targets\n\n\n intro-tests.json\n\n Lists all tests with instructions how to run them\n\n\n\n\n\n\n value of type\n\n Description\n\n\n\n\n executable\n\n This target will generate an executable file\n\n\n static library\n\n Target for a static library\n\n\n shared library\n\n Target for a shared library\n\n\n shared module\n\n A shared library that is meant to be used with dlopen rather than linking into something else\n\n\n custom\n\n A custom target\n\n\n run\n\n A Meson run target\n\n\n jar\n\n A Java JAR target\n\n\n\n\n\n\n Key\n Description\n\n\n\n\n node\n\n Type of the node (see following table)\n\n\n lineno\n\n Line number of the node in the file\n\n\n colno\n\n Column number of the node in the file\n\n\n end_lineno\n\n Marks the end of the node (may be the same as lineno)\n\n\n end_colno\n\n Marks the end of the node (may be the same as colno)\n\n\n\n\n\n\n Node type\n Additional keys\n\n\n\n\n BooleanNode\n\n value: bool\n\n\n IdNode\n\n value: str\n\n\n NumberNode\n\n value: int\n\n\n StringNode\n\n value: str\n\n\n ContinueNode\n\n\n\n\n BreakNode\n\n\n\n\n ArgumentNode\n\n positional: node list; kwargs: accept_kwargs\n\n\n ArrayNode\n\n args: node\n\n\n DictNode\n\n args: node\n\n\n EmptyNode\n\n\n\n\n OrNode\n\n left: node; right: node\n\n\n AndNode\n\n left: node; right: node\n\n\n ComparisonNode\n\n left: node; right: node; ctype: str\n\n\n ArithmeticNode\n\n left: node; right: node; op: str\n\n\n NotNode\n\n right: node\n\n\n CodeBlockNode\n\n lines: node list\n\n\n IndexNode\n\n object: node; index: node\n\n\n MethodNode\n\n object: node; args: node; name: str\n\n\n FunctionNode\n\n args: node; name: str\n\n\n AssignmentNode\n\n value: node; var_name: str\n\n\n PlusAssignmentNode\n\n value: node; var_name: str\n\n\n ForeachClauseNode\n\n items: node; block: node; varnames: list\n\n\n IfClauseNode\n\n ifs: node list; else: node\n\n\n IfNode\n\n condition: node; block: node\n\n\n UMinusNode\n\n right: node\n\n\n TernaryNode\n\n condition: node; true: node; false: node\n\n\n\n"});