fragment_downloaded_cb({"url":"Contributing.html#page-description","fragment":"A large fraction of Meson is contributed by people outside the core\nteam. This documentation explains some of the design rationales of\nMeson as well as how to create and submit your patches for inclusion\nto Meson.\nThank you for your interest in participating to the development.\nAll changes must be submitted as pull requests to\nGithub. This causes them\nto be run through the CI system. All submissions must pass a full CI\ntest run before they are even considered for submission.\nIt is possible that while your pull request is being reviewed, other\nchanges are committed to master that cause merge conflicts that must\nbe resolved. The basic rule for this is very simple: keep your pull\nrequest up to date using rebase only.\nDo not merge head back to your branch. Any merge commits in your pull\nrequest make it not acceptable for merging into master and you must\nremove them.\nEvery new feature requires some extra steps, namely:\nThe kind of review and acceptance any merge proposal gets depends on\nthe changes it contains. All pull requests must be reviewed and\naccepted by someone with commit rights who is not the original\nsubmitter. Merge requests can be roughly split into three different\ncategories.\nThe first one consists of MRs that only change the markdown\ndocumentation under docs/markdown. Anyone with access rights can\npush changes to these directly to master. For major changes it is\nstill recommended to create a MR so other people can comment on it.\nThe second group consists of merges that don't change any\nfunctionality, fixes to the CI system and bug fixes that have added\nregression tests (see below) and don't change existing\nfunctionality. Once successfully reviewed anyone with merge rights can\nmerge these to master.\nThe final kind of merges are those that add new functionality or\nchange existing functionality in a backwards incompatible way. These\nrequire the approval of the project lead.\nIn a simplified list form the split would look like the following:\nMeson's merge strategy should fulfill the following guidelines:\npreserve as much history as possible\nhave as little junk in the repo as possible\neverything in the \"master lineage\" should always pass all tests\nThese goals are slightly contradictory so the correct thing to do\noften requires some judgement on part of the person doing the\nmerge. Github provides three different merge options, The rules of\nthumb for choosing between them goes like this:\nsingle commit pull requests should always be rebased\na pull request with one commit and one \"fixup\" commit (such as\ntesting something to see if it passes CI) should be squashed\nlarge branches with many commits should be merged with a merge\ncommit, especially if one of the commits does not pass all tests\n(which happens in e.g. large and difficult refactorings)\nIf in doubt, ask for guidance on IRC.\nAll new features must come with automatic tests that thoroughly prove\nthat the feature is working as expected. Similarly bug fixes must come\nwith a unit test that demonstrates the bug, proves that it has been\nfixed and prevents the feature from breaking in the future.\nSometimes it is difficult to create a unit test for a given bug. If\nthis is the case, note this in your pull request. We may permit bug\nfix merge requests in these cases. This is done on a case by case\nbasis. Sometimes it may be easier to write the test than convince the\nmaintainers that one is not needed. Exercise judgment and ask for help\nin problematic cases.\nThe tests are split into two different parts: unit tests and full\nproject tests. To run all tests, execute ./run_tests.py. Unit tests\ncan be run with ./run_unittests.py and project tests with\n./run_project_tests.py.\nSubsets of project tests can be selected with\n./run_project_tests.py --only option. This can save a great deal of\ntime when only a certain part of Meson is being tested.\nFor example, a useful and easy contribution to Meson is making\nsure the full set of compilers is supported. One could for example test\nvarious Fortran compilers by setting FC=ifort or FC=flang or similar\nwith ./run_project_test.py --only fortran.\nSome families of tests require a particular backend to run.\nFor example, all the CUDA project tests run and pass on Windows via\n./run_project_tests.py --only cuda --backend ninja\nEach project test is a standalone project that can be compiled on its\nown. They are all in the test cases subdirectory. The simplest way to\nrun a single project test is to do something like ./meson.py test\\ cases/common/1\\ trivial builddir. The one exception to this is test cases/unit directory discussed below.\nThe test cases in the common subdirectory are meant to be run always\nfor all backends. They should only depend on C and C++, without any\nexternal dependencies such as libraries. Tests that require those are\nin the test cases/frameworks directory. If there is a need for an\nexternal program in the common directory, such as a code generator, it\nshould be implemented as a Python script. The goal of test projects is\nalso to provide sample projects that end users can use as a base for\ntheir own projects.\nAll project tests follow the same pattern: they are configured, compiled, tests\nare run and finally install is run. Passing means that configuring, building and\ntests succeed and that installed files match those expected.\nAny tests that require more thorough analysis, such as checking that certain\ncompiler arguments can be found in the command line or that the generated\npkg-config files actually work should be done with a unit test.\nAdditionally:\ncrossfile.ini and nativefile.ini are passed to the configure step with\n--cross-file and --native-file options, respectively.\nmlog.cmd_ci_include() can be called from anywhere inside meson to capture the\ncontents of an additional file into the CI log on failure.\nProjects needed by unit tests are in the test cases/unit\nsubdirectory. They are not run as part of ./run_project_tests.py.\nThe (optional) test.json file, in the root of a test case, is used\nfor configuring the test. All of the following root entries in the test.json\nare independent of each other and can be combined as needed.\nExanple test.json:\nThe env key contains a dictionary which specifies additional\nenvironment variables to be set during the configure step of the test. @ROOT@\nis replaced with the absolute path of the source directory.\nThe installed dict contains a list of dicts, describing which files are expected\nto be installed. Each dict contains the following keys:\nThe file entry contains the relative path (from the install root) to the\nactually installed file.\nThe type entry specifies how the file path should be interpreted based on the\ncurrent platform. The following values are currently supported:\nExcept for the file and expr types, all paths should be provided without a suffix.\nThe shared_lib and pdb types takes an optional additional parameter, version, this is us a string in X.Y.Z format that will be applied to the library. Each version to be tested must have a single version. The harness will apply this correctly per platform:\npdb takes an optional language argument. This determines which compiler/linker should generate the pdb file. Because it's possible to mix compilers that do and don't generate pdb files (dmd's optlink doesn't). Currently this is only needed when mixing D and C code.\nThis will be applied appropriatly per platform. On windows this expects lib.dll and lib-1.dll. on MacOS it expects liblib.dylib and liblib.1.dylib. On other Unices it expects liblib.so, liblib.so.1, and liblib.so.1.2.3.\nIf the platform key is present, the installed file entry is only considered if\nthe platform matches. The following values for platform are currently supported:\nThe matrix section can be used to define a test matrix to run project tests\nwith different meson options.\nIn the options dict, all possible options and their values are specified. Each\nkey in the options dict is a meson option. It stores a list of all potential\nvalues in a dict format, which allows to skip specific values based on the current\nenvironment.\nEach value must contain the val key for the value of the option. null can be\nused for adding matrix entries without the current option.\nAdditionally, the skip_on_env key can be used to specify a list of environment\nvariables. If at least one environment variable in skip_on_env is present, all\nmatrix entries containing this value are skipped.\nSimilarly, the compilers key can be used to define a mapping of compilers to languages that are required for this value.\nSpecific option combinations can be excluded with the exclude section. It should\nbe noted that exclude does not require exact matches. Instead, any matrix entry\ncontaining all option value combinations in exclude will be excluded. Thus\nan empty dict ({}) to will match all elements in the test matrix.\nThe above example will produce the following matrix entries:\nCurrently supported values are:\nThis section specifies a dict of tool requirements in a simple key-value format.\nIf a tool is specified, it has to be present in the environment, and the version\nrequirement must be fulfilled. Otherwise, the entire test is skipped (including\nevery element in the test matrix).\nThe stdout key contains a list of dicts, describing the expected stdout.\nEach dict contains the following keys:\nEach item in the list is matched, in order, against the remaining actual stdout\nlines, after any previous matches. If the actual stdout is exhausted before\nevery item in the list is matched, the expected output has not been seen, and\nthe test has failed.\nThe match element of the dict determines how the line element is matched:\nMeson uses several continuous integration testing systems that have slightly\ndifferent interfaces for indicating a commit should be skipped.\nContinuous integration systems currently used:\nTo promote consistent naming policy, use:\nThe docs directory contains the full documentation that will be used\nto generate the Meson web site. Every change\nin functionality must change the documentation pages. In most cases\nthis means updating the reference documentation page but bigger\nchanges might need changes in other documentation, too.\nAll new functionality needs to have a mention in the release\nnotes. These features should be written in standalone files in the\ndocs/markdown/snippets directory. The release manager will combine\nthem into one page when doing the release.\nIntegration tests should be disabled for\ndocumentation-only commits by putting [skip ci] into commit title.\nReviewers should ask contributors to put [skip ci] into the title because\ntests are run again after merge for master.\nMeson follows the basic Python coding style. Additional rules are the\nfollowing:\nMeson uses Flake8 for style guide enforcement. The Flake8 options for\nthe project are contained in .flake8.\nTo run Flake8 on your local clone of Meson:\nTo run it automatically before committing:\nMeson has a bunch of test code in several languages. The rules for\nthose are simple.\nThe goal of Meson is to be as easily usable as possible. The user\nexperience should be \"get Python3 and Ninja, run\", even on\nWindows. Unfortunately this means that we can't have dependencies on\nprojects outside of Python's standard library. This applies only to\ncore functionality, though. For additional helper programs etc the use\nof external dependencies may be ok. If you feel that you are dealing\nwith this kind of case, please contact the developers first with your\nuse case.\nThe main design principle of Meson is that the definition language is\nnot Turing complete. Any change that would make Meson Turing complete\nis automatically rejected. In practice this means that defining your\nown functions inside meson.build files and generalised loops will\nnot be added to the language.\nNo you don't. All contributions are welcome.\nMeson operates in much the same way as functional programming\nlanguages. It has inputs, which include meson.build files, values of\noptions, compilers and so on. These are passed to a function, which\ngenerates output build definition. This function is pure, which means that:\nThe latter one is important, because it enforces that there is no way\nfor \"secret state\" to pass between consecutive invocations of\nMeson. This is the reason why, for example, there is no set_option\nfunction even though there is a get_option one.\nIf this were not the case, we could never know if the build output is\n\"stable\". For example suppose there were a set_option function and a\nboolean variable flipflop. Then you could do this:\nThis piece of code would never converge. Every Meson run would change\nthe value of the option and thus the output you get out of this build\ndefinition would be random.\nMeson does not permit this by forbidding these sorts of covert channels.\nThere is one exception to this rule. Users can call into external\ncommands with run_command. If the output of that command does not\nbehave like a pure function, this problem arises. Meson does not try\nto guard against this case, it is the responsibility of the user to\nmake sure the commands they run behave like pure functions.\nEnvironment variables are like global variables, except that they are\nalso hidden by default. Envvars should be avoided whenever possible,\nall functionality should be exposed in better ways such as command\nline switches.\nAll features should follow the 90/9/1 rule. 90% of all use cases\nshould be easy, 9% should be possible and it is totally fine to not\nsupport the final 1% if it would make things too complicated.\nAny build directory will have at most two toolchains: one native and\none cross.\nPrefer specific solutions to generic frameworks. Solve the end\nuser's problems rather than providing them tools to do it\nthemselves.\nNever use features of the Unix shell (or Windows shell for that\nmatter). Doing things like forwaring output with > or invoking\nmultiple commands with && are not permitted. Whenever these sorts\nof requirements show up, write an internal Python script with the\ndesired functionality and use that instead.\n\nMust include a project test under test cases/, or if that's not\npossible or if the test requires a special environment, it must go\ninto run_unittests.py.\nMust be registered with the FeatureChecks framework\nthat will warn the user if they try to use a new feature while\ntargeting an older meson version.\nNeeds a release note snippet inside docs/markdown/snippets/ with\na heading and a brief paragraph explaining what the feature does\nwith an example.\n\n\nmembers with commit access can do:\n\ndocumentation changes (directly to master if warranted)\nbug fixes that don't change functionality\nrefactorings\nnew dependency types\nnew tool support (e.g. a new Doxygen-kind of tool)\nsupport for new compilers to existing languages\n\n\nproject leader decision is needed for:\n\nnew modules\nnew functions in the Meson language\nsyntax changes for Meson files\nchanges breaking backwards compatibility\nsupport for new languages\n\n\n\n\ndocumentation changes (directly to master if warranted)\nbug fixes that don't change functionality\nrefactorings\nnew dependency types\nnew tool support (e.g. a new Doxygen-kind of tool)\nsupport for new compilers to existing languages\n\n\nnew modules\nnew functions in the Meson language\nsyntax changes for Meson files\nchanges breaking backwards compatibility\nsupport for new languages\n\n\n\npreserve as much history as possible\n\n\nhave as little junk in the repo as possible\n\n\neverything in the \"master lineage\" should always pass all tests\n\n\n\n\nsingle commit pull requests should always be rebased\n\n\na pull request with one commit and one \"fixup\" commit (such as\ntesting something to see if it passes CI) should be squashed\n\n\nlarge branches with many commits should be merged with a merge\ncommit, especially if one of the commits does not pass all tests\n(which happens in e.g. large and difficult refactorings)\n\n\n\n\ncrossfile.ini and nativefile.ini are passed to the configure step with\n--cross-file and --native-file options, respectively.\n\n\nmlog.cmd_ci_include() can be called from anywhere inside meson to capture the\ncontents of an additional file into the CI log on failure.\n\n\n\nfile\ntype\n\nplatform (optional)\n\nversion (optional)\n\nlanguage (optional)\n\n\nopt1=abc\nopt1=abc opt2=true\nopt1=abc opt2=false\nopt1=qwert\nopt1=qwert opt2=true\n\n\nprefix\nlibdir\n\n\nline\n\nmatch (optional)\n\n\n\nTravis-CI\nallows [skip ci] anywhere in the commit messages.\n\nAzure Pipelines\nallows ***NO_CI*** in the commit message.\n\nSider\nruns Flake8 (see below)\n\n\n\n[skip ci] in the commit title if you want to disable all integration tests\n\n\nindent 4 spaces, no tabs ever\nindent meson.build files with two spaces\ntry to keep the code as simple as possible\ncontact the mailing list before embarking on large scale projects\nto avoid wasted effort\n\n\nindent 4 spaces, no tabs ever\nbrace always on the same line as if/for/else/function definition\n\n\nfor any given input the output is always the same\nrunning Meson twice in a row always produce the same output in both runs\n\n\n\nAll features should follow the 90/9/1 rule. 90% of all use cases\nshould be easy, 9% should be possible and it is totally fine to not\nsupport the final 1% if it would make things too complicated.\n\n\nAny build directory will have at most two toolchains: one native and\none cross.\n\n\nPrefer specific solutions to generic frameworks. Solve the end\nuser's problems rather than providing them tools to do it\nthemselves.\n\n\nNever use features of the Unix shell (or Windows shell for that\nmatter). Doing things like forwaring output with > or invoking\nmultiple commands with && are not permitted. Whenever these sorts\nof requirements show up, write an internal Python script with the\ndesired functionality and use that instead.\n\n\n\n\n\n type\n Description\n\n\n\n\n file\n\n No postprocessing, just use the provided path\n\n\n dir\n\n To include all files inside the directory (for generated docs, etc). The path must be a valid directory\n\n\n exe\n\n For executables. On Windows the .exe suffix is added to the path in file\n\n\n\n shared_lib\n\n For shared libraries, always written as name. The appropriate suffix and prefix are added by platform\n\n\n pdb\n\n For Windows PDB files. PDB entries are ignored on non Windows platforms\n\n\n implib\n\n For Windows import libraries. These entries are ignored on non Windows platforms\n\n\n implibempty\n\n Like implib, but no symbols are exported in the library\n\n\n expr\n\n file is an expression. This type should be avoided and removed if possible\n\n\n\n\n\n\n Argument\n Applies to\n Description\n\n\n\n\n version\n\n shared_lib, pdb\n\n Sets the version to look for appropriately per-platform\n\n\n language\n\n pdb\n\n Determines which compiler/linker determines the existence of this file\n\n\n\n\n\n\n platform\n Description\n\n\n\n\n msvc\n\n Matches when a msvc like compiler is used (msvc, clang-cl, etc.)\n\n\n gcc\n\n Not msvc\n\n\n\n cygwin\n\n Matches when the platform is cygwin\n\n\n !cygwin\n\n Not cygwin\n\n\n\n\n\n\n\n Type\n Description\n\n\n\n\n literal\n\n Literal match (default)\n\n\n re\n\n regex match\n\n\n\n"});