fragment_downloaded_cb({"url":"Subprojects.html#page-description","fragment":"Some platforms do not provide a native packaging system. In these\ncases it is common to bundle all third party libraries in your source\ntree. This is usually frowned upon because it makes it hard to add\nthese kinds of projects into e.g. those Linux distributions that\nforbid bundled libraries.\nMeson tries to solve this problem by making it extremely easy to\nprovide both at the same time. The way this is done is that Meson\nallows you to take any other Meson project and make it a part of your\nbuild without (in the best case) any changes to its Meson setup. It\nbecomes a transparent part of the project.\nIt should be noted that this is only guaranteed to work for subprojects\nthat are built with Meson. The reason is the simple fact that there is\nno possible way to do this reliably with mixed build systems. Because of\nthis, only Meson subprojects are described here.\nCMake based subprojects are also\nsupported but not guaranteed to work.\nUsually dependencies consist of some header files plus a library to\nlink against. To declare this internal dependency use\ndeclare_dependency function.\nAs an example, suppose we have a simple project that provides a shared\nlibrary. Its meson.build would look like this.\nIdeally the dependency variable name should be of <project_name>_dep\nform. This way one can just use it without even looking inside build\ndefinitions of that subproject.\nIn cases where there are multiple dependencies need to be declared,\nthe default one should be named as <project_name>_dep (e.g.\ngtest_dep), and others can have <project_name>_<other>_<name>_dep\nform (e.g. gtest_main_dep - gtest with main function).\nThere may be exceptions to these rules where common sense should be applied.\nNew in 0.54.0\nIn some cases a project may define special variables via pkg-config or\ncmake that a caller needs to know about. Meson provides a\ndependency.get_variable method to hide what kind of dependency is\nprovided, and this is available to subprojects as well. Use the\nvariables keyword to add a dict of strings:\nWhich another project can access via:\nThe values of the dict must be strings, as pkg-config and cmake will\nreturn variables as strings.\nAll Meson features of the subproject, such as project options keep\nworking and can be set in the master project. There are a few\nlimitations, the most important being that global compiler arguments\nmust be set in the main project before calling subproject. Subprojects\nmust not set global arguments because there is no way to do that\nreliably over multiple subprojects. To check whether you are running\nas a subproject, use the is_subproject function.\nAll subprojects must be inside subprojects directory. The\nsubprojects directory must be at the top level of your project.\nSubproject declaration must be in your top level meson.build.\nLet's use libsimple as a subproject.\nAt the top level of your project create subprojects directory.\nThen copy libsimple into subprojects directory.\nYour project's meson.build should look like this.\nNote that the subproject object is not used as the dependency, but\nrather you need to get the declared dependency from it with\nget_variable because a subproject may have multiple declared\ndependencies.\nWhen building distro packages it is very important that you do not\nembed any sources. Some distros have a rule forbidding embedded\ndependencies so your project must be buildable without them or\notherwise the packager will hate you.\nHere's how you would use system libraries and fall back to embedding sources\nif the dependency is not available.\nBecause this is such a common operation, Meson provides a shortcut for\nthis use case.\nThe fallback keyword argument takes two items, the name of the\nsubproject and the name of the variable that holds the dependency. If\nyou need to do something more complicated, such as extract several\ndifferent variables, then you need to do it yourself with the manual\nmethod described above.\nUsing this shortcut the build definition would look like this.\nWith this setup when libsimple is provided by the system, we use it.\nWhen that is not the case we use the embedded version (the one from\nsubprojects).\nNote that libsimple_dep can point to an external or an internal\ndependency but you don't have to worry about their differences. Meson\nwill take care of the details for you.\nSubprojects can use other subprojects, but all subprojects must reside\nin the top level subprojects directory. Recursive use of subprojects\nis not allowed, though, so you can't have subproject a that uses\nsubproject b and have b also use a.\nMeson ships with a dependency system to automatically obtain\ndependency subprojects. It is documented in the Wrap dependency\nsystem manual.\nThe usage of subprojects can be controlled by users and distros with\nthe following command-line options:\n--wrap-mode=nodownload\nMeson will not use the network to download any subprojects or\nfetch any wrap information. Only pre-existing sources will be used.\nThis is useful (mostly for distros) when you want to only use the\nsources provided by a software release, and want to manually handle\nor provide missing dependencies.\n--wrap-mode=nofallback\nMeson will not use subproject fallbacks for any dependency\ndeclarations in the build files, and will only look for them in the\nsystem. Note that this does not apply to unconditional subproject()\ncalls, and those are meant to be used for sources that cannot be\nprovided by the system, such as copylibs.\nThis option may be overridden by --force-fallback-for for specific\ndependencies.\n--wrap-mode=forcefallback\nMeson will not look at the system for any dependencies which have\nsubproject fallbacks available, and will only use subprojects for\nthem. This is useful when you want to test your fallback setup, or\nwant to specifically build against the library sources provided by\nyour subprojects.\n--force-fallback-for=list,of,dependencies\nMeson will not look at the system for any dependencies listed there,\nprovided a fallback was supplied when the dependency was declared.\nThis option takes precedence over --wrap-mode=nofallback, and when\nused in combination with --wrap-mode=nodownload will only work\nif the dependency has already been downloaded.\nThis is useful when your project has many fallback dependencies,\nbut you only want to build against the library sources for a few\nof them.\nWarning: This could lead to mixing system and subproject version of the\nsame library in the same process. Take this case as example:\n--wrap-mode=nopromote\nSince 0.56.0 Meson will automatically use wrap files found in subprojects\nand copy them into the main project. That new behavior can be disabled by\npassing --wrap-mode=nopromote. In that case only wraps found in the main\nproject will be used.\nSince 0.49.0\nmeson subprojects has various subcommands to manage all subprojects.\nIf the subcommand fails on any subproject the execution continues with\nother subprojects. All subcommands accept --sourcedir argument\npointing to the root source dir of the main project.\nSince 0.56.0 all subcommands accept --types <file|git|hg|svn>\nargument to run the subcommands only on subprojects of the given\ntypes. Multiple types can be set as comma separated list e.g. --types git,file.\nSince 0.56.0 If the subcommand fails on any subproject an error code\nis returned at the end instead of retuning success.\nSince 0.49.0\nMeson will automatically download needed subprojects during configure,\nunless --wrap-mode=nodownload option is passed. It is sometimes\npreferable to download all subprojects in advance, so the Meson\nconfigure can be performed offline. The command-line meson subprojects download can be used for that, it will download all\nmissing subprojects, but will not update already fetched subprojects.\nSince 0.49.0\nOnce a subproject has been fetched, Meson will not update it automatically.\nFor example if the wrap file tracks a git branch, it won't pull latest commits.\nTo pull latest version of all your subprojects at once, just run the command:\nmeson subprojects update.\nSince 0.49.0\nThe command-line meson subprojects checkout <branch_name> will\ncheckout a branch, or create one with -b argument, in every git\nsubprojects. This is useful when starting local changes across\nmultiple subprojects. It is still your responsibility to commit and\npush in each repository where you made local changes.\nTo come back to the revision set in wrap file (i.e. master), just run\nmeson subprojects checkout with no branch name.\nSince 0.56.0 any pending changes are now stashed before checkout a new branch.\nSince 0.51.0\nThe command-line meson subprojects foreach <command> [...] will\nexecute a command in each subproject directory. For example this can\nbe useful to check the status of subprojects (e.g. with git status\nor git diff) before performing other actions on them.\nThere are several reasons.\nFirst of all, to maintain any sort of sanity, the system must prevent going\ninside other subprojects with subdir() or variations thereof. Having the\nsubprojects in well defined places makes this easy. If subprojects could be\nanywhere at all, it would be a lot harder.\nSecond of all it is extremely important that end users can easily see what\nsubprojects any project has. Because they are in one, and only one, place,\nreviewing them becomes easy.\nThis is also a question of convention. Since all Meson projects have the same\nlayout w.r.t subprojects, switching between projects becomes easier. You don't\nhave to spend time on a new project traipsing through the source tree looking\nfor subprojects. They are always in the same place.\nFinally if you can have subprojects anywhere, this increases the possibility of\nhaving many different (possibly incompatible) versions of a dependency in your\nsource tree. Then changing some code (such as changing the order you traverse\ndirectories) may cause a completely different version of the subproject to be\nused by accident.\n\n\n--wrap-mode=nodownload\nMeson will not use the network to download any subprojects or\nfetch any wrap information. Only pre-existing sources will be used.\nThis is useful (mostly for distros) when you want to only use the\nsources provided by a software release, and want to manually handle\nor provide missing dependencies.\n\n\n--wrap-mode=nofallback\nMeson will not use subproject fallbacks for any dependency\ndeclarations in the build files, and will only look for them in the\nsystem. Note that this does not apply to unconditional subproject()\ncalls, and those are meant to be used for sources that cannot be\nprovided by the system, such as copylibs.\nThis option may be overridden by --force-fallback-for for specific\ndependencies.\n\n\n--wrap-mode=forcefallback\nMeson will not look at the system for any dependencies which have\nsubproject fallbacks available, and will only use subprojects for\nthem. This is useful when you want to test your fallback setup, or\nwant to specifically build against the library sources provided by\nyour subprojects.\n\n\n--force-fallback-for=list,of,dependencies\nMeson will not look at the system for any dependencies listed there,\nprovided a fallback was supplied when the dependency was declared.\nThis option takes precedence over --wrap-mode=nofallback, and when\nused in combination with --wrap-mode=nodownload will only work\nif the dependency has already been downloaded.\nThis is useful when your project has many fallback dependencies,\nbut you only want to build against the library sources for a few\nof them.\nWarning: This could lead to mixing system and subproject version of the\nsame library in the same process. Take this case as example:\n\nLibraries glib-2.0 and gstreamer-1.0 are installed on your system.\n\ngstreamer-1.0 depends on glib-2.0, pkg-config file gstreamer-1.0.pc\nhas Requires: glib-2.0.\nIn your application build definition you do:\nexecutable('app', ...,\n  dependencies: [\n    dependency('glib-2.0', fallback: 'glib'),\n    dependency('gstreamer-1.0', fallback: 'gstreamer')],\n)\n\n\nYou configure with --force-fallback-for=glib.\nThis result in linking to two different versions of library glib-2.0\nbecause dependency('glib-2.0', fallback: 'glib') will return the\nsubproject dependency, but dependency('gstreamer-1.0', fallback: 'gstreamer')\nwill not fallback and return the system dependency, including glib-2.0\nlibrary. To avoid that situation, every dependency that itself depend on\nglib-2.0 must also be forced to fallback, in this case with\n--force-fallback-for=glib,gsteamer.\n\n\n\n--wrap-mode=nopromote\nSince 0.56.0 Meson will automatically use wrap files found in subprojects\nand copy them into the main project. That new behavior can be disabled by\npassing --wrap-mode=nopromote. In that case only wraps found in the main\nproject will be used.\n\n\n\nLibraries glib-2.0 and gstreamer-1.0 are installed on your system.\n\ngstreamer-1.0 depends on glib-2.0, pkg-config file gstreamer-1.0.pc\nhas Requires: glib-2.0.\nIn your application build definition you do:\nexecutable('app', ...,\n  dependencies: [\n    dependency('glib-2.0', fallback: 'glib'),\n    dependency('gstreamer-1.0', fallback: 'gstreamer')],\n)\n\n\nYou configure with --force-fallback-for=glib.\nThis result in linking to two different versions of library glib-2.0\nbecause dependency('glib-2.0', fallback: 'glib') will return the\nsubproject dependency, but dependency('gstreamer-1.0', fallback: 'gstreamer')\nwill not fallback and return the system dependency, including glib-2.0\nlibrary. To avoid that situation, every dependency that itself depend on\nglib-2.0 must also be forced to fallback, in this case with\n--force-fallback-for=glib,gsteamer.\n\n\nIf the wrap file comes from wrapdb, the latest version of the wrap file will\nbe pulled and used next time meson reconfigure the project. This can be\ntriggered using meson --reconfigure. Previous source tree is not deleted, to\nprevent from any loss of local changes. Since 0.58.0 If --reset is\nspecified, the source tree is deleted and new source is extracted.\nIf subproject is currently in detached mode, a checkout of the revision from\nwrap file is performed. Since 0.56.0 a rebase is also performed in case the\nrevision already existed locally but was outdated. If --reset is specified,\na hard reset is performed instead of rebase.\nIf subproject is currently at the same branch as specified by the wrap file,\na rebase on origin commit is performed. Since 0.56.0 If --reset is\nspecified, a hard reset is performed instead of rebase.\nIf subproject is currently in a different branch as specified by the wrap file,\nit is skipped unless --rebase option is passed in which case a rebase on\norigin commit is performed. Since 0.56.0 the --rebase argument is\ndeprecated and has no effect. Instead, a checkout of the revision from wrap file\nfile is performed and a rebase is also performed in case the revision already\nexisted locally by was outdated. If --reset is specified, a hard reset is\nperformed instead of rebase.\n\nSince 0.56.0 if the url specified in wrap file is different to the URL set\non origin for a git repository it will not be updated, unless --reset is\nspecified in which case the URL of origin will be reset first.\n\nSince 0.56.0 If the subproject directory is not a git repository but has a\n[wrap-git] the subproject is ignored, unless --reset is specified in which\ncase the directory is deleted and the new repository is cloned.\n\n"});