fragment_downloaded_cb({"url":"Subprojects.html#page-description","fragment":"Some platforms do not provide a native packaging system. In these\ncases it is common to bundle all third party libraries in your source\ntree. This is usually frowned upon because it makes it hard to add\nthese kinds of projects into e.g. those Linux distributions that\nforbid bundled libraries.\nMeson tries to solve this problem by making it extremely easy to\nprovide both at the same time. The way this is done is that Meson\nallows you to take any other Meson project and make it a part of your\nbuild without (in the best case) any changes to its Meson setup. It\nbecomes a transparent part of the project.\nIt should be noted that this is only guaranteed to work for subprojects\nthat are built with Meson. The reason is the simple fact that there is\nno possible way to do this reliably with mixed build systems. Because of\nthis, only meson subprojects are described here.\nCMake based subprojects are also\nsupported but not guaranteed to work.\nUsually dependencies consist of some header files plus a library to link against.\nTo declare this internal dependency use declare_dependency function.\nAs an example, suppose we have a simple project that provides a shared\nlibrary. Its meson.build would look like this.\nIdeally the dependency variable name should be of <project_name>_dep form.\nThis way one can just use it without even looking inside build definitions of that subproject.\nIn cases where there are multiple dependencies need to be declared, the default one\nshould be named as <project_name>_dep (e.g. gtest_dep), and others can have\n<project_name>_<other>_<name>_dep form (e.g. gtest_main_dep - gtest with main function).\nThere may be exceptions to these rules where common sense should be applied.\nNew in 0.54.0\nIn some cases a project may define special variables via pkg-config or cmake\nthat a caller needs to know about. Meson provides a dependency.get_variable\nmethod to hide what kind of dependency is provided, and this is available to\nsubprojects as well. Use the variables keyword to add a dict of strings:\nWhich another project can access via:\nThe values of the dict must be strings, as pkg-config and cmake will return\nvariables as strings.\nAll Meson features of the subproject, such as project options keep\nworking and can be set in the master project. There are a few\nlimitations, the most important being that global compiler arguments\nmust be set in the main project before calling subproject. Subprojects\nmust not set global arguments because there is no way to do that\nreliably over multiple subprojects. To check whether you are running\nas a subproject, use the is_subproject function.\nAll subprojects must be inside subprojects directory.\nThe subprojects directory must be at the top level of your project.\nSubproject declaration must be in your top level meson.build.\nLet's use libsimple as a subproject.\nAt the top level of your project create subprojects directory.\nThen copy libsimple into subprojects directory.\nYour project's meson.build should look like this.\nNote that the subproject object is not used as the dependency, but\nrather you need to get the declared dependency from it with\nget_variable because a subproject may have multiple declared\ndependencies.\nWhen building distro packages it is very important that you do not\nembed any sources. Some distros have a rule forbidding embedded\ndependencies so your project must be buildable without them or\notherwise the packager will hate you.\nHere's how you would use system libraries and fall back to embedding sources\nif the dependency is not available.\nBecause this is such a common operation, Meson provides a shortcut for\nthis use case.\nThe fallback keyword argument takes two items, the name of the\nsubproject and the name of the variable that holds the dependency. If\nyou need to do something more complicated, such as extract several\ndifferent variables, then you need to do it yourself with the manual\nmethod described above.\nUsing this shortcut the build definition would look like this.\nWith this setup when libsimple is provided by the system, we use it. When\nthat is not the case we use the embedded version (the one from subprojects).\nNote that libsimple_dep can point to an external or an internal dependency but\nyou don't have to worry about their differences. Meson will take care\nof the details for you.\nSubprojects can use other subprojects, but all subprojects must reside\nin the top level subprojects directory. Recursive use of subprojects\nis not allowed, though, so you can't have subproject a that uses\nsubproject b and have b also use a.\nMeson ships with a dependency system to automatically obtain\ndependency subprojects. It is documented in the Wrap dependency\nsystem manual.\nThe usage of subprojects can be controlled by users and distros with\nthe following command-line options:\n--wrap-mode=nodownload\nMeson will not use the network to download any subprojects or\nfetch any wrap information. Only pre-existing sources will be used.\nThis is useful (mostly for distros) when you want to only use the\nsources provided by a software release, and want to manually handle\nor provide missing dependencies.\n--wrap-mode=nofallback\nMeson will not use subproject fallbacks for any dependency\ndeclarations in the build files, and will only look for them in the\nsystem. Note that this does not apply to unconditional subproject()\ncalls, and those are meant to be used for sources that cannot be\nprovided by the system, such as copylibs.\n--wrap-mode=forcefallback\nMeson will not look at the system for any dependencies which have\nsubproject fallbacks available, and will only use subprojects for\nthem. This is useful when you want to test your fallback setup, or\nwant to specifically build against the library sources provided by\nyour subprojects.\nSince 0.49.0\nMeson will automatically download needed subprojects during configure, unless\n--wrap-mode=nodownload option is passed. It is sometimes preferable to\ndownload all subprojects in advance, so the meson configure can be performed\noffline. The command-line meson subprojects download can be used for that, it\nwill download all missing subprojects, but will not update already fetched\nsubprojects.\nSince 0.49.0\nOnce a subproject has been fetched, Meson will not update it automatically.\nFor example if the wrap file tracks a git branch, it won't pull latest commits.\nTo pull latest version of all your subprojects at once, just run the command:\nmeson subprojects update.\nSince 0.49.0\nThe command-line meson subprojects checkout <branch_name> will checkout a\nbranch, or create one with -b argument, in every git subprojects. This is\nuseful when starting local changes across multiple subprojects. It is still your\nresponsibility to commit and push in each repository where you made local\nchanges.\nTo come back to the revision set in wrap file (i.e. master), just run\nmeson subprojects checkout with no branch name.\nSince 0.51.0\nThe command-line meson subprojects foreach <command> [...] will\nexecute a command in each subproject directory. For example this can be useful\nto check the status of subprojects (e.g. with git status or git diff) before\nperforming other actions on them.\nThere are several reasons.\nFirst of all, to maintain any sort of sanity, the system must prevent going\ninside other subprojects with subdir() or variations thereof. Having the\nsubprojects in well defined places makes this easy. If subprojects could be\nanywhere at all, it would be a lot harder.\nSecond of all it is extremely important that end users can easily see what\nsubprojects any project has. Because they are in one, and only one, place,\nreviewing them becomes easy.\nThis is also a question of convention. Since all Meson projects have the same\nlayout w.r.t subprojects, switching between projects becomes easier. You don't\nhave to spend time on a new project traipsing through the source tree looking\nfor subprojects. They are always in the same place.\nFinally if you can have subprojects anywhere, this increases the possibility of\nhaving many different (possibly incompatible) versions of a dependency in your\nsource tree. Then changing some code (such as changing the order you traverse\ndirectories) may cause a completely different version of the subproject to be\nused by accident.\n\n\n--wrap-mode=nodownload\nMeson will not use the network to download any subprojects or\nfetch any wrap information. Only pre-existing sources will be used.\nThis is useful (mostly for distros) when you want to only use the\nsources provided by a software release, and want to manually handle\nor provide missing dependencies.\n\n\n--wrap-mode=nofallback\nMeson will not use subproject fallbacks for any dependency\ndeclarations in the build files, and will only look for them in the\nsystem. Note that this does not apply to unconditional subproject()\ncalls, and those are meant to be used for sources that cannot be\nprovided by the system, such as copylibs.\n\n\n--wrap-mode=forcefallback\nMeson will not look at the system for any dependencies which have\nsubproject fallbacks available, and will only use subprojects for\nthem. This is useful when you want to test your fallback setup, or\nwant to specifically build against the library sources provided by\nyour subprojects.\n\n\n\nIf the wrap file comes from wrapdb, the latest version of the wrap file will\nbe pulled and used next time meson reconfigure the project. This can be\ntriggered using meson --reconfigure. Previous source tree is not deleted, to\nprevent from any loss of local changes.\nIf the wrap file points to a git commit or tag, a checkout of that commit is\nperformed.\nIf the wrap file points to a git branch, and the current branch has the same\nname, a git pull is performed.\nIf the wrap file points to a git branch, and the current branch is different,\nit is skipped. Unless --rebase option is passed in which case\ngit pull --rebase is performed.\n\n"});