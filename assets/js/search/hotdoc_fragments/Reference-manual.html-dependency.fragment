fragment_downloaded_cb({"url":"Reference-manual.html#dependency","fragment":"dependency()\nFinds an external dependency (usually a library installed on your\nsystem) with the given name with pkg-config and with\nCMake if pkg-config fails. Additionally,\nframeworks (OSX only) and library-specific fallback detection\nlogic\nare also supported.\nDependencies can also be resolved in two other ways:\nif the same name was used in a meson.override_dependency prior to\nthe call to dependency, the overriding dependency will be returned\nunconditionally; that is, the overriding dependency will be used\nindependent of whether an external dependency is installed in the system.\nTypically, meson.override_dependency will have been used by a\nsubproject.\nby a fallback subproject which, if needed, will be brought into the current\nbuild specification as if subproject() had been called.\nThe subproject can be specified with the fallback argument.  Alternatively,\nif the fallback argument is absent, since 0.55.0 Meson can\nautomatically identify a subproject as a fallback if a wrap file\nprovides the\ndependency, or if a subproject has the same name as the dependency.\nIn the latter case, the subproject must use meson.override_dependency to\nspecify the replacement, or Meson will report a hard error.  See the\nWrap documentation\nfor more details.  This automatic search can be controlled using the\nallow_fallback keyword argument.\nThis function supports the following keyword arguments:\nIf dependency_name is '', the dependency is always not found. So\nwith required: false, this always returns a dependency object for\nwhich the found() method returns false, and which can be passed\nlike any other dependency to the dependencies: keyword argument of a\nbuild_target. This can be used to implement a dependency which is\nsometimes not required e.g. in some branches of a conditional, or with\na fallback: kwarg, can be used to declare an optional dependency\nthat only looks in the specified subproject, and only if that's\nallowed by --wrap-mode.\nThe returned object also has methods that are documented in the\nobject methods section below.\n\n\nif the same name was used in a meson.override_dependency prior to\nthe call to dependency, the overriding dependency will be returned\nunconditionally; that is, the overriding dependency will be used\nindependent of whether an external dependency is installed in the system.\nTypically, meson.override_dependency will have been used by a\nsubproject.\n\n\nby a fallback subproject which, if needed, will be brought into the current\nbuild specification as if subproject() had been called.\nThe subproject can be specified with the fallback argument.  Alternatively,\nif the fallback argument is absent, since 0.55.0 Meson can\nautomatically identify a subproject as a fallback if a wrap file\nprovides the\ndependency, or if a subproject has the same name as the dependency.\nIn the latter case, the subproject must use meson.override_dependency to\nspecify the replacement, or Meson will report a hard error.  See the\nWrap documentation\nfor more details.  This automatic search can be controlled using the\nallow_fallback keyword argument.\n\n\n\n\ndefault_options (since 0.37.0): an array of default option values\nthat override those set in the subproject's meson_options.txt\n(like default_options in project(), they only have\neffect when Meson is run for the first time, and command line\narguments override any default options in build files)\n\nallow_fallback (boolean argument, since 0.56.0): specifies whether Meson\nshould automatically pick a fallback subproject in case the dependency\nis not found in the system.  If true and the dependency is not found\non the system, Meson will fallback to a subproject that provides this\ndependency. If false, Meson will not fallback even if a subproject\nprovides this dependency.  By default, Meson will do so if required\nis true or  enabled; see the Wrap\ndocumentation\nfor more details.\n\nfallback (string or array argument): manually specifies a subproject\nfallback to use in case the dependency is not found in the system.\nThis is useful if the automatic search is not applicable or if you\nwant to support versions of Meson older than 0.55.0.  If the value is an\narray ['subproj_name', 'subproj_dep'], the first value is the name\nof the subproject and the second is the variable name in that\nsubproject that contains a dependency object such as the return\nvalue of declare_dependency or\ndependency(), etc. Note that this means the\nfallback dependency may be a not-found dependency, in which\ncase the value of the required: kwarg will be obeyed.\nSince 0.54.0 the value can be a single string, the subproject name;\nin this case the subproject must use\nmeson.override_dependency('dependency_name', subproj_dep)\nto specify the dependency object used in the superproject.\nIf the value is an empty list, it has the same effect as\nallow_fallback: false.\n\nlanguage (since 0.42.0): defines what language-specific\ndependency to find if it's available for multiple languages.\n\nmethod: defines the way the dependency is detected, the default is\nauto but can be overridden to be e.g. qmake for Qt development,\nand different dependencies support different values\nfor this (though auto will work on all of them)\n\nnative: if set to true, causes Meson to find the dependency on\nthe build machine system rather than the host system (i.e. where the\ncross compiled binary will run on), usually only needed if you build\na tool to be used during compilation.\n\nnot_found_message (since 0.50.0): an optional string that will\nbe printed as a message() if the dependency was not found.\n\nrequired: when set to false, Meson will proceed with the build\neven if the dependency is not found. (since 0.47.0) The value of a\nfeature option can also be passed.\n\nstatic: tells the dependency provider to try to get static\nlibraries instead of dynamic ones (note that this is not supported\nby all dependency backends)\n\nversion (since 0.37.0): specifies the required version, a string containing a\ncomparison operator followed by the version string, examples include\n>1.0.0, <=2.3.5 or 3.1.4 for exact matching.\nYou can also specify multiple restrictions by passing a list to this\nkeyword argument, such as: ['>=3.14.0', '<=4.1.0'].\nThese requirements are never met if the version is unknown.\n\ninclude_type (since 0.52.0): an enum flag, marking how the dependency\nflags should be converted. Supported values are 'preserve', 'system' and\n'non-system'. System dependencies may be handled differently on some\nplatforms, for instance, using -isystem instead of -I, where possible.\nIf include_type is set to 'preserve', no additional conversion will be\nperformed. The default value is 'preserve'.\nother\nlibrary-specific\nkeywords may also be accepted (e.g. modules specifies submodules to use for\ndependencies such as Qt5 or Boost. components allows the user to manually\nadd CMake COMPONENTS for the find_package lookup)\n\ndisabler (since 0.49.0): if true and the dependency couldn't be found,\nreturns a disabler object instead of a not-found dependency.\n\n"});