fragment_downloaded_cb({"url":"FAQ.html#page-description","fragment":"See also How do I do X in Meson.\nWhen the name was originally chosen, there were two main limitations:\nthere must not exist either a Debian package or a Sourceforge project\nof the given name. This ruled out tens of potential project names. At\nsome point the name Gluon was considered. Gluons are elementary\nparticles that hold protons and neutrons together, much like a build\nsystem's job is to take pieces of source code and a compiler and bind\nthem to a complete whole.\nUnfortunately this name was taken, too. Then the rest of subatomic\nparticles were examined and Meson was found to be available.\nThis will set up everything on your behalf. People coming from\nAutotools or CMake want to do this by looking for libpthread.so\nmanually. Don't do that, it has tricky corner cases especially when\ncross compiling.\nStarting from version 0.29.0, Meson is available from the Python\nPackage Index, so installing it\nsimply a matter of running this command:\nIf you don't have access to PyPI, that is not a problem either. Meson\nhas been designed to be easily runnable from an extracted source\ntarball or even a git checkout. First you need to download Meson. Then\nuse this command to set up you build instead of plain meson.\nAfter this you don't have to care about invoking Meson any more. It\nremembers where it was originally invoked from and calls itself\nappropriately. As a user the only thing you need to do is to cd into\nyour build directory and invoke meson compile.\nInstead of specifying files explicitly, people seem to want to do this:\nMeson does not support this syntax and the reason for this is simple.\nThis can not be made both reliable and fast. By reliable we mean that\nif the user adds a new source file to the subdirectory, Meson should\ndetect that and make it part of the build automatically.\nOne of the main requirements of Meson is that it must be fast. This\nmeans that a no-op build in a tree of 10 000 source files must take no\nmore than a fraction of a second. This is only possible because Meson\nknows the exact list of files to check. If any target is specified as\na wildcard glob, this is no longer possible. Meson would need to\nre-evaluate the glob every time and compare the list of files produced\nagainst the previous list. This means inspecting the entire source\ntree (because the glob pattern could be src/\\*/\\*/\\*/\\*.cpp or\nsomething like that). This is impossible to do efficiently.\nThe main backend of Meson is Ninja, which does not support wildcard\nmatches either, and for the same reasons.\nBecause of this, all source files must be specified explicitly.\nIf the tradeoff between reliability and convenience is acceptable to\nyou, then Meson gives you all the tools necessary to do wildcard\nglobbing. You are allowed to run arbitrary commands during\nconfiguration. First you need to write a script that locates the files\nto compile. Here's a simple shell script that writes all .c files in\nthe current directory, one per line.\nThen you need to run this script in your Meson file, convert the\noutput into a string array and use the result in a target.\nThe script can be any executable, so it can be written in shell,\nPython, Lua, Perl or whatever you wish.\nAs mentioned above, the tradeoff is that just adding new files to the\nsource directory does not add them to the build automatically. To\nadd them you need to tell Meson to reinitialize itself. The simplest\nway is to touch the meson.build file in your source root. Then Meson\nwill reconfigure itself next time the build command is run. Advanced\nusers can even write a small background script that utilizes a\nfilesystem event queue, such as\ninotify, to do this\nautomatically.\nThe answer is almost always subdir. Subproject exists for a very\nspecific use case: embedding external dependencies into your build\nprocess. As an example, suppose we are writing a game and wish to use\nSDL. Let us further suppose that SDL comes with a Meson build\ndefinition. Let us suppose even further that we don't want to use\nprebuilt binaries but want to compile SDL for ourselves.\nIn this case you would use subproject. The way to do it would be to\ngrab the source code of SDL and put it inside your own source\ntree. Then you would do sdl = subproject('sdl'), which would cause\nMeson to build SDL as part of your build and would then allow you to\nlink against it or do whatever else you may prefer.\nFor every other use you would use subdir. As an example, if you\nwanted to build a shared library in one dir and link tests against it\nin another dir, you would do something like this:\nBecause Make is slow. This is not an implementation issue, Make simply\ncan not be made fast. For further info we recommend you read this\npost\nby Evan Martin, the author of Ninja. Makefiles also have a syntax that\nis very unpleasant to write which makes them a big maintenance burden.\nThe only reason why one would use Make instead of Ninja is working on\na platform that does not have a Ninja port. Even in this case it is an\norder of magnitude less work to port Ninja than it is to write a Make\nbackend for Meson.\nJust use Ninja, you'll be happier that way. I guarantee it.\nA related question to this is Why is Meson's configuration language\nnot Turing-complete?\nThere are many good reasons for this, most of which are summarized on\nthis web page: Against The Use Of Programming Languages in\nConfiguration Files.\nIn addition to those reasons, not exposing Python or any other \"real\"\nprogramming language makes it possible to port Meson's implementation\nto a different language. This might become necessary if, for example,\nPython turns out to be a performance bottleneck. This is an actual\nproblem that has caused complications for GNU Autotools and SCons.\nEither by using GCC symbol\nvisibility or by writing a\nlinker\nscript. This\nhas the added benefit that your symbol definitions are in a standalone\nfile instead of being buried inside your build definitions. An example\ncan be found\nhere.\nWith GCC, all symbols on shared libraries are exported automatically\nunless you specify otherwise. With MSVC no symbols are exported by\ndefault. If your shared library exports no symbols, MSVC will silently\nnot produce an import library file leading to failures. The solution\nis to add symbol visibility definitions as specified in GCC\nwiki.\nYou probably did the equivalent to this:\nMeson is explicit. In this particular case it will not\nautomatically split your strings at whitespaces, instead it will take\nit as is and work extra hard to pass it to the compiler unchanged,\nincluding quoting it properly over shell invocations. This is\nmandatory to make e.g. files with spaces in them work flawlessly. To\npass multiple command line arguments, you need to explicitly put them\nin an array like this:\nYou probably had a project that looked something like this:\nThis defaults to c++11 on GCC compilers. Suppose you want to use\nc++14 instead, so you change the definition to this:\nBut when you recompile, it still uses c++11. The reason for this is\nthat default options are only looked at when you are setting up a\nbuild directory for the very first time. After that the setting is\nconsidered to have a value and thus the default value is ignored. To\nchange an existing build dir to c++14, either reconfigure your build\ndir with meson configure or delete the build dir and recreate it\nfrom scratch.\nThe reason we don't automatically change the option value when the\ndefault is changed is that it is impossible to know to do that\nreliably. The actual question that we need to solve is \"if the\noption's value is foo and the default value is bar, should we change\nthe option value to bar also\". There are many choices:\nif the user has changed the value themselves from the default, then\nwe must not change it back\nif the user has not changed the value, but changes the default\nvalue, then this section's premise would seem to indicate that the\nvalue should be changed\nsuppose the user changes the value from the default to foo, then\nback to bar and then changes the default value to bar, the correct\nstep to take is ambiguous by itself\nIn order to solve the latter question we would need to remember not\nonly the current and old value, but also all the times the user has\nchanged the value and from which value to which other value. Since\npeople don't remember their own actions that far back, toggling\nbetween states based on long history would be confusing.\nBecause of this we do the simple and understandable thing: default\nvalues are only defaults and will never affect the value of an option\nonce set.\nIt does not. In order for Meson to download anything from the net\nwhile building, two conditions must be met.\nFirst of all there needs to be a .wrap file with a download URL in\nthe subprojects directory. If one does not exist, Meson will not\ndownload anything.\nThe second requirement is that there needs to be an explicit\nsubproject invocation in your meson.build files. Either\nsubproject('foobar') or dependency('foobar', fallback : ['foobar', 'foo_dep']). If these declarations either are not in any build file\nor they are not called (due to e.g. if/else) then nothing is\ndownloaded.\nIf this is not sufficient for you, starting from release 0.40.0 Meson\nhas a option called wrap-mode which can be used to disable wrap\ndownloads altogether with --wrap-mode=nodownload. You can also\ndisable dependency fallbacks altogether with --wrap-mode=nofallback,\nwhich also implies the nodownload option.\nIf on the other hand, you want meson to always use the fallback\nfor dependencies, even when an external dependency exists and could\nsatisfy the version requirements, for example in order to make\nsure your project builds when fallbacks are used, you can use\n--wrap-mode=forcefallback since 0.46.0.\nBecause build systems are special in ways normal applications aren't.\nPerhaps the biggest limitation is that because Meson is used to build\nsoftware at the very lowest levels of the OS, it is part of the core\nbootstrap for new systems. Whenever support for a new CPU architecture\nis added, Meson must run on the system before software using it can be\ncompiled natively. This requirement adds two hard limitations.\nThe first one is that Meson must have the minimal amount of\ndependencies, because they must all be built during the bootstrap to\nget Meson to work.\nThe second is that Meson must support all CPU architectures, both\nexisting and future ones. As an example many new programming languages\nhave only an LLVM based compiler available. LLVM has limited CPU\nsupport compared to, say, GCC, and thus bootstrapping Meson on such\nplatforms would first require adding new processor support to\nLLVM. This is in most cases unfeasible.\nA further limitation is that we want developers on as many platforms\nas possible to submit to Meson development using the default tools\nprovided by their operating system. In practice what this means is\nthat Windows developers should be able to contribute using nothing but\nVisual Studio.\nAt the time of writing (April 2018) there are only three languages\nthat could fulfill these requirements:\nOut of these we have chosen Python because it is the best fit for our\nneeds.\nMeson needs to know several details about each compiler in order to\ncompile code with it. These include things such as which compiler\nflags to use for each option and how to detect the compiler from its\noutput. This information can not be input via a configuration file,\ninstead it requires changes to Meson's source code that need to be\nsubmitted to Meson master repository. In theory you can run your own\nforked version with custom patches, but that's not good use of your\ntime. Please submit the code upstream so everyone can use the\ntoolchain.\nThe steps for adding a new compiler for an existing language are\nroughly the following. For simplicity we're going to assume a C\ncompiler.\nCreate a new class with a proper name in\nmesonbuild/compilers/c.py. Look at the methods that other\ncompilers for the same language have and duplicate what they do.\nIf the compiler can only be used for cross compilation, make sure to\nflag it as such (see existing compiler classes for examples).\nAdd detection logic to mesonbuild/environment.py, look for a\nmethod called detect_c_compiler.\nRun the test suite and fix issues until the tests pass.\nSubmit a pull request, add the result of the test suite to your MR\n(linking an existing page is fine).\nIf the compiler is freely available, consider adding it to the CI\nsystem.\nThe naming convention for static libraries on Windows is usually\nfoo.lib.  Unfortunately, import libraries are also called foo.lib.\nThis causes filename collisions with the default library type where we\nbuild both shared and static libraries, and also causes collisions\nduring installation since all libraries are installed to the same\ndirectory by default.\nTo resolve this, we decided to default to creating static libraries of\nthe form libfoo.a when building with MSVC. This has the following\nadvantages:\nIf, for some reason, you really need your project to output static\nlibraries of the form foo.lib when building with MSVC, you can set\nthe\nname_prefix:\nkwarg to '' and the\nname_suffix:\nkwarg to 'lib'. To get the default behaviour for each, you can\neither not specify the kwarg, or pass [] (an empty array) to it.\nAutotools requires you to add private and public headers to the sources list so\nthat it knows what files to include in the tarball generated by make dist.\nMeson's dist command simply gathers everything committed to your git/hg\nrepository and adds it to the tarball, so adding headers to the sources list is\npointless.\nMeson uses Ninja which uses compiler dependency information to automatically\nfigure out dependencies between C sources and headers, so it will rebuild\nthings correctly when a header changes.\nThe only exception to this are generated headers, for which you must declare\ndependencies correctly.\nIf, for whatever reason, you do add non-generated headers to the sources list\nof a target, Meson will simply ignore them.\nLet's say you use a custom_target()\nto generate the headers, and then #include them in your C code. Here's how\nyou ensure that Meson generates the headers before trying to compile any\nsources in the build target:\nNow let's say you have a new target that links to libfoo:\nThis adds a link-time dependency between the two targets, but note that the\nsources of the targets have no compile-time dependencies and can be built\nin any order; which improves parallelism and speeds up builds.\nIf the sources in libbar also use foo-gen.h, that's a compile-time\ndependency, and you'll have to add libfoo_gen_headers to sources: for\nlibbar too:\nAlternatively, if you have multiple libraries with sources that link to\na library and also use its generated headers, this code is equivalent to above:\nNote: You should only add headers to sources: while declaring\na dependency. If your custom target outputs both sources and headers, you can\nuse the subscript notation to get only the header(s):\nA good example of a generator that outputs both sources and headers is\ngnome.mkenums().\nWith the cpp_eh and cpp_rtti options. A typical invocation would\nlook like this:\nThe RTTI option is only available since Meson version 0.53.0.\nThis depends highly on what you actually need to happen. The\n´buildtype` option is meant do describe the current build's\nintent. That is, what it will be used for. Individual options are\nfor determining what the exact state is. This becomes clearer with a\nfew examples.\nSuppose you have a source file that is known to miscompile when using\n-O3 and requires a workaround. Then you'd write something like this:\nOn the other hand if your project has extra logging and sanity checks\nthat you would like to be enabled during the day to day development\nwork (which uses the debug buildtype), you'd do this instead:\nIn this way the extra options are automatically used during\ndevelopment but are not compiled in release builds. Note that (since\nMeson 0.57.0) you can set optimization to, say, 2 in your debug builds\nif you want to. If you tried to set this flag based on optimization\nlevel, it would fail in this case.\nThis is valid (and good) code:\nBut there is currently no way to get something like this to work:\nThis means that you HAVE to write your library(...) calls in the order that the\ndependencies flow. While ideas to make arbitrary orders possible exist, they were\nrejected because reordering the library(...) calls was considered the \"proper\"\nway. See here for the discussion.\n\n\nif the user has changed the value themselves from the default, then\nwe must not change it back\n\n\nif the user has not changed the value, but changes the default\nvalue, then this section's premise would seem to indicate that the\nvalue should be changed\n\n\nsuppose the user changes the value from the default to foo, then\nback to bar and then changes the default value to bar, the correct\nstep to take is ambiguous by itself\n\n\n\nC\nC++\nPython\n\n\n\nCreate a new class with a proper name in\nmesonbuild/compilers/c.py. Look at the methods that other\ncompilers for the same language have and duplicate what they do.\n\n\nIf the compiler can only be used for cross compilation, make sure to\nflag it as such (see existing compiler classes for examples).\n\n\nAdd detection logic to mesonbuild/environment.py, look for a\nmethod called detect_c_compiler.\n\n\nRun the test suite and fix issues until the tests pass.\n\n\nSubmit a pull request, add the result of the test suite to your MR\n(linking an existing page is fine).\n\n\nIf the compiler is freely available, consider adding it to the CI\nsystem.\n\n\n"});