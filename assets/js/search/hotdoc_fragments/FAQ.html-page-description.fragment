fragment_downloaded_cb({"url": "FAQ.html#page-description", "fragment": "Meson Frequently Asked Questions \nWhat is the correct way to use threads such as pthreads \nHow to use Meson on a host where it is not available in system packages \nWhy can t I specify target files with a wildcard \nBut I really want to use wildcards \nShould I use subdir or subproject \nWhy is there not a Make backend \nWhy is Meson not just a Python module so I could code my build setup in Python \nHow do I do the equivalent of Libtools export symbol and export regex \nMy project works fine on Linux and MinGW but fails with MSVC due to a missing lib file \nI added some compiler flags and now the build fails with weird errors. What is happening \nWhy are changes to default project options ignored \nDoes wrap download sources behind my back \nSee also How do I do X in Meson. \nThis will set up everything on your behalf. People coming from Autotools or CMake want to do this by looking for libpthread.so manually. Don t do that it has tricky corner cases especially when cross compiling. \nStarting from version Meson is available from the Python Package Index so installing it simply a matter of running this command \nIf you don t have access to PyPI that is not a problem either. Meson has been designed to be easily runnable from an extracted source tarball or even a git checkout. First you need to download Meson. Then use this command to set up you build instead of plain meson. \nAfter this you don t have to care about invoking Meson any more. It remembers where it was originally invoked from and calls itself appropriately. As a user the only thing you need to do is to cd into your build directory and invoke ninja. \nInstead of specifying files explicitly people seem to want to do this \nMeson does not support this syntax and the reason for this is simple. This can not be made both reliable and fast. By reliable we mean that if the user adds a new source file to the subdirectory Meson should detect that and make it part of the build automatically. \nOne of the main requirements of Meson is that it must be fast. This means that a no op build in a tree of source files must take no more than a fraction of a second. This is only possible because Meson knows the exact list of files to check. If any target is specified as a wildcard glob this is no longer possible. Meson would need to re evaluate the glob every time and compare the list of files produced against the previous list. This means inspecting the entire source tree because the glob pattern could be src cpp or something like that This is impossible to do efficiently. \nThe main backend of Meson is Ninja which does not support wildcard matches either and for the same reasons. \nBecause of this all source files must be specified explicitly. \nIf the tradeoff between reliability and convenience is acceptable to you then Meson gives you all the tools necessary to do wildcard globbing. You are allowed to run arbitrary commands during configuration. First you need to write a script that locates the files to compile. Here s a simple shell script that writes all c files in the current directory one per line. \nThen you need to run this script in your Meson file convert the output into a string array and use the result in a target. \nThe script can be any executable so it can be written in shell Python Lua Perl or whatever you wish. \nAs mentioned above the tradeoff is that just adding new files to the source directory does not add them to the build automatically. To add them you need to tell Meson to reinitialize itself. The simplest way is to touch the meson.build file in your source root. Then Meson will reconfigure itself next time the build command is run. Advanced users can even write a small background script that utilizes a filesystem event queue such as inotify to do this automatically. \nThe answer is almost always subdir. Subproject exists for a very specific use case embedding external dependencies into your build process. As an example suppose we are writing a game and wish to use SDL. Let us further suppose that SDL comes with a Meson build definition. Let us suppose even further that we don t want to use prebuilt binaries but want to compile SDL for ourselves. \nIn this case you would use subproject. The way to do it would be to grab the source code of SDL and put it inside your own source tree. Then you would do sdl subproject sdl which would cause Meson to build SDL as part of your build and would then allow you to link against it or do whatever else you may prefer. \nFor every other use you would use subdir. As an example if you wanted to build a shared library in one dir and link tests against it in another dir you would do something like this \nBecause Make is slow. This is not an implementation issue Make simply can not be made fast. For further info we recommend you read this post by Evan Martin the author of Ninja. Makefiles also have a syntax that is very unpleasant to write which makes them a big maintenance burden. \nThe only reason why one would use Make instead of Ninja is working on a platform that does not have a Ninja port. Even in this case it is an order of magnitude less work to port Ninja than it is to write a Make backend for Meson. \nJust use Ninja you ll be happier that way. I guarantee it. \nA related question to this is Why is Meson s configuration language not Turing complete \nThere are many good reasons for this most of which are summarized on this web page Against The Use Of Programming Languages in Configuration Files. \nIn addition to those reasons not exposing Python or any other real programming language makes it possible to port Meson s implementation to a different language. This might become necessary if for example Python turns out to be a performance bottleneck. This is an actual problem that has caused complications for GNU Autotools and SCons. \nEither by using GCC symbol visibility or by writing a linker script. This has the added benefit that your symbol definitions are in a standalone file instead of being buried inside your build definitions. An example can be found here. \nWith GCC all symbols on shared libraries are exported automatically unless you specify otherwise. With MSVC no symbols are exported by default. If your shared library exports no symbols MSVC will silently not produce an import library file leading to failures. The solution is to add symbol visibility definitions as specified in GCC wiki. \nYou probably did the equivalent to this \nMeson is explicit. In this particular case it will not automatically split your strings at whitespaces instead it will take it as is and work extra hard to pass it to the compiler unchanged including quoting it properly over shell invocations. This is mandatory to make e.g. files with spaces in them work flawlessly. To pass multiple command line arguments you need to explicitly put them in an array like this \nYou probably had a project that looked something like this \nThis defaults to c on GCC compilers. Suppose you want to use c instead so you change the definition to this \nBut when you recompile it still uses c The reason for this is that default options are only looked at when you are setting up a build directory for the very first time. After that the setting is considered to have a value and thus the default value is ignored. To change an existing build dir to c either reconfigure your build dir with mesonconf or delete the build dir and recreate it from scratch. \nIt does not. In order for Meson to download anything from the net while building two conditions must be met. \nFirst of all there needs to be a wrap file with a download URL in the subprojects directory. If one does not exist Meson will not download anything. \nThe second requirement is that there needs to be an explicit subproject invocation in your meson.build files. Either subproject foobar or dependency foobar fallback foobar foo_dep If these declarations either are not in any build file or they are not called due to e.g. if else then nothing is downloaded. \nIf this is not sufficient for you starting from release Meson has a option called wrap mode which can be used to disable wrap downloads altogether. \n"});