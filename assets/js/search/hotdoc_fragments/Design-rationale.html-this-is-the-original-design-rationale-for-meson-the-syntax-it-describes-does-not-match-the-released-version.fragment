fragment_downloaded_cb({"url":"Design-rationale.html#this-is-the-original-design-rationale-for-meson-the-syntax-it-describes-does-not-match-the-released-version","fragment":"This is the original design rationale for Meson. The syntax it\ndescribes does not match the released version\nA software developer's most important tool is the editor. If you talk\nto coders about the editors they use, you are usually met with massive\nenthusiasm and praise. You will hear how Emacs is the greatest thing\never or how vi is so elegant or how Eclipse's integration features\nmake you so much more productive. You can sense the enthusiasm and\naffection that the people feel towards these programs.\nThe second most important tool, even more important than the compiler,\nis the build system.\nThose are pretty much universally despised.\nThe most positive statement on build systems you can usually get (and\nit might require some coaxing) is something along the lines of well,\nit's a terrible system, but all other options are even worse. It is\neasy to see why this is the case. For starters, commonly used free\nbuild systems have obtuse syntaxes. They use for the most part global\nvariables that are set in random locations so you can never really be\nsure what a given line of code does. They do strange and unpredictable\nthings at every turn.\nLet's illustrate this with a simple example. Suppose we want to run a\nprogram built with GNU Autotools under GDB. The instinctive thing to\ndo is to just run gdb programname. The problem is that this may or\nmay not work. In some cases the executable file is a binary whereas at\nother times it is a wrapper shell script that invokes the real binary\nwhich resides in a hidden subdirectory. GDB invocation fails if the\nbinary is a script but succeeds if it is not. The user has to remember\nthe type of each executable (which is an implementation detail of the\nbuild system) just to be able to debug them. Several other such pain\npoints can be found in this blog\npost.\nGiven these idiosyncrasies it is no wonder that most people don't want\nto have anything to do with build systems. They'll just copy-paste\ncode that works (somewhat) in one place to another and hope for the\nbest. They actively go out of their way not to understand the system\nbecause the mere thought of it is repulsive. Doing this also provides\na kind of inverse job security. If you don't know tool X, there's less\nchance of finding yourself responsible for its use in your\norganisation. Instead you get to work on more enjoyable things.\nThis leads to a vicious circle. Since people avoid the tools and don't\nwant to deal with them, very few work on improving them. The result is\napathy and stagnation.\n"});