fragment_downloaded_cb({"url":"Cross-compilation.html#machine-entries","fragment":"Machine Entries\nThe next bit is the definition of host and target machines. Every\ncross build definition must have one or both of them. If it had\nneither, the build would not be a cross build but a native build. You\ndo not need to define the build machine, as all necessary information\nabout it is extracted automatically. The definitions for host and\ntarget machines look the same. Here is a sample for host machine.\nThese values define the machines sufficiently for cross compilation\npurposes. The corresponding target definition would look the same but\nhave target_machine in the header. These values are available in\nyour Meson scripts. There are three predefined variables called,\nsurprisingly, build_machine, host_machine and\ntarget_machine. Determining the operating system of your host\nmachine is simply a matter of calling host_machine.system().\nStarting from version 1.2.0 you can get more fine grained information\nusing the .subsystem() and .kernel() methods. The return values of\nthese functions are documented in the reference table\npage.\nThere are two different values for the CPU. The first one is\ncpu_family. It is a general type of the CPU. This should have a\nvalue from the CPU Family table.\nNote that Meson does not add el to end cpu_family value for little\nendian systems. Big endian and little endian mips are both just\nmips, with the endian field set appropriately.\nThe second value is cpu which is a more specific subtype for the\nCPU. Typical values for a x86 CPU family might include i386 or\ni586 and for arm family armv5 or armv7hl. Note that CPU type\nstrings are very system dependent. You might get a different value if\nyou check its value on the same machine but with different operating\nsystems.\nIf you do not define your host machine, it is assumed to be the build\nmachine. Similarly if you do not specify target machine, it is assumed\nto be the host machine.\n"});