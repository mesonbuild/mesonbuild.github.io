fragment_downloaded_cb({"url":"Syntax.html#page-description","fragment":"The syntax of Meson's specification language has been kept as simple\nas possible. It is strongly typed so no object is ever converted to\nanother under the covers. Variables have no visible type which makes\nMeson dynamically typed (also known as duck typed).\nThe main building blocks of the language are variables, numbers,\nbooleans, strings, arrays, function calls, method calls, if\nstatements and includes.\nUsually one Meson statement takes just one line. There is no way to\nhave multiple statements on one line as in e.g. C. Function and\nmethod calls' argument lists can be split over multiple lines. Meson\nwill autodetect this case and do the right thing.\nIn other cases, (added 0.50) you can get multi-line statements by ending the\nline with a \\.  Apart from line ending whitespace has no syntactic meaning.\nVariables in Meson work just like in other high level programming\nlanguages. A variable can contain a value of any type, such as an\ninteger or a string. Variables don't need to be predeclared, you can\njust assign to them and they appear. Here's how you would assign\nvalues to two different variables.\nOne important difference in how variables work in Meson is that all\nobjects are immutable. This is different from, for example, how Python\nworks.\nMeson supports only integer numbers. They are declared simply by\nwriting them out. Basic arithmetic operations are supported.\nHexadecimal literals are supported since version 0.45.0:\nOctal and binary literals are supported since version 0.47.0:\nStrings can be converted to a number like this:\nNumbers can be converted to a string:\nA boolean is either true or false.\nStrings in Meson are declared with single quotes. To enter a literal\nsingle quote do it like this:\nThe full list of escape sequences is:\nAs in python and C, up to three octal digits are accepted in \\ooo.\nUnrecognized escape sequences are left in the string unchanged, i.e., the\nbackslash is left in the string.\nStrings can be concatenated to form a new string using the + symbol.\n(Added 0.49)\nYou can concatenate any two strings using / as an operator to build paths.\nThis will always use / as the path separator on all platforms.\nNote that this is equivalent to using join_paths(),\nwhich was obsoleted by this operator.\nStrings running over multiple lines can be declared with three single\nquotes, like this:\nThese are raw strings that do not support the escape sequences listed\nabove.  These strings can also be combined with the string formatting\nfunctionality described below.\nStrings can be built using the string formatting functionality.\nAs can be seen, the formatting works by replacing placeholders of type\n@number@ with the corresponding argument.\nStrings also support a number of other methods that return transformed\ncopies.\nSince 0.56.0, you can extract a substring from a string.\nThe method accepts negative values where negative start is relative to the end of\nstring len(string) - start as well as negative end.\nMeson version comparison conventions include:\nIt is best to be unambiguous and specify the full revision level to compare.\nArrays are delimited by brackets. An array can contain an arbitrary number of objects of any type.\nAccessing elements of an array can be done via array indexing:\nYou can add more items to an array like this:\nWhen adding a single item, you do not need to enclose it in an array:\nNote appending to an array will always create a new array object and\nassign it to my_array instead of modifying the original since all\nobjects in Meson are immutable.\nSince 0.49.0, you can check if an array contains an element like this:\nThe following methods are defined for all arrays:\nDictionaries are delimited by curly braces. A dictionary can contain an\narbitrary number of key value pairs. Keys are required to be strings, values can\nbe objects of any type. Prior to 0.53.0 keys were required to be literal strings.\nKeys must be unique:\nDictionaries are immutable and do not have a guaranteed order.\nDictionaries are available since 0.47.0.\nVisit the Reference Manual to read\nabout the methods exposed by dictionaries.\nSince 0.49.0, you can check if a dictionary contains a key like this:\nSince 0.53.0 Keys can be any expression evaluating to a string value, not limited\nto string literals any more.\nMeson provides a set of usable functions. The most common use case is\ncreating build objects.\nMost functions take only few positional arguments but several keyword\narguments, which are specified like this:\nStarting with version 0.49.0 keyword arguments can be specified\ndynamically. This is done by passing dictionary representing the\nkeywords to set in the kwargs keyword. The previous example would be\nspecified like this:\nA single function can take keyword argumets both directly in the\nfunction call and indirectly via the kwargs keyword argument. The\nonly limitation is that it is a hard error to pass any particular key\nboth as a direct and indirect argument.\nAttempting to do this causes Meson to immediately exit with an error.\nObjects can have methods, which are called with the dot operator. The\nexact methods it provides depends on the object.\nIf statements work just like in other languages.\nMeson has the standard range of logical operations which can be used in\nif statements.\nLogical operations work only on boolean values.\nTo do an operation on all elements of an iterable, use the foreach\ncommand.\nNote that Meson variables are immutable. Trying to assign a new value\nto the iterated object inside a foreach loop will not affect foreach's\ncontrol flow.\nHere's an example of how you could define two executables\nwith corresponding tests using arrays and foreach.\nHere's an example of you could iterate a set of components that\nshould be compiled in according to some configuration. This uses\na dictionary, which is available since 0.47.0.\nSince 0.49.0 break and continue keywords can be used inside foreach loops.\nA comment starts with the # character and extends until the end of the line.\nThe ternary operator works just like in other languages.\nThe only exception is that nested ternary operators are forbidden to\nimprove legibility. If your branching needs are more complex than this\nyou need to write an if/else construct.\nMost source trees have multiple subdirectories to process. These can\nbe handled by Meson's subdir command. It changes to the given\nsubdirectory and executes the contents of meson.build in that\nsubdirectory. All state (variables etc) are passed to and from the\nsubdirectory. The effect is roughly the same as if the contents of the\nsubdirectory's Meson file would have been written where the include\ncommand is.\nMeson does not currently support user-defined functions or\nmethods. The addition of user-defined functions would make Meson\nTuring-complete which would make it harder to reason about and more\ndifficult to integrate with tools like IDEs. More details about this\nare in the\nFAQ. If\nbecause of this limitation you find yourself copying and pasting code\na lot you may be able to use a foreach loop\ninstead.\nMeson is very actively developed and continuously improved. There is a\npossibility that future enhancements to the Meson build system will require\nchanges to the syntax. Such changes might be the addition of new reserved\nkeywords, changing the meaning of existing keywords or additions around the\nbasic building blocks like statements and fundamental types. It is planned\nto stabilize the syntax with the 1.0 release.\nThis is the full Meson grammar, as it is used to parse Meson build definition files:\n\n\n\\\\ Backslash\n\n\\' Single quote\n\n\\a Bell\n\n\\b Backspace\n\n\\f Formfeed\n\n\\n Newline\n\n\\r Carriage Return\n\n\\t Horizontal Tab\n\n\\v Vertical Tab\n\n\\ooo Character with octal value ooo\n\n\\xhh Character with hex value hh\n\n\\uxxxx Character with 16-bit hex value xxxx\n\n\\Uxxxxxxxx Character with 32-bit hex value xxxxxxxx\n\n\\N{name} Character named name in Unicode database\n\n\n\nlength, the size of the array\n\ncontains, returns true if the array contains the object given as argument, false otherwise\n\nget, returns the object at the given index, negative indices count from the back of the array, indexing out of bounds is a fatal error. Provided for backwards-compatibility, it is identical to array indexing.\n\n"});