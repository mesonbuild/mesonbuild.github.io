fragment_downloaded_cb({"url":"Reference-manual.html#page-description","fragment":"The following functions are available in build files. Click on each to\nsee the description and usage. The objects returned by them are list\nafterwards.\nAdds the positional arguments to the compiler command line. This\nfunction has two keyword arguments:\nlanguage: specifies the language(s) that the arguments should be\napplied to. If a list of languages is given, the arguments are added\nto each of the corresponding compiler command lines. Note that there\nis no way to remove an argument set in this way. If you have an\nargument that is only used in a subset of targets, you have to specify\nit in per-target flags.\nnative (since 0.48.0): a boolean specifying whether the arguments should be\napplied to the native or cross compilation. If true the arguments\nwill only be used for native compilations. If false the arguments\nwill only be used in cross compilations. If omitted, the flags are\nadded to native compilations if compiling natively and cross\ncompilations (only) when cross compiling.\nThe arguments are used in all compiler invocations with the exception\nof compile tests, because you might need to run a compile test with\nand without the argument in question. For this reason only the\narguments explicitly specified are used during compile tests.\nNote: Usually you should use add_project_arguments instead,\nbecause that works even when you project is used as a subproject.\nNote: You must pass always arguments individually arg1, arg2, ... rather than as a string 'arg1 arg2', ...\nLike add_global_arguments but the arguments are passed to the linker.\nAdd programming languages used by the project. Equivalent to having\nthem in the project declaration. This function is usually used to\nadd languages that are only used under some conditions, like this:\nTakes the following keyword arguments:\nrequired: defaults to true, which means that if any of the languages\nspecified is not found, Meson will halt. (since 0.47.0) The value of a\nfeature option can also be passed.\nnative (since 0.54.0): if set to true, the language will be used to compile for the build\nmachine, if false, for the host machine.\nReturns true if all languages specified were found and false otherwise.\nIf native is omitted, the languages may be used for either build or host\nmachine, but are never required for the build machine.  (i.e. it is equivalent\nto add_languages(*langs*, native: false, required: *required*) and add_languages(*langs*, native: true, required: false). This default behaviour\nmay change to native: false in a future meson version.\nThis function behaves in the same way as add_global_arguments except\nthat the arguments are only used for the current project, they won't\nbe used in any other subproject.\nLike add_project_arguments but the arguments are passed to the linker.\nAdd a custom test setup that can be used to run the tests with a\ncustom setup, for example under Valgrind. The keyword arguments are\nthe following:\nTo use the test setup, run meson test --setup=*name* inside the\nbuild dir.\nNote that all these options are also available while running the\nmeson test script for running tests instead of ninja test or\nmsbuild RUN_TESTS.vcxproj, etc depending on the backend.\n(since 0.52.0)\nThis function creates a new top-level target. Like all top-level\ntargets, this integrates with the selected backend. For instance, with\nyou can run it as meson compile target_name. This is a dummy target\nthat does not execute any command, but ensures that all dependencies\nare built. Dependencies can be any build target (e.g. return value of\nexecutable(), custom_target(), etc)\nAbort with an error message if condition evaluates to false.\n(since 0.53.0) message argument is optional and defaults to print the condition\nstatement instead.\nCreates a benchmark item that will be run when the benchmark target is\nrun. The behavior of this function is identical to test()\nexcept for:\nNote: Prior to 0.52.0 benchmark would warn that depends and\npriority were unsupported, this is incorrect.\n(since 0.46.0)\nBuilds both a static and shared library with the given sources.\nPositional and keyword arguments are otherwise the same as for\nlibrary. Source files will be compiled only once and\nobject files will be reused to build both shared and static libraries,\nunless b_staticpic user option or pic argument are set to false in\nwhich case sources will be compiled twice.\nThe returned buildtarget always represents the\nshared library. In addition it supports the following extra methods:\nCreates a build target whose type can be set dynamically with the\ntarget_type keyword argument.\ntarget_type may be set to one of:\nThis declaration:\nis equivalent to this:\nThe object returned by build_target and all convenience wrappers for\nbuild_target such as executable and\nlibrary has methods that are documented in the object\nmethods section below.\nCreates an empty configuration object. You should add your\nconfiguration with its method calls and\nfinally use it in a call to configure_file.\n(since 0.49.0) Takes an optional dictionary as first argument. If\nprovided, each key/value pair is added into the configuration_data\nas if set() method was called for each of them.\nThis function can run in three modes depending on the keyword arguments\npassed to it.\nWhen a configuration_data() object is passed\nto the configuration: keyword argument, it takes a template file as\nthe input: (optional) and produces the output: (required) by\nsubstituting values from the configuration data as detailed in the\nconfiguration file documentation. (since 0.49.0)\nA dictionary can be passed instead of a\nconfiguration_data() object.\nWhen a list of strings is passed to the command: keyword argument,\nit takes any source or configured file as the input: and assumes\nthat the output: is produced when the specified command is run.\n(since 0.47.0) When the copy: keyword argument is set to true,\nthis function will copy the file provided in input: to a file in the\nbuild directory with the name output: in the current directory.\nThese are all the supported keyword arguments:\nCreate a custom top level build target. The only positional argument\nis the name of this target and the keyword arguments are the\nfollowing.\nThe list of strings passed to the command keyword argument accept\nthe following special string substitutions:\n(since 0.47.0) The depfile keyword argument also accepts the\n@BASENAME@ and @PLAINNAME@ substitutions.\nThe returned object also has methods that are documented in the\nobject methods section below.\nNote: Assuming that command: is executed by a POSIX sh shell\nis not portable, notably to Windows. Instead, consider using a\nnative: true executable(), or a python script.\nThis function returns a dependency object that\nbehaves like the return value of dependency but is\ninternal to the current build. The main use case for this is in\nsubprojects. This allows a subproject to easily specify how it should\nbe used. This makes it interchangeable with the same dependency that\nis provided externally by the system. This function has the following\nkeyword arguments:\nFinds an external dependency (usually a library installed on your\nsystem) with the given name with pkg-config and with\nCMake if pkg-config fails. Additionally,\nframeworks (OSX only) and library-specific fallback detection\nlogic\nare also supported.\nDependencies can also be resolved in two other ways:\nif the same name was used in a meson.override_dependency prior to\nthe call to dependency, the overriding dependency will be returned\nunconditionally; that is, the overriding dependency will be used\nindependent of whether an external dependency is installed in the system.\nTypically, meson.override_dependency will have been used by a\nsubproject.\nby a fallback subproject which, if needed, will be brought into the current\nbuild specification as if subproject() had been called.\nThe subproject can be specified with the fallback argument.  Alternatively,\nif the fallback argument is absent, since 0.55.0 Meson can\nautomatically identify a subproject as a fallback if a wrap file\nprovides the\ndependency, or if a subproject has the same name as the dependency.\nIn the latter case, the subproject must use meson.override_dependency to\nspecify the replacement, or Meson will report a hard error.  See the\nWrap documentation\nfor more details.  This automatic search can be controlled using the\nallow_fallback keyword argument.\nThis function supports the following keyword arguments:\nIf dependency_name is '', the dependency is always not found. So\nwith required: false, this always returns a dependency object for\nwhich the found() method returns false, and which can be passed\nlike any other dependency to the dependencies: keyword argument of a\nbuild_target. This can be used to implement a dependency which is\nsometimes not required e.g. in some branches of a conditional, or with\na fallback: kwarg, can be used to declare an optional dependency\nthat only looks in the specified subproject, and only if that's\nallowed by --wrap-mode.\nThe returned object also has methods that are documented in the\nobject methods section below.\n(since 0.44.0)\nReturns a disabler object.\nPrint the argument string and halts the build process.\n(since 0.35.0)\nReturns an empty environment variable object.\n(since 0.52.0) Takes an optional dictionary as first argument. If\nprovided, each key/value pair is added into the environment_object\nas if set() method was called for each of them.\nCreates a new executable. The first argument specifies its name and\nthe remaining positional arguments define the input files to use. They\ncan be of the following types:\nThese input files can be sources, objects, libraries, or any other\nfile. Meson will automatically categorize them based on the extension\nand use them accordingly. For instance, sources (.c, .cpp,\n.vala, .rs, etc) will be compiled and objects (.o, .obj) and\nlibraries (.so, .dll, etc) will be linked.\nWith the Ninja backend, Meson will create a build-time order-only\ndependency on\nall generated input files, including unknown files. This is needed to\nbootstrap the generation of the real dependencies in the\ndepfile generated\nby your compiler to determine when to rebuild sources. Ninja relies on\nthis dependency file for all input files, generated and non-generated.\nThe behavior is similar for other backends.\nExecutable supports the following keyword arguments. Note that just\nlike the positional arguments above, these keyword arguments can also\nbe passed to shared and static libraries.\nThe list of sources, objects, and dependencies is always\nflattened, which means you can freely nest and add lists while\ncreating the final list.\nThe returned object also has methods that are documented in the\nobject methods section below.\n(since 0.31.0) (deprecated) Use find_library() method of\nthe compiler object as obtained from\nmeson.get_compiler(lang).\nprogram_name1 here is a string that can be an executable or script\nto be searched for in PATH or other places inside the project.\nThe search order is:\n(since 0.37.0) program_name2 and later positional arguments are used as fallback\nstrings to search for. This is meant to be used for cases where the\nprogram may have many alternative names, such as foo and\nfoo.py. The function will check for the arguments one by one and the\nfirst one that is found is returned.\nKeyword arguments are the following:\nrequired By default, required is set to true and Meson will\nabort if no program can be found. If required is set to false,\nMeson continue even if none of the programs can be found. You can\nthen use the .found() method on the returned object to check\nwhether it was found or not. (since 0.47.0) The value of a\nfeature option can also be passed to the\nrequired keyword argument.\nnative (since 0.43.0): defines how this executable should be searched. By default\nit is set to false, which causes Meson to first look for the\nexecutable in the cross file (when cross building) and if it is not\ndefined there, then from the system. If set to true, the cross\nfile is ignored and the program is only searched from the system.\ndisabler (since 0.49.0): if true and the program couldn't be found, return a\ndisabler object instead of a not-found object.\nversion (since 0.52.0): specifies the required version, see\ndependency() for argument format. The version of the program\nis determined by running program_name --version command. If stdout is empty\nit fallbacks to stderr. If the output contains more text than simply a version\nnumber, only the first occurrence of numbers separated by dots is kept.\nIf the output is more complicated than that, the version checking will have to\nbe done manually using run_command().\ndirs (since 0.53.0): extra list of absolute paths where to look for program\nnames.\nMeson will also autodetect scripts with a shebang line and run them\nwith the executable/interpreter specified in it both on Windows\n(because the command invocator will reject the command otherwise) and\nUnixes (if the script file does not have the executable bit set).\nHence, you must not manually add the interpreter while using this\nscript as part of a list of commands.\nIf you need to check for a program in a non-standard location, you can\njust pass an absolute path to find_program, e.g.\nIt is also possible to pass an array to find_program in case you\nneed to construct the set of paths to search on the fly:\nThe returned object also has methods that are documented in the\nobject methods section below.\nThis command takes the strings given to it in arguments and returns\ncorresponding File objects that you can use as sources for build\ntargets. The difference is that file objects remember the subdirectory\nthey were defined in and can be used anywhere in the source tree. As\nan example suppose you have source file foo.cpp in subdirectory\nbar1 and you would like to use it in a build target that is defined\nin bar2. To make this happen you first create the object in bar1\nlike this:\nThen you can use it in bar2 like this:\nMeson will then do the right thing.\nSee also: custom_target\nThis function creates a generator object that can\nbe used to run custom compilation commands. The only positional\nargument is the executable to use. It can either be a self-built\nexecutable or one returned by find_program. Keyword arguments are the\nfollowing:\nThe returned object also has methods that are documented in the\nobject methods section below.\nThe template strings passed to all the above keyword arguments accept\nthe following special substitutions:\nEach string passed to the output keyword argument must be\nconstructed using one or both of these two substitutions.\nIn addition to the above substitutions, the arguments keyword\nargument also accepts the following:\nNOTE: Generators should only be used for outputs that will only\nbe used as inputs for a build target or a custom\ntarget. When you use the processed output of a\ngenerator in multiple targets, the generator will be run multiple\ntimes to create outputs for each target. Each output will be created\nin a target-private directory @BUILD_DIR@.\nIf you want to generate files for general purposes such as for\ngenerating headers to be used by several sources, or data that will be\ninstalled, and so on, use a custom_target instead.\nObtains the value of the project build option\nspecified in the positional argument.\nNote that the value returned for built-in options that end in dir\nsuch as bindir and libdir is always a path relative to (and\ninside) the prefix.\nThe only exceptions are: sysconfdir, localstatedir, and\nsharedstatedir which will return the value passed during\nconfiguration as-is, which may be absolute, or relative to prefix.\ninstall_dir arguments handles that as expected, but\nif you need the absolute path to one of these e.g. to use in a define\netc., you should use get_option('prefix') / get_option('localstatedir')\nFor options of type feature a\nfeature option object\nis returned instead of a string.\nSee feature options\ndocumentation for more details.\nThis function can be used to dynamically obtain a variable. res = get_variable(varname, fallback) takes the value of varname (which\nmust be a string) and stores the variable of that name into res. If\nthe variable does not exist, the variable fallback is stored to\nresinstead. If a fallback is not specified, then attempting to read\na non-existing variable will cause a fatal error.\nImports the given extension module. Returns an opaque object that can\nbe used to call the methods of the module. Here's an example for a\nhypothetical testmod module.\nReturns an opaque object which contains the directories (relative to\nthe current directory) given in the positional arguments. The result\ncan then be passed to the include_directories: keyword argument when\nbuilding executables or libraries. You can use the returned object in\nany subdirectory you want, Meson will make the paths work\nautomatically.\nNote that this function call itself does not add the directories into\nthe search path, since there is no global search path. For something\nlike that, see add_project_arguments().\nSee also implicit_include_directories parameter of\nexecutable(), which adds current source and build\ndirectories to include path.\nEach directory given is converted to two include paths: one that is\nrelative to the source root and one relative to the build root.\nFor example, with the following source tree layout in\n/home/user/project.git:\nmeson.build:\ninclude/meson.build:\nsrc/meson.build:\nIf the build tree is /tmp/build-tree, the following include paths\nwill be added to the executable() call: -I/tmp/build-tree/include -I/home/user/project.git/include.\nThis function has one keyword argument is_system which, if set,\nflags the specified directories as system directories. This means that\nthey will be used with the -isystem compiler argument rather than\n-I on compilers that support this flag (in practice everything\nexcept Visual Studio).\nInstalls files from the source tree that are listed as positional\narguments. The following keyword arguments are supported:\ninstall_dir: the absolute or relative path to the installation\ndirectory. If this is a relative path, it is assumed to be relative\nto the prefix.\nIf omitted, the directory defaults to {datadir}/{projectname} (since 0.45.0).\ninstall_mode: specify the file mode in symbolic format and\noptionally the owner/uid and group/gid for the installed files. For\nexample:\ninstall_mode: 'rw-r--r--' for just the file mode\ninstall_mode: ['rw-r--r--', 'nobody', 'nobody'] for the file mode and the user/group\ninstall_mode: ['rw-r-----', 0, 0] for the file mode and uid/gid\nTo leave any of these three as the default, specify false.\nSee Installing for more examples.\nInstalls the specified header files from the source tree into the\nsystem header directory (usually /{prefix}/include) during the\ninstall step. This directory can be overridden by specifying it with\nthe install_dir keyword argument. If you just want to install into a\nsubdirectory of the system header directory, then use the subdir\nargument. As an example if this has the value myproj then the\nheaders would be installed to /{prefix}/include/myproj.\nFor example, this will install common.h and kola.h into\n/{prefix}/include:\nThis will install common.h and kola.h into /{prefix}/include/myproj:\nThis will install common.h and kola.h into /{prefix}/cust/myproj:\nAccepts the following keywords:\nInstalls the specified man files from the source tree into system's\nman directory during the install step. This directory can be\noverridden by specifying it with the install_dir keyword argument.\nAccepts the following keywords:\n(since 0.49.0) manpages are no longer compressed\nimplicitly.\nInstalls the entire given subdirectory and its contents from the\nsource tree to the location specified by the keyword argument\ninstall_dir.\nThe following keyword arguments are supported:\nFor a given directory foo:\ninstall_subdir('foo', install_dir : 'share', strip_directory : false) creates\ninstall_subdir('foo', install_dir : 'share', strip_directory : true) creates\ninstall_subdir('foo/bar', install_dir : 'share', strip_directory : false) creates\ninstall_subdir('foo/bar', install_dir : 'share', strip_directory : true) creates\n(since 0.52.0)\nReturns true if a variable is a disabler and false otherwise.\nReturns true if a variable of the given name exists and false otherwise.\nBuild a jar from the specified Java source files. Keyword arguments\nare the same as executable's, with the addition of\nmain_class which specifies the main class to execute when running\nthe jar with java -jar file.jar.\n(since 0.36.0)\nJoins the given strings into a file system path segment. For example\njoin_paths('foo', 'bar') results in foo/bar. If any one of the\nindividual segments is an absolute path, all segments before it are\ndropped. That means that join_paths('foo', '/bar') returns /bar.\nWarning Don't use join_paths() for sources in library and\nexecutable, you should use files instead.\n(since 0.49.0) Using the/ operator on strings is equivalent to calling\njoin_paths.\nBuilds a library that is either static, shared or both depending on\nthe value of default_library\nuser option.\nYou should use this instead of shared_library,\nstatic_library or\nboth_libraries most of the time. This allows you\nto toggle your entire project (including subprojects) from shared to\nstatic with only one option. This option applies to libraries being\nbuilt internal to the entire project. For external dependencies, the\ndefault library type preferred is shared. This can be adapted on a per\nlibrary basis using the dependency()) static keyword.\nThe keyword arguments for this are the same as for\nexecutable with the following additions:\nstatic_library, shared_library and both_libraries also accept\nthese keyword arguments.\nNote: You can set name_prefix and name_suffix to [], or omit\nthem for the default behaviour for each platform.\nThis function prints its argument to stdout.\n(since 0.54.0) Can take more than one argument that will be\nseparated by space.\n(since 0.44.0)\nThis function prints its argument to stdout prefixed with WARNING:.\n(since 0.54.0) Can take more than one argument that will be separated by\nspace.\n(since 0.53.0)\nThis function is used to summarize build configuration at the end of the build\nprocess. This function provides a way for projects (and subprojects) to report\nthis information in a clear way.\nThe content is a series of key/value pairs grouped into sections. If\nthe section keyword argument is omitted, those key/value pairs are\nimplicitly grouped into a section with no title. key/value pairs can\noptionally be grouped into a dictionary, but keep in mind that\ndictionaries does not guarantee ordering. key must be string,\nvalue can be:\nsummary() can be called multiple times as long as the same\nsection/key pair doesn't appear twice. All sections will be collected\nand printed at the end of the configuration in the same order as they\nhave been called.\nKeyword arguments:\nExample:\nOutput:\nThe first argument to this function must be a string defining the name\nof this project.\nThe project name can be any string you want, it's not used for\nanything except descriptive purposes. However since it is written to\ne.g. the dependency manifest is usually makes sense to have it be the\nsame as the project tarball or pkg-config name. So for example you\nwould probably want to use the name libfoobar instead of The Foobar\nLibrary.\nIt may be followed by the list of programming languages that the project uses.\n(since 0.40.0) The list of languages is optional.\nThese languages may be used both for native: false (the default)\n(host machine) targets and for native: true (build machine) targets.\n(since 0.56.0) The build machine compilers for the specified\nlanguages are not required.\nSupported values for languages are c, cpp (for C++), cuda, d,\nobjc, objcpp, fortran, java, cs (for C#), vala and rust.\nProject supports the following keyword arguments.\ndefault_options: takes an array of strings. The strings are in the\nform key=value and have the same format as options to\nmeson configure. For example to set the default project type you would\nset this: default_options : ['buildtype=debugoptimized']. Note\nthat these settings are only used when running Meson for the first\ntime. Global options such as buildtype can only be specified in\nthe master project, settings in subprojects are ignored. Project\nspecific options are used normally even in subprojects.\nlicense: takes a string or array of strings describing the license(s) the\ncode is under. To avoid ambiguity it is recommended to use a standardized\nlicense identifier from the SPDX license list.\nUsually this would be something like license : 'GPL-2.0-or-later', but if\nthe code has multiple licenses you can specify them as an array like this:\nlicense : ['proprietary', 'GPL-3.0-only']. Note that the text is informal\nand is only written to the dependency manifest. Meson does not do any license\nvalidation, you are responsible for verifying that you abide by all licensing\nterms. You can access the value in your Meson build files with\nmeson.project_license().\nmeson_version: takes a string describing which Meson version the\nproject requires. Usually something like >=0.28.0.\nsubproject_dir: specifies the top level directory name that holds\nMeson subprojects. This is only meant as a compatibility option\nfor existing code bases that house their embedded source code in a\ncustom directory. All new projects should not set this but instead\nuse the default value. It should be noted that this keyword\nargument is ignored inside subprojects. There can be only one\nsubproject dir and it is set in the top level Meson file.\nversion: which is a free form string describing the version of\nthis project. You can access the value in your Meson build files\nwith meson.project_version(). Since 0.57.0 this can also be a\nFile object pointing to a file that contains exactly one line of\ntext.\nRuns the command specified in positional arguments. command can be a\nstring, or the output of find_program(),\nfiles() or configure_file(), or a\ncompiler object.\nReturns an opaque object containing the result\nof the invocation. The command is run from an unspecified directory,\nand Meson will set three environment variables MESON_SOURCE_ROOT,\nMESON_BUILD_ROOT and MESON_SUBDIR that specify the source\ndirectory, build directory and subdirectory the target was defined in,\nrespectively.\nThis function supports the following keyword arguments:\nSee also External commands.\nThis function creates a new top-level target that runs a specified\ncommand with the specified arguments. Like all top-level targets, this\nintegrates with the selected backend. For instance, you can run it as\nmeson compile target_name. Note that a run target produces no output\nas far as Meson is concerned. It is only meant for tasks such as\nrunning a code formatter or flashing an external device's firmware\nwith a built file.\nThe command is run from an unspecified directory, and Meson will set\nthree environment variables MESON_SOURCE_ROOT, MESON_BUILD_ROOT\nand MESON_SUBDIR that specify the source directory, build directory\nand subdirectory the target was defined in, respectively.\nAssigns a value to the given variable name. Calling\nset_variable('foo', bar) is equivalent to foo = bar.\n(since 0.46.1) The value parameter can be an array type.\nBuilds a shared library with the given sources. Positional and keyword\narguments are the same as for library with the following\nextra keyword arguments.\n(since 0.37.0)\nBuilds a shared module with the given sources. Positional and keyword\narguments are the same as for library.\nThis is useful for building modules that will be dlopen()ed and\nhence may contain undefined symbols that will be provided by the\nlibrary that is loading it.\nIf you want the shared module to be able to refer to functions and\nvariables defined in the executable it is loaded by,\nyou will need to set the export_dynamic argument of the executable to\ntrue.\nSupports the following extra keyword arguments:\nNote: Linking to a shared module is not supported on some\nplatforms, notably OSX.  Consider using a\nshared_library instead, if you need to both\ndlopen() and link with a library.\nBuilds a static library with the given sources. Positional and keyword\narguments are otherwise the same as for library, but it\nhas one argument the others don't have:\npic (since 0.36.0): builds the library as positional\nindependent code (so it can be linked into a shared library). This\noption has no effect on Windows and OS X since it doesn't make\nsense on Windows and PIC cannot be disabled on OS X.\nprelink since0.57.0: if true the object files in the target\nwill be prelinked, meaning that it will contain only one prelinked\nobject file rather than the individual object files.\nEnters the specified subdirectory and executes the meson.build file\nin it. Once that is done, it returns and execution continues on the\nline following this subdir() command. Variables defined in that\nmeson.build file are then available for use in later parts of the\ncurrent build file and in all subsequent build files executed with\nsubdir().\nNote that this means that each meson.build file in a source tree can\nand must only be executed once.\nThis function has one keyword argument.\nStops further interpretation of the meson script file from the point\nof the invocation. All steps executed up to this point are valid and\nwill be executed by meson. This means that all targets defined before\nthe call of subdir_done will be build.\nIf the current script was called by subdir the execution returns to\nthe calling directory and continues as if the script had reached the\nend. If the current script is the top level script meson configures\nthe project as defined up to this point.\nExample:\nThe executable exe1 will be build, while the executable exe2 is not\nbuild.\nTakes the project specified in the positional argument and brings that\nin the current build specification by returning a subproject\nobject. Subprojects must always be placed inside\nthe subprojects directory at the top source directory. So for\nexample a subproject called foo must be located in\n${MESON_SOURCE_ROOT}/subprojects/foo. Supports the following keyword\narguments:\nNote that you can use the returned subproject\nobject to access any variable in the\nsubproject. However, if you want to use a dependency object from\ninside a subproject, an easier way is to use the fallback: keyword\nargument to dependency().\nSee additional documentation.\nDefines a test to run with the test harness. Takes two positional\narguments, the first is the name of the test and the second is the\nexecutable to run. The executable can be an executable build target\nobject returned by\nexecutable() or an external program\nobject returned by\nfind_program().\n(since 0.55.0) When cross compiling, if an exe_wrapper is needed and\ndefined the environment variable MESON_EXE_WRAPPER will be set to\nthe string value of that wrapper (implementation detail: using\nmesonlib.join_args). Test scripts may use this to run cross built\nbinaries. If your test needs MESON_EXE_WRAPPER in cross build\nsituations it is your responsibility to return code 77 to tell the\nharness to report \"skip\".\nBy default, environment variable\nMALLOC_PERTURB_\nis automatically set by meson test to a random value between 1..255.\nThis can help find memory leaks on configurations using glibc,\nincluding with non-GCC compilers. However, this can have a performance\nimpact, and may fail a test due to external libraries whose internals\nare out of the user's control. To check if this feature is causing an\nexpected runtime crash, disable the feature by temporarily setting\nenvironment variable MALLOC_PERTURB_=0. While it's preferable to\nonly temporarily disable this check, if a project requires permanent\ndisabling of this check in meson.build do like:\nargs: arguments to pass to the executable\nenv: environment variables to set, such as ['NAME1=value1', 'NAME2=value2'], or an environment()\nobject which allows more sophisticated\nenvironment juggling. (since 0.52.0) A dictionary is also accepted.\nis_parallel: when false, specifies that no other test must be\nrunning at the same time as this test\nshould_fail: when true the test is considered passed if the\nexecutable returns a non-zero return value (i.e. reports an error)\nsuite: 'label' (or list of labels ['label1', 'label2'])\nattached to this test. The suite name is qualified by a (sub)project\nname resulting in (sub)project_name:label. In the case of a list\nof strings, the suite names will be (sub)project_name:label1,\n(sub)project_name:label2, etc.\ntimeout: the amount of seconds the test is allowed to run, a test\nthat exceeds its time limit is always considered failed, defaults to\n30 seconds. Since 0.57 if timeout is <= 0 the test has infinite duration,\nin previous versions of Meson the test would fail with a timeout immediately.\nworkdir: absolute path that will be used as the working directory\nfor the test\ndepends (since 0.46.0): specifies that this test depends on the specified\ntarget(s), even though it does not take any of them as a command\nline argument. This is meant for cases where test finds those\ntargets internally, e.g. plugins or globbing. Those targets are built\nbefore test is executed even if they have build_by_default : false.\nprotocol (since 0.50.0): specifies how the test results are parsed and can\nbe one of exitcode, tap, or gtest. For more information about test\nharness protocol read Unit Tests. The following values are\naccepted:\npriority (since 0.52.0):specifies the priority of a test. Tests with a\nhigher priority are started before tests with a lower priority.\nThe starting order of tests with identical priorities is\nimplementation-defined. The default priority is 0, negative numbers are\npermitted.\nDefined tests can be run in a backend-agnostic way by calling\nmeson test inside the build dir, or by using backend-specific\ncommands, such as ninja test or msbuild RUN_TESTS.vcxproj.\nThis command detects revision control commit information at build time\nand places it in the specified output file. This file is guaranteed to\nbe up to date on every build. Keywords are similar to custom_target.\nMeson will read the contents of input, substitute the\nreplace_string with the detected revision number, and write the\nresult to output. This method returns a\ncustom_target object that (as usual) should be\nused to signal dependencies if other targets use the file outputted\nby this.\nFor example, if you generate a header with this and want to use that\nin a build target, you must add the return value to the sources of\nthat build target. Without that, Meson will not know the order in\nwhich to build the targets.\nIf you desire more specific behavior than what this command provides,\nyou should use custom_target.\nThese are built-in objects that are always available.\nThe meson object allows you to introspect various properties of the\nsystem. This object is always mapped in the meson variable. It has\nthe following methods.\nadd_dist_script(script_name, arg1, arg2, ...) (since 0.48.0): causes the script\ngiven as argument to run during dist operation after the\ndistribution source has been generated but before it is\narchived. Note that this runs the script file that is in the\nstaging directory, not the one in the source directory. If the\nscript file can not be found in the staging directory, it is a hard\nerror. This command can only invoked from the main project, calling\nit from a subproject is a hard error. (since 0.49.0) Accepts multiple arguments\nfor the fscript. (since 0.54.0) The MESON_SOURCE_ROOT and MESON_BUILD_ROOT\nenvironment variables are set when dist scripts are run.\n(since 0.55.0) The output of configure_file, files, and find_program\nas well as strings.\n(since 0.57.0) file objects and the output of configure_file may be\n*used as the script_name parameter.\nadd_install_script(script_name, arg1, arg2, ...): causes the script\ngiven as an argument to be run during the install step, this script\nwill have the environment variables MESON_SOURCE_ROOT,\nMESON_BUILD_ROOT, MESON_INSTALL_PREFIX,\nMESON_INSTALL_DESTDIR_PREFIX, and MESONINTROSPECT set.\nAll positional arguments are passed as parameters.\n(since 0.54.0) If meson install is called with the --quiet option, the\nenvironment variable MESON_INSTALL_QUIET will be set.\n(since 0.55.0) The output of configure_file, files, find_program,\ncustom_target, indexes of custom_target, executable, library, and\nother built targets as well as strings.\n(since 0.57.0) file objects and the output of configure_file may be\n*used as the script_name parameter.\nMeson uses the DESTDIR environment variable as set by the\ninherited environment to determine the (temporary) installation\nlocation for files. Your install script must be aware of this while\nmanipulating and installing files. The correct way to handle this is\nwith the MESON_INSTALL_DESTDIR_PREFIX variable which is always set\nand contains DESTDIR (if set) and prefix joined together. This\nis useful because both are usually absolute paths and there are\nplatform-specific edge-cases in joining two absolute paths.\nIn case it is needed, MESON_INSTALL_PREFIX is also always set and\nhas the value of the prefix option passed to Meson.\nMESONINTROSPECT contains the path to the introspect command that\ncorresponds to the meson executable that was used to configure the\nbuild. (This might be a different path than the first executable\nfound in PATH.) It can be used to query build configuration. Note\nthat the value will contain many parts, f.ex., it may be python3 /path/to/meson.py introspect. The user is responsible for splitting\nthe string to an array if needed by splitting lexically like a UNIX\nshell would. If your script uses Python, shlex.split() is the\neasiest correct way to do this.\nadd_postconf_script(script_name, arg1, arg2, ...): runs the\nexecutable given as an argument after all project files have been\ngenerated. This script will have the environment variables\nMESON_SOURCE_ROOT and MESON_BUILD_ROOT set.\n(since 0.55.0) The output of configure_file, files, and find_program\nas well as strings.\n(since 0.57.0) file objects and the output of configure_file may be\n*used as the script_name parameter.\nbackend() (since 0.37.0): returns a string representing the\ncurrent backend: ninja, vs2010, vs2015, vs2017, vs2019,\nor xcode.\nbuild_root(): returns a string with the absolute path to the build\nroot directory. (deprecated since 0.56.0): this function will return the\nbuild root of the parent project if called from a subproject, which is usually\nnot what you want. Try using current_build_dir() or project_build_root().\nsource_root(): returns a string with the absolute path to the\nsource root directory. Note: you should use the files() function\nto refer to files in the root source directory instead of\nconstructing paths manually with meson.source_root().\n(deprecated since 0.56.0): This function will return the source root of the\nparent project if called from a subproject, which is usually not what you want.\nTry using current_source_dir() or project_source_root().\nproject_build_root() (since 0.56.0): returns a string with the absolute path\nto the build root directory of the current (sub)project.\nproject_source_root() (since 0.56.0): returns a string with the absolute path\nto the source root directory of the current (sub)project.\ncurrent_build_dir(): returns a string with the absolute path to the\ncurrent build directory.\ncurrent_source_dir(): returns a string to the current source\ndirectory. Note: you do not need to use this function when\npassing files from the current source directory to a function since\nthat is the default. Also, you can use the files() function to\nrefer to files in the current or any other source directory instead\nof constructing paths manually with meson.current_source_dir().\nget_compiler(language): returns an object describing a\ncompiler, takes one positional argument which is\nthe language to use. It also accepts one keyword argument, native\nwhich when set to true makes Meson return the compiler for the build\nmachine (the \"native\" compiler) and when false it returns the host\ncompiler (the \"cross\" compiler). If native is omitted, Meson\nreturns the \"cross\" compiler if we're currently cross-compiling and\nthe \"native\" compiler if we're not.\nget_cross_property(propname, fallback_value):\nConsider get_external_property() instead. Returns the given\nproperty from a cross file, the optional fallback_value is returned\nif not cross compiling or the given property is not found.\nget_external_property(propname, fallback_value, native: true/false)\n(since 0.54.0): returns the given property from a native or cross file.\nThe optional fallback_value is returned if the given property is not found.\nThe optional native: true forces retrieving a variable from the\nnative file, even when cross-compiling.\nIf native: false or not specified, variable is retrieved from the\ncross-file if cross-compiling, and from the native-file when not cross-compiling.\ncan_run_host_binaries() (since 0.55.0): returns true if the build machine can run\nbinaries compiled for the host. This returns true unless you are\ncross compiling, need a helper to run host binaries, and don't have one.\nFor example when cross compiling from Linux to Windows, one can use wine\nas the helper.\nhas_exe_wrapper(): (since 0.55.0) (deprecated). Use can_run_host_binaries instead.\ninstall_dependency_manifest(output_name): installs a manifest file\ncontaining a list of all subprojects, their versions and license\nfiles to the file name given as the argument.\nis_cross_build(): returns true if the current build is a cross\nbuild and false otherwise.\nis_subproject(): returns true if the current project is being\nbuilt as a subproject of some other project and false otherwise.\nis_unity(): returns true when doing a unity\nbuild (multiple sources are combined before\ncompilation to reduce build time) and false otherwise.\noverride_find_program(progname, program) (since 0.46.0):\nspecifies that whenever find_program is used to find a program\nnamed progname, Meson should not look it up on the system but\ninstead return program, which may either be the result of\nfind_program, configure_file or executable. (since 0.55.0) If a version\ncheck is passed to find_program for a program that has been overridden with\nan executable, the current project version is used.\nIf program is an executable, it cannot be used during configure.\noverride_dependency(name, dep_object) (since 0.54.0):\nspecifies that whenever dependency(name, ...) is used, Meson should not\nlook it up on the system but instead return dep_object, which may either be\nthe result of dependency() or declare_dependency(). It takes optional\nnative keyword arguments. Doing this in a subproject allows the parent\nproject to retrieve the dependency without having to know the dependency\nvariable name: dependency(name, fallback : subproject_name).\nproject_version(): returns the version string specified in\nproject function call.\nproject_license(): returns the array of licenses specified in\nproject function call.\nproject_name(): returns the project name specified in the project\nfunction call.\nversion(): return a string with the version of Meson.\nProvides information about the build machine — the machine that is\ndoing the actual compilation. See\nCross-compilation. It has the following\nmethods:\ncpu_family(): returns the CPU family name. This\ntable contains all known CPU\nfamilies. These are guaranteed to continue working.\ncpu(): returns a more specific CPU name, such as i686, amd64,\netc.\nsystem(): returns the operating system name.  This\ntable Lists all of\nthe currently known Operating System names, these are guaranteed to\ncontinue working.\nendian(): returns big on big-endian systems and little on\nlittle-endian systems.\nCurrently, these values are populated using\nplatform.system()\nand\nplatform.machine(). If\nyou think the returned values for any of these are incorrect for your\nsystem or CPU, or if your OS is not in the linked table, please file\na bug report with\ndetails and we'll look into it.\nProvides information about the host machine — the machine on which the\ncompiled binary will run. See\nCross-compilation.\nIt has the same methods as build_machine.\nWhen not cross-compiling, all the methods return the same values as\nbuild_machine (because the build machine is the host machine)\nNote that while cross-compiling, it simply returns the values defined\nin the cross-info file.\nProvides information about the target machine — the machine on which\nthe compiled binary's output will run. Hence, this object should only\nbe used while cross-compiling a compiler. See\nCross-compilation.\nIt has the same methods as build_machine.\nWhen all compilation is 'native', all the methods return the same\nvalues as build_machine (because the build machine is the host\nmachine and the target machine).\nNote that while cross-compiling, it simply returns the values defined\nin the cross-info file. If target_machine values are not defined in\nthe cross-info file, host_machine values are returned instead.\nAll strings have the following methods. Strings\nare immutable, all operations return their results as a new string.\ncontains(string): returns true if string contains the string\nspecified as the argument.\nendswith(string): returns true if string ends with the string\nspecified as the argument.\nformat(): formats text, see the Syntax\nmanual for usage info.\njoin(list_of_strings): the opposite of split, for example\n'.'.join(['a', 'b', 'c'] yields 'a.b.c'.\nsplit(split_character): splits the string at the specified\ncharacter (or whitespace if not set) and returns the parts in an\narray.\nstartswith(string): returns true if string starts with the string\nspecified as the argument\nsubstring(start,end) (since 0.56.0): returns a substring specified from start to end.\nBoth start and end arguments are optional, so, for example, 'foobar'.substring() will return 'foobar'.\nstrip(): removes whitespace at the beginning and end of the string.\n(since 0.43.0) Optionally can take one positional string argument,\nand all characters in that string will be stripped.\nto_int(): returns the string converted to an integer (error if string\nis not a number).\nto_lower(): creates a lower case version of the string.\nto_upper(): creates an upper case version of the string.\nunderscorify(): creates a string where every non-alphabetical\nnon-number character is replaced with _.\nversion_compare(comparison_string): does semantic version\ncomparison, if x = '1.2.3' then x.version_compare('>1.0.0')\nreturns true.\nNumbers support these methods:\nA boolean object has two simple methods:\nto_int(): returns either 1 or 0.\nto_string(): returns the string 'true' if the boolean is true or\n'false' otherwise. You can also pass it two strings as positional\narguments to specify what to return for true/false. For instance,\nbool.to_string('yes', 'no') will return yes if the boolean is\ntrue and no if it is false.\nThe following methods are defined for all arrays:\ncontains(item): returns true if the array contains the object\ngiven as argument, false otherwise\nget(index, fallback): returns the object at the given index,\nnegative indices count from the back of the array, indexing out of\nbounds returns the fallback value (since 0.38.0) or, if it is\nnot specified, causes a fatal error\nlength(): the size of the array\nYou can also iterate over arrays with the foreach\nstatement.\n(since 0.47.0)\nThe following methods are defined for all dictionaries:\nhas_key(key): returns true if the dictionary contains the key\ngiven as argument, false otherwise\nget(key, fallback): returns the value for the key given as first\nargument if it is present in the dictionary, or the optional\nfallback value given as the second argument. If a single argument\nwas given and the key was not found, causes a fatal error\nkeys(): returns an array of keys in the dictionary\nYou can also iterate over dictionaries with the foreach\nstatement.\n(since 0.48.0) Dictionaries can be added (e.g. d1 = d2 + d3 and d1 += d2).\nValues from the second dictionary overrides values from the first.\nThese are objects returned by the functions listed above.\nThis object is returned by\nmeson.get_compiler(lang). It represents a compiler\nfor a given language and allows you to query its properties. It has\nthe following methods:\nalignment(typename): returns the alignment of the type specified in\nthe positional argument, you can specify external dependencies to\nuse with dependencies keyword argument.\ncmd_array(): returns an array containing the command arguments for\nthe current compiler.\ncompiles(code): returns true if the code fragment given in the\npositional argument compiles, you can specify external dependencies\nto use with dependencies keyword argument, code can be either a\nstring containing source code or a file object pointing to the\nsource code.\ncompute_int(expr, ...'): computes the value of the given expression\n(as an example 1 + 2). When cross compiling this is evaluated with\nan iterative algorithm, you can specify keyword arguments low\n(defaults to -1024), high (defaults to 1024) and guess to\nspecify max and min values for the search and the value to try\nfirst.\nfind_library(lib_name, ...): tries to find the library specified in\nthe positional argument. The result\nobject can be used just like the return\nvalue of dependency. If the keyword argument required is false,\nMeson will proceed even if the library is not found. By default the\nlibrary is searched for in the system library directory\n(e.g. /usr/lib). This can be overridden with the dirs keyword\nargument, which can be either a string or a list of strings.\n(since 0.47.0) The value of a feature\noption can also be passed to the required keyword argument.\n(since 0.49.0) If the keyword argument disabler is true and the\ndependency couldn't be found, return a disabler object\ninstead of a not-found dependency. (since 0.50.0) The has_headers keyword\nargument can be a list of header files that must be found as well, using\nhas_header() method. All keyword arguments prefixed with header_ will be\npassed down to has_header() method with the prefix removed. (since 0.51.0)\nThe static keyword (boolean) can be set to true to limit the search to\nstatic libraries and false for dynamic/shared.\nfirst_supported_argument(list_of_strings): given a list of\nstrings, returns the first argument that passes the has_argument\ntest or an empty array if none pass.\nfirst_supported_link_argument(list_of_strings) (since 0.46.0):\ngiven a list of strings, returns the first argument that passes the\nhas_link_argument test or an empty array if none pass.\nget_define(definename): returns the given preprocessor symbol's\nvalue as a string or empty string if it is not defined.\n(since 0.47.0) This method will concatenate string literals as\nthe compiler would. E.g. \"a\" \"b\" will become \"ab\".\nget_id(): returns a string identifying the compiler. For example,\ngcc, msvc, and more.\nget_argument_syntax() (since 0.49.0): returns a string identifying the type\nof arguments the compiler takes. Can be one of gcc, msvc, or an undefined\nstring value. This method is useful for identifying compilers that are not\ngcc or msvc, but use the same argument syntax as one of those two compilers\nsuch as clang or icc, especially when they use different syntax on different\noperating systems.\nget_linker_id() (since 0.53.0): returns a string identifying the linker.\nFor example, ld.bfd, link, and more.\nget_supported_arguments(list_of_string) (since 0.43.0): returns\nan array containing only the arguments supported by the compiler,\nas if has_argument were called on them individually.\nget_supported_link_arguments(list_of_string) (since 0.46.0): returns\nan array containing only the arguments supported by the linker,\nas if has_link_argument were called on them individually.\nhas_argument(argument_name): returns true if the compiler accepts\nthe specified command line argument, that is, can compile code\nwithout erroring out or printing a warning about an unknown flag.\nhas_link_argument(argument_name) (since 0.46.0): returns true if\nthe linker accepts the specified command line argument, that is, can\ncompile and link code without erroring out or printing a warning\nabout an unknown flag. Link arguments will be passed to the\ncompiler, so should usually have the -Wl, prefix. On VisualStudio\na /link argument will be prepended.\nhas_function(funcname): returns true if the given function is\nprovided by the standard library or a library passed in with the\nargs keyword, you can specify external dependencies to use with\ndependencies keyword argument.\ncheck_header(header_name) (since 0.47.0): returns true if the\nspecified header is usable with the specified prefix,\ndependencies, and arguments. You can specify external dependencies\nto use with dependencies keyword argument and extra code to put\nabove the header test with the prefix keyword. In order to look\nfor headers in a specific directory you can use args : '-I/extra/include/dir, but this should only be used in exceptional\ncases for includes that can't be detected via pkg-config and passed\nvia dependencies. (since 0.50.0) The required keyword argument\ncan be used to abort if the header cannot be found.\nhas_header(header_name): returns true if the specified header\nexists, and is faster than check_header() since it only does a\npre-processor check. You can specify external dependencies to use\nwith dependencies keyword argument and extra code to put above the\nheader test with the prefix keyword. In order to look for headers\nin a specific directory you can use args : '-I/extra/include/dir,\nbut this should only be used in exceptional cases for includes that\ncan't be detected via pkg-config and passed via dependencies.\n(since 0.50.0) The required keyword argument can be used to\nabort if the header cannot be found.\nhas_header_symbol(headername, symbolname): detects\nwhether a particular symbol (function, variable, #define, type\ndefinition, etc) is declared in the specified header, you can\nspecify external dependencies to use with dependencies keyword\nargument. (since 0.50.0) The required keyword argument can be\nused to abort if the symbol cannot be found.\nhas_member(typename, membername): takes two arguments, type name\nand member name and returns true if the type has the specified\nmember, you can specify external dependencies to use with\ndependencies keyword argument.\nhas_members(typename, membername1, membername2, ...): takes at\nleast two arguments, type name and one or more member names, returns\ntrue if the type has all the specified members, you can specify\nexternal dependencies to use with dependencies keyword argument.\nhas_multi_arguments(arg1, arg2, arg3, ...) (since 0.37.0): the same as\nhas_argument but takes multiple arguments and uses them all in a\nsingle compiler invocation.\nhas_multi_link_arguments(arg1, arg2, arg3, ...) (since 0.46.0):\nthe same as has_link_argument but takes multiple arguments and\nuses them all in a single compiler invocation.\nhas_type(typename): returns true if the specified token is a type,\nyou can specify external dependencies to use with dependencies\nkeyword argument.\nlinks(code): returns true if the code fragment given in the\npositional argument compiles and links, you can specify external\ndependencies to use with dependencies keyword argument, code can\nbe either a string containing source code or a file object\npointing to the source code.\nrun(code): attempts to compile and execute the given code fragment,\nreturns a run result object, you can specify external dependencies\nto use with dependencies keyword argument, code can be either a\nstring containing source code or a file object pointing to the\nsource code.\nsymbols_have_underscore_prefix() (since 0.37.0): returns true\nif the C symbol mangling is one underscore (_) prefixed to the symbol.\nsizeof(typename, ...): returns the size of the given type\n(e.g. 'int') or -1 if the type is unknown, to add includes set\nthem in the prefix keyword argument, you can specify external\ndependencies to use with dependencies keyword argument.\nversion(): returns the compiler's version number as a string.\nhas_function_attribute(name) (since 0.48.0): returns true if the\ncompiler supports the GNU style (__attribute__(...)) name. This is\npreferable to manual compile checks as it may be optimized for compilers that\ndo not support such attributes.\nThis table lists all of the\nsupported attributes.\nget_supported_function_attributes(list_of_names) (since 0.48.0):\nreturns an array containing any names that are supported GCC style\nattributes. Equivalent to has_function_attribute was called on each of them\nindividually.\nThe following keyword arguments can be used:\nargs: used to pass a list of compiler arguments that are\nrequired to find the header or symbol. For example, you might need\nto pass the include path -Isome/path/to/header if a header is not\nin the default include path. (since 0.38.0) you should use the\ninclude_directories keyword described below. You may also want to\npass a library name -lfoo for has_function to check for a function.\nSupported by all methods except get_id, version, and find_library.\ninclude_directories (since 0.38.0): specifies extra directories for\nheader searches.\nname: the name to use for printing a message about the compiler\ncheck. Supported by the methods compiles(), links(), and\nrun(). If this keyword argument is not passed to those methods, no\nmessage will be printed about the check.\nno_builtin_args: when set to true, the compiler arguments controlled\nby built-in configuration options are not added.\nprefix: adds #includes and other things that are\nrequired for the symbol to be declared. System definitions should be\npassed via compiler args (eg: _GNU_SOURCE is often required for\nsome symbols to be exposed on Linux, and it should be passed via\nargs keyword argument, see below). Supported by the methods\nsizeof, has_type, has_function, has_member, has_members,\ncheck_header, has_header, has_header_symbol, get_define\nNote: These compiler checks do not use compiler arguments added\nwith add_*_arguments(), via -Dlang_args on the command-line, or\nthrough CFLAGS/LDFLAGS, etc in the environment. Hence, you can\ntrust that the tests will be fully self-contained, and won't fail\nbecause of custom flags added by other parts of the build file or by\nusers.\nNote that if you have a single prefix with all your dependencies, you\nmight find it easier to append to the environment variables\nC_INCLUDE_PATH with GCC/Clang and INCLUDE with MSVC to expand the\ndefault include path, and LIBRARY_PATH with GCC/Clang and LIB with\nMSVC to expand the default library search path.\nHowever, with GCC, these variables will be ignored when\ncross-compiling. In that case you need to use a specs file. See:\nhttp://www.mingw.org/wiki/SpecsFileHOWTO\nA build target is either an executable, shared\nlibrary, static library, both\nshared and static library or shared\nmodule.\nextract_all_objects(): is same as extract_objects but returns all\nobject files generated by this target. (since 0.46.0) keyword argument\nrecursive must be set to true to also return objects passed to\nthe object argument of this target. By default only objects built\nfor this target are returned to maintain backward compatibility with\nprevious versions.  The default will eventually be changed to true\nin a future version.\nextract_objects(source1, source2, ...): takes as its arguments\na number of source files as string or\nfiles() and returns an opaque value representing the\nobject files generated for those source files. This is typically used\nto take single object files and link them to unit tests or to compile\nsome source files with custom flags. To use the object file(s)\nin another build target, use the objects: keyword argument.\nfull_path(): returns a full path pointing to the result target file.\nNOTE: In most cases using the object itself will do the same job as\nthis and will also allow Meson to setup inter-target dependencies\ncorrectly. Please file a bug if that doesn't work for you.\nprivate_dir_include(): returns a opaque value that works like\ninclude_directories but points to the private directory of this\ntarget, usually only needed if an another target needs to access\nsome generated internal headers of this target\nname() (since 0.54.0): returns the target name.\nThis object is returned by\nconfiguration_data() and encapsulates\nconfiguration values to be used for generating configuration files. A\nmore in-depth description can be found in the the configuration wiki\npage It has three methods:\nget(varname, default_value): returns the value of varname, if the\nvalue has not been set returns default_value if it is defined\n(since 0.38.0) and errors out if not\nget_unquoted(varname, default_value) (since 0.44.0): returns the value\nof varname but without surrounding double quotes (\"). If the value has\nnot been set returns default_value if it is defined and errors out if not.\nhas(varname): returns true if the specified variable is set\nkeys()(since 0.57.0): returns an array of keys of\nthe configuration data object.\nYou can iterate over this array with the foreach\nstatement.\nmerge_from(other) (since 0.42.0): takes as argument a different\nconfiguration data object and copies all entries from that object to\nthe current.\nset(varname, value), sets a variable to a given value\nset10(varname, boolean_value) is the same as above but the value\nis either true or false and will be written as 1 or 0,\nrespectively\nset_quoted(varname, value) is same as set but quotes the value\nin double quotes (\")\nThey all take the description keyword that will be written in the\nresult file. The replacement assumes a file with C syntax. If your\ngenerated file is source code in some other language, you probably\ndon't want to add a description field because it most likely will\ncause a syntax error.\nThis object is returned by custom_target and\ncontains a target with the following methods:\nfull_path(): returns a full path pointing to the result target file\nNOTE: In most cases using the object itself will do the same job as\nthis and will also allow Meson to setup inter-target dependencies\ncorrectly. Please file a bug if that doesn't work for you.\n(since 0.54.0) It can be also called on indexes objects:\ncustom_targets[i].full_path().\n[index]: returns an opaque object that references this target, and\ncan be used as a source in other targets. When it is used as such it\nwill make that target depend on this custom target, but the only\nsource added will be the one that corresponds to the index of the\ncustom target's output argument.\nto_list() (since 0.54.0): returns a list of opaque objects that references\nthis target, and can be used as a source in other targets. This can be used to\niterate outputs with foreach loop.\nThis object is returned by dependency() and contains\nan external dependency with the following methods:\nfound(): returns whether the dependency was found.\nname() (since 0.48.0): returns the name of the dependency that was\nsearched. Returns internal for dependencies created with\ndeclare_dependency().\nget_pkgconfig_variable(varname) (since 0.36.0): gets the\npkg-config variable specified, or, if invoked on a non pkg-config\ndependency, error out. (since 0.44.0) You can also redefine a\nvariable by passing a list to the define_variable parameter\nthat can affect the retrieved variable: ['prefix', '/']).\n(since 0.45.0) A warning is issued if the variable is not defined,\nunless a default parameter is specified.\n(Deprecated since 0.56.0) use get_variable(pkgconfig : ...) instead\nget_configtool_variable(varname) (since 0.44.0): gets the\ncommand line argument from the config tool (with -- prepended), or,\nif invoked on a non config-tool dependency, error out.\n(Deprecated since 0.56.0) use get_variable(configtool : ...) instead\ntype_name(): returns a string describing the type of the\ndependency, the most common values are internal for deps created\nwith declare_dependency() and pkgconfig for system dependencies\nobtained with Pkg-config.\nversion(): the version number as a string, for example 1.2.8.\nunknown if the dependency provider doesn't support determining the\nversion.\ninclude_type(): returns whether the value set by the include_type kwarg\nas_system(value): returns a copy of the dependency object, which has changed\nthe value of include_type to value. The value argument is optional and\ndefaults to 'preserve'.\nas_link_whole() Since 0.56.0 Only dependencies created with\ndeclare_dependency(), returns a copy of the dependency object with all\nlink_with arguments changed to link_whole. This is useful for example for\nfallback dependency from a subproject built with default_library=static.\nNote that all link_with objects must be static libraries otherwise an error\nwill be raised when trying to link_whole a shared library.\npartial_dependency(compile_args : false, link_args : false, links : false, includes : false, sources : false) (since 0.46.0): returns\na new dependency object with the same name, version, found status,\ntype name, and methods as the object that called it. This new\nobject will only inherit other attributes from its parent as\ncontrolled by keyword arguments.\nIf the parent has any dependencies, those will be applied to the new\npartial dependency with the same rules. So, given:\ndep3 will add ['-Werror=foo', '-Werror=bar'] to the compiler args\nof any target it is added to, but libfoo will not be added to the\nlink_args.\nNote: A bug present until 0.50.1 results in the above behavior\nnot working correctly.\nThe following arguments will add the following attributes:\nget_variable(cmake : str, pkgconfig : str, configtool : str, internal: str, default_value : str, pkgconfig_define : [str, str])\n(since 0.51.0): a generic variable getter method, which replaces the\nget_type_variable methods. This allows one to get the variable\nfrom a dependency without knowing specifically how that dependency\nwas found. If default_value is set and the value cannot be gotten\nfrom the object then default_value is returned, if it is not set\nthen an error is raised.\n(since 0.54.0) added internal keyword.\nA disabler object is an object that behaves in much the same way as\nNaN numbers do in floating point math. That is when used in any\nstatement (function call, logical op, etc) they will cause the\nstatement evaluation to immediately short circuit to return a disabler\nobject. A disabler object has one method:\nThis object is returned by find_program() and\ncontains an external (i.e. not built as part of this project) program\nand has the following methods:\nfound(): returns whether the executable was found.\npath(): (since 0.55.0) (deprecated) use full_path() instead.\nReturns a string pointing to the script or executable\nNOTE: You should not need to use this method. Passing the object\nitself should work in all cases. For example: run_command(obj, arg1, arg2).\nfull_path() (since 0.55.0): which returns a string pointing to the script or\nexecutable NOTE: You should not need to use this method. Passing the object\nitself should work in all cases. For example: run_command(obj, arg1, arg2).\nThis object is returned by environment() and stores\ndetailed information about how environment variables should be set\nduring tests. It should be passed as the env keyword argument to\ntests and other functions. It has the following methods.\nappend(varname, value1, value2, ...): appends the given values to\nthe old value of the environment variable, e.g.  env.append('FOO', 'BAR', 'BAZ', separator : ';') produces BOB;BAR;BAZ if FOO had\nthe value BOB and plain BAR;BAZ if the value was not defined. If\nthe separator is not specified explicitly, the default path\nseparator for the host operating system will be used, i.e. ';' for\nWindows and ':' for UNIX/POSIX systems.\nprepend(varname, value1, value2, ...): same as append\nexcept that it writes to the beginning of the variable.\nset(varname, value1, value2): sets the environment variable\nspecified in the first argument to the values in the second argument\njoined by the separator, e.g.  env.set('FOO', 'BAR'), sets envvar\nFOO to value BAR. See append() above for how separators work.\nNote: All these methods overwrite the previously-defined value(s)\nif called twice with the same varname.\nThis object is returned by find_library() and\ncontains an external (i.e. not built as part of this project)\nlibrary. This object has the following methods:\nfound(): returns whether the library was found.\ntype_name() (since 0.48.0): returns a string describing\nthe type of the dependency, which will be library in this case.\npartial_dependency(compile_args : false, link_args : false, links : false, includes : false, source : false) (since 0.46.0): returns\na new dependency object with the same name, version, found status,\ntype name, and methods as the object that called it. This new\nobject will only inherit other attributes from its parent as\ncontrolled by keyword arguments.\n(since 0.47.0)\nThe following methods are defined for all feature options:\nThis object is returned by generator() and contains a\ngenerator that is used to transform files from one type to another by\nan executable (e.g. idl files into source code and headers).\nThis object is returned by subproject() and is an\nopaque object representing it.\nfound() (since 0.48.0): returns whether the subproject was\nsuccessfully setup\nget_variable(name, fallback): fetches the specified variable from\ninside the subproject. This is useful to, for instance, get a\ndeclared dependency from the\nsubproject.\nIf the variable does not exist, the variable fallback is returned.\nIf a fallback is not specified, then attempting to read a non-existing\nvariable will cause a fatal error.\nThis object encapsulates the result of trying to compile and run a\nsample piece of code with compiler.run() or\nrun_command(). It has the following methods:\n\n\nlanguage: specifies the language(s) that the arguments should be\napplied to. If a list of languages is given, the arguments are added\nto each of the corresponding compiler command lines. Note that there\nis no way to remove an argument set in this way. If you have an\nargument that is only used in a subset of targets, you have to specify\nit in per-target flags.\n\n\nnative (since 0.48.0): a boolean specifying whether the arguments should be\napplied to the native or cross compilation. If true the arguments\nwill only be used for native compilations. If false the arguments\nwill only be used in cross compilations. If omitted, the flags are\nadded to native compilations if compiling natively and cross\ncompilations (only) when cross compiling.\n\n\n\n\nrequired: defaults to true, which means that if any of the languages\nspecified is not found, Meson will halt. (since 0.47.0) The value of a\nfeature option can also be passed.\n\n\nnative (since 0.54.0): if set to true, the language will be used to compile for the build\nmachine, if false, for the host machine.\n\n\n\n\nenv: environment variables to set, such as ['NAME1=value1', 'NAME2=value2'], or an environment()\nobject which allows more sophisticated\nenvironment juggling. (since 0.52.0) A dictionary is also accepted.\n\nexe_wrapper: a list containing the wrapper command or script followed by the arguments to it\n\ngdb: if true, the tests are also run under gdb\n\n\ntimeout_multiplier: a number to multiply the test timeout with.\nSince 0.57 if timeout_multiplier is <= 0 the test has infinite duration,\nin previous versions of Meson the test would fail with a timeout immediately.\n\nis_default (since 0.49.0): a bool to set whether this is the default test setup.\nIf true, the setup will be used whenever meson test is run\nwithout the --setup option.\n\n\nbenchmark() has no is_parallel keyword because benchmarks are not run in parallel\nbenchmark() does not automatically add the MALLOC_PERTURB_ environment variable\n\n\n\nget_shared_lib() returns the shared library build target\n\nget_static_lib() returns the static library build target\n\n\nexecutable\nshared_library\nshared_module\nstatic_library\nboth_libraries\nlibrary\njar\n\n\n\ncapture (since 0.41.0): when this argument is set to true,\nMeson captures stdout of the command and writes it to the target\nfile specified as output.\n\ncommand: as explained above, if specified, Meson does not create\nthe file itself but rather runs the specified command, which allows\nyou to do fully custom file generation. (since 0.52.0) The command can contain\nfile objects and more than one file can be passed to the input keyword\nargument, see custom_target() for details about string\nsubstitutions.\n\ncopy (since 0.47.0): as explained above, if specified Meson only\ncopies the file from input to output.\n\ndepfile (since 0.52.0): a dependency file that the command can write listing\nall the additional files this target depends on. A change\nin any one of these files triggers a reconfiguration.\n\nformat (since 0.46.0): the format of defines. It defaults to meson, and so substitutes\n#mesondefine statements and variables surrounded by @ characters, you can also use cmake\nto replace #cmakedefine statements and variables with the ${variable} syntax. Finally you can use\ncmake@ in which case substitutions will apply on #cmakedefine statements and variables with\nthe @variable@ syntax.\n\ninput: the input file name. If it's not specified in configuration\nmode, all the variables in the configuration: object (see above)\nare written to the output: file.\n\ninstall (since 0.50.0): when true, this generated file is installed during\nthe install step, and install_dir must be set and not empty. When false, this\ngenerated file is not installed regardless of the value of install_dir.\nWhen omitted it defaults to true when install_dir is set and not empty,\nfalse otherwise.\n\ninstall_dir: the subdirectory to install the generated file to\n(e.g. share/myproject), if omitted or given the value of empty\nstring, the file is not installed.\n\ninstall_mode (since 0.47.0): specify the file mode in symbolic format\nand optionally the owner/uid and group/gid for the installed files.\n\noutput: the output file name. (since 0.41.0) may contain\n@PLAINNAME@ or @BASENAME@ substitutions. In configuration mode,\nthe permissions of the input file (if it is specified) are copied to\nthe output file.\n\noutput_format (since 0.47.0): the format of the output to generate when no input\nwas specified. It defaults to c, in which case preprocessor directives\nwill be prefixed with #, you can also use nasm, in which case the\nprefix will be %.\n\nencoding (since 0.47.0): set the file encoding for the input and output file,\ndefaults to utf-8. The supported encodings are those of python3, see\nstandard-encodings.\n\n\n\nbuild_by_default (since 0.38.0): causes, when set to true, to\nhave this target be built by default. This means it will be built when\nmeson compile is called without any arguments. The default value is false.\n(since 0.50.0) If build_by_default is explicitly set to false, install\nwill no longer override it. If build_by_default is not set, install will\nstill determine its default.\n\nbuild_always (deprecated): if true this target is always considered out of\ndate and is rebuilt every time.  Equivalent to setting both\nbuild_always_stale and build_by_default to true.\n\nbuild_always_stale (since 0.47.0): if true the target is always considered out of date.\nUseful for things such as build timestamps or revision control tags.\nThe associated command is run even if the outputs are up to date.\n\ncapture: there are some compilers that can't be told to write\ntheir output to a file but instead write it to standard output. When\nthis argument is set to true, Meson captures stdout and writes it\nto the target file. Note that your command argument list may not\ncontain @OUTPUT@ when capture mode is active.\n\nconsole (since 0.48.0): keyword argument conflicts with capture, and is meant\nfor commands that are resource-intensive and take a long time to\nfinish. With the Ninja backend, setting this will add this target\nto Ninja's console pool,\nwhich has special properties such as not buffering stdout and\nserializing all targets in this pool.\n\ncommand: command to run to create outputs from inputs. The command\nmay be strings or the return value of functions that return file-like\nobjects such as find_program(),\nexecutable(), configure_file(),\nfiles(), custom_target(), etc.\nMeson will automatically insert the appropriate dependencies on\ntargets and files listed in this keyword argument.\nNote: always specify commands in array form ['commandname', '-arg1', '-arg2'] rather than as a string 'commandname -arg1 -arg2' as the latter will not work.\n\ndepend_files: files (string,\nfiles(), or configure_file()) that\nthis target depends on but are not listed in the command keyword\nargument. Useful for adding regen dependencies.\n\ndepends: specifies that this target depends on the specified\ntarget(s), even though it does not take any of them as a command\nline argument. This is meant for cases where you have a tool that\ne.g. does globbing internally. Usually you should just put the\ngenerated sources as inputs and Meson will set up all dependencies\nautomatically.\n\ndepfile: a dependency file that the command can write listing\nall the additional files this target depends on, for example a C\ncompiler would list all the header files it included, and a change\nin any one of these files triggers a recompilation\n\ninput: list of source files. (since 0.41.0) the list is flattened.\n\ninstall: when true, this target is installed during the install step\n\ninstall_dir: directory to install to\n\ninstall_mode (since 0.47.0): the file mode and optionally the\nowner/uid and group/gid\n\noutput: list of output files\n\nenv (since 0.57.0): environment variables to set, such as\n{'NAME1': 'value1', 'NAME2': 'value2'} or ['NAME1=value1', 'NAME2=value2'],\nor an environment() object which allows more\nsophisticated environment juggling.\n\n\n\n@INPUT@: the full path to the input passed to input. If more than\none input is specified, all of them will be substituted as separate\narguments only if the command uses '@INPUT@' as a\nstandalone-argument. For instance, this would not work: command : ['cp', './@INPUT@'], but this would: command : ['cp', '@INPUT@'].\n\n@OUTPUT@: the full path to the output passed to output. If more\nthan one outputs are specified, the behavior is the same as\n@INPUT@.\n\n@INPUT0@ @INPUT1@ ...: the full path to the input with the specified array index in input\n\n\n@OUTPUT0@ @OUTPUT1@ ...: the full path to the output with the specified array index in output\n\n\n@OUTDIR@: the full path to the directory where the output(s) must be written\n\n@DEPFILE@: the full path to the dependency file passed to depfile\n\n\n@PLAINNAME@: the input filename, without a path\n\n@BASENAME@: the input filename, with extension removed\n\n@PRIVATE_DIR@ (since 0.50.1): path to a directory where the custom target must store all its intermediate files.\n\n\n\ncompile_args: compile arguments to use.\n\ndependencies: other dependencies needed to use this dependency.\n\ninclude_directories: the directories to add to header search path,\nmust be include_directories objects or (since 0.50.0) plain strings\n\nlink_args: link arguments to use.\n\nlink_with: libraries to link against.\n\nlink_whole (since 0.46.0): libraries to link fully, same as executable.\n\nsources: sources to add to targets (or generated header files\nthat should be built before sources including them are built)\n\nversion: the version of this dependency, such as 1.2.3\n\n\nvariables (since 0.54.0): a dictionary of arbitrary strings, this is meant to be used\nin subprojects where special variables would be provided via cmake or\npkg-config. since 0.56.0 it can also be a list of 'key=value' strings.\n\n\n\nif the same name was used in a meson.override_dependency prior to\nthe call to dependency, the overriding dependency will be returned\nunconditionally; that is, the overriding dependency will be used\nindependent of whether an external dependency is installed in the system.\nTypically, meson.override_dependency will have been used by a\nsubproject.\n\n\nby a fallback subproject which, if needed, will be brought into the current\nbuild specification as if subproject() had been called.\nThe subproject can be specified with the fallback argument.  Alternatively,\nif the fallback argument is absent, since 0.55.0 Meson can\nautomatically identify a subproject as a fallback if a wrap file\nprovides the\ndependency, or if a subproject has the same name as the dependency.\nIn the latter case, the subproject must use meson.override_dependency to\nspecify the replacement, or Meson will report a hard error.  See the\nWrap documentation\nfor more details.  This automatic search can be controlled using the\nallow_fallback keyword argument.\n\n\n\n\ndefault_options (since 0.37.0): an array of default option values\nthat override those set in the subproject's meson_options.txt\n(like default_options in project(), they only have\neffect when Meson is run for the first time, and command line\narguments override any default options in build files)\n\nallow_fallback (boolean argument, since 0.56.0): specifies whether Meson\nshould automatically pick a fallback subproject in case the dependency\nis not found in the system.  If true and the dependency is not found\non the system, Meson will fallback to a subproject that provides this\ndependency. If false, Meson will not fallback even if a subproject\nprovides this dependency.  By default, Meson will do so if required\nis true or  enabled; see the Wrap\ndocumentation\nfor more details.\n\nfallback (string or array argument): manually specifies a subproject\nfallback to use in case the dependency is not found in the system.\nThis is useful if the automatic search is not applicable or if you\nwant to support versions of Meson older than 0.55.0.  If the value is an\narray ['subproj_name', 'subproj_dep'], the first value is the name\nof the subproject and the second is the variable name in that\nsubproject that contains a dependency object such as the return\nvalue of declare_dependency or\ndependency(), etc. Note that this means the\nfallback dependency may be a not-found dependency, in which\ncase the value of the required: kwarg will be obeyed.\nSince 0.54.0 the value can be a single string, the subproject name;\nin this case the subproject must use\nmeson.override_dependency('dependency_name', subproj_dep)\nto specify the dependency object used in the superproject.\n\nlanguage (since 0.42.0): defines what language-specific\ndependency to find if it's available for multiple languages.\n\nmethod: defines the way the dependency is detected, the default is\nauto but can be overridden to be e.g. qmake for Qt development,\nand different dependencies support different values\nfor this (though auto will work on all of them)\n\nnative: if set to true, causes Meson to find the dependency on\nthe build machine system rather than the host system (i.e. where the\ncross compiled binary will run on), usually only needed if you build\na tool to be used during compilation.\n\nnot_found_message (since 0.50.0): an optional string that will\nbe printed as a message() if the dependency was not found.\n\nrequired: when set to false, Meson will proceed with the build\neven if the dependency is not found. (since 0.47.0) The value of a\nfeature option can also be passed.\n\nstatic: tells the dependency provider to try to get static\nlibraries instead of dynamic ones (note that this is not supported\nby all dependency backends)\n\nversion (since 0.37.0): specifies the required version, a string containing a\ncomparison operator followed by the version string, examples include\n>1.0.0, <=2.3.5 or 3.1.4 for exact matching.\nYou can also specify multiple restrictions by passing a list to this\nkeyword argument, such as: ['>=3.14.0', '<=4.1.0'].\nThese requirements are never met if the version is unknown.\n\ninclude_type (since 0.52.0): an enum flag, marking how the dependency\nflags should be converted. Supported values are 'preserve', 'system' and\n'non-system'. System dependencies may be handled differently on some\nplatforms, for instance, using -isystem instead of -I, where possible.\nIf include_type is set to 'preserve', no additional conversion will be\nperformed. The default value is 'preserve'.\nother\nlibrary-specific\nkeywords may also be accepted (e.g. modules specifies submodules to use for\ndependencies such as Qt5 or Boost. components allows the user to manually\nadd CMake COMPONENTS for the find_package lookup)\n\ndisabler (since 0.49.0): if true and the dependency couldn't be found,\nreturns a disabler object instead of a not-found dependency.\n\n\nStrings relative to the current source directory\n\nfiles() objects defined in any preceding build file\nThe return value of configure-time generators such as configure_file()\n\nThe return value of build-time generators such as\ncustom_target() or\ngenerator.process()\n\n\n\n\n<languagename>_pch: precompiled header file to use for the given language\n\n<languagename>_args: compiler flags to use for the given language;\neg: cpp_args for C++\n\nbuild_by_default (since 0.38.0): causes, when set to true, to\nhave this target be built by default. This means it will be built when\nmeson compile is called without any arguments. The default value is\ntrue for all built target types.\n\nbuild_rpath: a string to add to target's rpath definition in the\nbuild dir, but which will be removed on install\n\ndependencies: one or more objects created with\ndependency or find_library\n(for external deps) or declare_dependency\n(for deps built by the project)\n\nextra_files: not used for the build itself but are shown as\nsource files in IDEs that group files by targets (such as Visual\nStudio)\n\ngui_app: when set to true flags this target as a GUI application\non platforms where this makes a differerence, deprecated since\n0.56.0, use win_subsystem instead.\n\nlink_args: flags to use during linking. You can use UNIX-style\nflags here for all platforms.\n\nlink_depends: strings, files, or custom targets the link step\ndepends on such as a symbol visibility map. The purpose is to\nautomatically trigger a re-link (but not a re-compile) of the target\nwhen this file changes.\n\nlink_language (since 0.51.0) (broken until 0.55.0): makes the linker for this\ntarget be for the specified language. It is generally unnecessary to set\nthis, as meson will detect the right linker to use in most cases. There are\nonly two cases where this is needed. One, your main function in an\nexecutable is not in the language meson picked, or second you want to force\na library to use only one ABI.\n\nlink_whole (since 0.40.0): links all contents of the given static libraries\nwhether they are used by not, equivalent to the -Wl,--whole-archive argument flag of GCC.\n(since 0.41.0) If passed a list that list will be flattened.\n(since 0.51.0) This argument also accepts outputs produced by\ncustom targets. The user must ensure that the output is a library in\nthe correct format.\n\nlink_with: one or more shared or static libraries (built by this\nproject) that this target should be linked with. (since 0.41.0) If passed a\nlist this list will be flattened. (since 0.51.0) The arguments can also be custom targets.\nIn this case Meson will assume that merely adding the output file in the linker command\nline is sufficient to make linking work. If this is not sufficient,\nthen the build system writer must write all other steps manually.\n\nexport_dynamic (since 0.45.0): when set to true causes the target's symbols to be\ndynamically exported, allowing modules built using the\nshared_module function to refer to functions,\nvariables and other symbols defined in the executable itself. Implies\nthe implib argument.\n\nimplib (since 0.42.0): when set to true, an import library is generated for the\nexecutable (the name of the import library is based on exe_name).\nAlternatively, when set to a string, that gives the base name for\nthe import library.  The import library is used when the returned\nbuild target object appears in link_with: elsewhere.  Only has any\neffect on platforms where that is meaningful (e.g. Windows). Implies\nthe export_dynamic argument.\n\nimplicit_include_directories (since 0.42.0): a boolean telling whether Meson\nadds the current source and build directories to the include path,\ndefaults to true.\n\ninclude_directories: one or more objects created with the\ninclude_directories function, or (since 0.50.0) strings, which\nwill be transparently expanded to include directory objects\n\ninstall: when set to true, this executable should be installed, defaults to false\n\n\ninstall_dir: override install directory for this file. The value is\nrelative to the prefix specified. F.ex, if you want to install\nplugins into a subdir, you'd use something like this: install_dir : get_option('libdir') / 'projectname-1.0'.\n\ninstall_mode (since 0.47.0): specify the file mode in symbolic format\nand optionally the owner/uid and group/gid for the installed files.\n\ninstall_rpath: a string to set the target's rpath to after install\n(but not before that). On Windows, this argument has no effect.\n\nobjects: list of prebuilt object files (usually for third party\nproducts you don't have source to) that should be linked in this\ntarget, never use this for object files that you build yourself.\n\nname_suffix: the string that will be used as the extension for the\ntarget by overriding the default. By default on Windows this is\nexe and on other platforms it is omitted. Set this to [], or omit\nthe keyword argument for the default behaviour.\n\noverride_options (since 0.40.0): takes an array of strings in the same format as\nproject's default_options overriding the values of these options\nfor this target only.\n\ngnu_symbol_visibility (since 0.48.0): specifies how symbols should be exported, see\ne.g the GCC Wiki for more\ninformation. This value can either be an empty string or one of\ndefault, internal, hidden, protected or inlineshidden, which\nis the same as hidden but also includes things like C++ implicit\nconstructors as specified in the GCC manual. Ignored on compilers that\ndo not support GNU visibility arguments.\n\nd_import_dirs: list of directories to look in for string imports used\nin the D programming language\n\nd_unittest: when set to true, the D modules are compiled in debug mode\n\nd_module_versions: list of module version identifiers set when compiling D sources\n\nd_debug: list of module debug identifiers set when compiling D sources\n\npie (since 0.49.0): build a position-independent executable\n\nnative: is a boolean controlling whether the target is compiled for the\nbuild or host machines. Defaults to false, building for the host machine.\n\nwin_subsystem (since 0.56.0) specifies the subsystem type to use\non the Windows platform. Typical values include console for text\nmode programs and windows for gui apps. The value can also contain\nversion specification such as windows,6.0. See MSDN\ndocumentation\nfor the full list. The default value is console.\n\n\nIf you use the return value of configure_file(), the\ncurrent subdir inside the build tree is used instead\n\n\n\nrequired By default, required is set to true and Meson will\nabort if no program can be found. If required is set to false,\nMeson continue even if none of the programs can be found. You can\nthen use the .found() method on the returned object to check\nwhether it was found or not. (since 0.47.0) The value of a\nfeature option can also be passed to the\nrequired keyword argument.\n\n\nnative (since 0.43.0): defines how this executable should be searched. By default\nit is set to false, which causes Meson to first look for the\nexecutable in the cross file (when cross building) and if it is not\ndefined there, then from the system. If set to true, the cross\nfile is ignored and the program is only searched from the system.\n\n\ndisabler (since 0.49.0): if true and the program couldn't be found, return a\ndisabler object instead of a not-found object.\n\n\nversion (since 0.52.0): specifies the required version, see\ndependency() for argument format. The version of the program\nis determined by running program_name --version command. If stdout is empty\nit fallbacks to stderr. If the output contains more text than simply a version\nnumber, only the first occurrence of numbers separated by dots is kept.\nIf the output is more complicated than that, the version checking will have to\nbe done manually using run_command().\n\n\ndirs (since 0.53.0): extra list of absolute paths where to look for program\nnames.\n\n\n\n\narguments: a list of template strings that will be the command line\narguments passed to the executable\n\ndepends (since 0.51.0): is an array of build targets that must be built before this\ngenerator can be run. This is used if you have a generator that calls\na second executable that is built in this project.\n\ndepfile: is a template string pointing to a dependency file that a\ngenerator can write listing all the additional files this target\ndepends on, for example a C compiler would list all the header files\nit included, and a change in any one of these files triggers a\nrecompilation\n\noutput: a template string (or list of template strings) defining\nhow an output file name is (or multiple output names are) generated\nfrom a single source file name\n\ncapture (since 0.43.0): when this argument is set to true, Meson\ncaptures stdout of the executable and writes it to the target file\nspecified as output.\n\n\n\n@PLAINNAME@: the complete input file name, e.g: foo.c becomes foo.c (unchanged)\n\n@BASENAME@: the base of the input filename, e.g.: foo.c.y becomes foo.c (extension is removed)\n\n\n\n@OUTPUT@: the full path to the output file\n\n@INPUT@: the full path to the input file\n\n@DEPFILE@: the full path to the depfile\n\n@SOURCE_DIR@: the full path to the root of the source tree\n\n@CURRENT_SOURCE_DIR@: this is the directory where the currently processed meson.build is located in\n\n@BUILD_DIR@: the full path to the root of the build dir where the output will be placed\n\n\n\ninstall_dir: the absolute or relative path to the installation\ndirectory. If this is a relative path, it is assumed to be relative\nto the prefix.\nIf omitted, the directory defaults to {datadir}/{projectname} (since 0.45.0).\n\n\ninstall_mode: specify the file mode in symbolic format and\noptionally the owner/uid and group/gid for the installed files. For\nexample:\ninstall_mode: 'rw-r--r--' for just the file mode\ninstall_mode: ['rw-r--r--', 'nobody', 'nobody'] for the file mode and the user/group\ninstall_mode: ['rw-r-----', 0, 0] for the file mode and uid/gid\n\n\n\n\nrename (since 0.46.0): if specified renames each source file into corresponding\nfile from rename list. Nested paths are allowed and they are\njoined with install_dir. Length of rename list must be equal to\nthe number of sources.\n\n\n\ninstall_mode (since 0.47.0): can be used to specify the file mode in symbolic\nformat and optionally the owner/uid and group/gid for the installed files.\nAn example value could be ['rwxr-sr-x', 'root', 'root'].\n\n\n\ninstall_mode (since 0.47.0): can be used to specify the file mode in symbolic\nformat and optionally the owner/uid and group/gid for the installed files.\nAn example value could be ['rwxr-sr-x', 'root', 'root'].\n\n\n\nexclude_files: a list of file names that should not be installed.\nNames are interpreted as paths relative to the subdir_name location.\n\nexclude_directories: a list of directory names that should not be installed.\nNames are interpreted as paths relative to the subdir_name location.\n\ninstall_dir: the location to place the installed subdirectory.\n\ninstall_mode (since 0.47.0): the file mode in symbolic format and optionally\nthe owner/uid and group/gid for the installed files.\n\nstrip_directory (since 0.45.0): install directory contents. strip_directory=false by default.\nIf strip_directory=true only the last component of the source path is used.\n\n\n\nname_prefix: the string that will be used as the prefix for the\ntarget output filename by overriding the default (only used for\nlibraries). By default this is lib on all platforms and compilers,\nexcept for MSVC shared libraries where it is omitted to follow\nconvention, and Cygwin shared libraries where it is cyg.\n\nname_suffix: the string that will be used as the suffix for the\ntarget output filename by overriding the default (see also:\nexecutable()). By default, for shared libraries this\nis dylib on macOS, dll on Windows, and so everywhere else.\nFor static libraries, it is a everywhere. By convention MSVC\nstatic libraries use the lib suffix, but we use a to avoid a\npotential name clash with shared libraries which also generate\nimport libraries with a lib suffix.\n\nrust_crate_type: specifies the crate type for Rust\nlibraries. Defaults to dylib for shared libraries and rlib for\nstatic libraries.\n\n\nan integer, boolean or string\n\nsince 0.57.0 an external program or a dependency\na list of those.\n\n\n\nsection: title to group a set of key/value pairs.\n\nbool_yn: if set to true, all boolean values will be replaced by green YES\nor red NO.\n\nlist_sep (since 0.54.0): string used to separate list values (e.g. ', ').\n\n\n\ndefault_options: takes an array of strings. The strings are in the\nform key=value and have the same format as options to\nmeson configure. For example to set the default project type you would\nset this: default_options : ['buildtype=debugoptimized']. Note\nthat these settings are only used when running Meson for the first\ntime. Global options such as buildtype can only be specified in\nthe master project, settings in subprojects are ignored. Project\nspecific options are used normally even in subprojects.\n\n\nlicense: takes a string or array of strings describing the license(s) the\ncode is under. To avoid ambiguity it is recommended to use a standardized\nlicense identifier from the SPDX license list.\nUsually this would be something like license : 'GPL-2.0-or-later', but if\nthe code has multiple licenses you can specify them as an array like this:\nlicense : ['proprietary', 'GPL-3.0-only']. Note that the text is informal\nand is only written to the dependency manifest. Meson does not do any license\nvalidation, you are responsible for verifying that you abide by all licensing\nterms. You can access the value in your Meson build files with\nmeson.project_license().\n\n\nmeson_version: takes a string describing which Meson version the\nproject requires. Usually something like >=0.28.0.\n\n\nsubproject_dir: specifies the top level directory name that holds\nMeson subprojects. This is only meant as a compatibility option\nfor existing code bases that house their embedded source code in a\ncustom directory. All new projects should not set this but instead\nuse the default value. It should be noted that this keyword\nargument is ignored inside subprojects. There can be only one\nsubproject dir and it is set in the top level Meson file.\n\n\nversion: which is a free form string describing the version of\nthis project. You can access the value in your Meson build files\nwith meson.project_version(). Since 0.57.0 this can also be a\nFile object pointing to a file that contains exactly one line of\ntext.\n\n\n\n\ncheck (since 0.47.0): takes a boolean. If true, the exit status code of the command will\nbe checked, and the configuration will fail if it is non-zero. The default is\nfalse.\n\nenv (since 0.50.0): environment variables to set, such as ['NAME1=value1', 'NAME2=value2'], or an environment()\nobject which allows more sophisticated\nenvironment juggling. (since 0.52.0) A dictionary is also accepted.\n\n\n\ncommand is a list containing the command to run and the arguments\nto pass to it. Each list item may be a string or a target. For\ninstance, passing the return value of executable()\nas the first item will run that executable, or passing a string as\nthe first item will find that command in PATH and run it.\n\ndepends is a list of targets that this target depends on but which\nare not listed in the command array (because, for example, the\nscript does file globbing internally)\n\n\n\nsoversion: a string specifying the soversion of this shared\nlibrary, such as 0. On Linux and Windows this is used to set the\nsoversion (or equivalent) in the filename. For example, if\nsoversion is 4, a Windows DLL will be called foo-4.dll and one\nof the aliases of the Linux shared library would be\nlibfoo.so.4. If this is not specified, the first part of version\nis used instead (see below). For example, if version is 3.6.0 and\nsoversion is not defined, it is set to 3.\n\nversion: a string specifying the version of this shared library,\nsuch as 1.1.0. On Linux and OS X, this is used to set the shared\nlibrary version in the filename, such as libfoo.so.1.1.0 and\nlibfoo.1.1.0.dylib. If this is not specified, soversion is used\ninstead (see above).\n\ndarwin_versions (since 0.48.0): an integer, string, or a list of\nversions to use for setting dylib compatibility version and\ncurrent version on macOS. If a list is specified, it must be\neither zero, one, or two elements. If only one element is specified\nor if it's not a list, the specified value will be used for setting\nboth compatibility version and current version. If unspecified, the\nsoversion will be used as per the aforementioned rules.\n\nvs_module_defs: a string, a File object, or Custom Target for a\nMicrosoft module definition file for controlling symbol exports,\netc., on platforms where that is possible (e.g. Windows).\n\n\n\nvs_module_defs (since 0.52.0): a string, a File object, or\nCustom Target for a Microsoft module definition file for controlling\nsymbol exports, etc., on platforms where that is possible\n(e.g. Windows).\n\n\n\npic (since 0.36.0): builds the library as positional\nindependent code (so it can be linked into a shared library). This\noption has no effect on Windows and OS X since it doesn't make\nsense on Windows and PIC cannot be disabled on OS X.\n\n\nprelink since0.57.0: if true the object files in the target\nwill be prelinked, meaning that it will contain only one prelinked\nobject file rather than the individual object files.\n\n\n\n\nif_found: takes one or several dependency objects and will only\nrecurse in the subdir if they all return true when queried with\n.found()\n\n\n\n\ndefault_options (since 0.37.0): an array of default option values\nthat override those set in the subproject's meson_options.txt\n(like default_options in project, they only have effect when\nMeson is run for the first time, and command line arguments override\nany default options in build files). (since 0.54.0): default_library\nbuilt-in option can also be overridden.\n\nversion: works just like the same as in dependency.\nIt specifies what version the subproject should be, as an example >=1.0.1\n\n\nrequired (since 0.48.0): By default, required is true and\nMeson will abort if the subproject could not be setup. You can set\nthis to false and then use the .found() method on the returned\nobject. You may also pass the value of a\nfeature option, same as\ndependency().\n\n\n\nargs: arguments to pass to the executable\n\n\nenv: environment variables to set, such as ['NAME1=value1', 'NAME2=value2'], or an environment()\nobject which allows more sophisticated\nenvironment juggling. (since 0.52.0) A dictionary is also accepted.\n\n\nis_parallel: when false, specifies that no other test must be\nrunning at the same time as this test\n\n\nshould_fail: when true the test is considered passed if the\nexecutable returns a non-zero return value (i.e. reports an error)\n\n\nsuite: 'label' (or list of labels ['label1', 'label2'])\nattached to this test. The suite name is qualified by a (sub)project\nname resulting in (sub)project_name:label. In the case of a list\nof strings, the suite names will be (sub)project_name:label1,\n(sub)project_name:label2, etc.\n\n\ntimeout: the amount of seconds the test is allowed to run, a test\nthat exceeds its time limit is always considered failed, defaults to\n30 seconds. Since 0.57 if timeout is <= 0 the test has infinite duration,\nin previous versions of Meson the test would fail with a timeout immediately.\n\n\nworkdir: absolute path that will be used as the working directory\nfor the test\n\n\ndepends (since 0.46.0): specifies that this test depends on the specified\ntarget(s), even though it does not take any of them as a command\nline argument. This is meant for cases where test finds those\ntargets internally, e.g. plugins or globbing. Those targets are built\nbefore test is executed even if they have build_by_default : false.\n\n\nprotocol (since 0.50.0): specifies how the test results are parsed and can\nbe one of exitcode, tap, or gtest. For more information about test\nharness protocol read Unit Tests. The following values are\naccepted:\n\n\nexitcode: the executable's exit code is used by the test harness\nto record the outcome of the test).\n\ntap: Test Anything Protocol.\n\ngtest (since 0.55.0): for Google Tests.\n\nrust (since 0.56.0): for native rust tests\n\n\n\npriority (since 0.52.0):specifies the priority of a test. Tests with a\nhigher priority are started before tests with a lower priority.\nThe starting order of tests with identical priorities is\nimplementation-defined. The default priority is 0, negative numbers are\npermitted.\n\n\n\n\nexitcode: the executable's exit code is used by the test harness\nto record the outcome of the test).\n\ntap: Test Anything Protocol.\n\ngtest (since 0.55.0): for Google Tests.\n\nrust (since 0.56.0): for native rust tests\n\n\n\ncommand: string list with the command to execute, see\ncustom_target for details on how this command\nmust be specified\n\nfallback: version number to use when no revision control\ninformation is present, such as when building from a release tarball\n(defaults to meson.project_version())\n\ninput: file to modify (e.g. version.c.in) (required)\n\noutput: file to write the results to (e.g. version.c) (required)\n\nreplace_string: string in the input file to substitute with the\ncommit information (defaults to @VCS_TAG@)\n\n\n\nadd_dist_script(script_name, arg1, arg2, ...) (since 0.48.0): causes the script\ngiven as argument to run during dist operation after the\ndistribution source has been generated but before it is\narchived. Note that this runs the script file that is in the\nstaging directory, not the one in the source directory. If the\nscript file can not be found in the staging directory, it is a hard\nerror. This command can only invoked from the main project, calling\nit from a subproject is a hard error. (since 0.49.0) Accepts multiple arguments\nfor the fscript. (since 0.54.0) The MESON_SOURCE_ROOT and MESON_BUILD_ROOT\nenvironment variables are set when dist scripts are run.\n(since 0.55.0) The output of configure_file, files, and find_program\nas well as strings.\n(since 0.57.0) file objects and the output of configure_file may be\n*used as the script_name parameter.\n\n\nadd_install_script(script_name, arg1, arg2, ...): causes the script\ngiven as an argument to be run during the install step, this script\nwill have the environment variables MESON_SOURCE_ROOT,\nMESON_BUILD_ROOT, MESON_INSTALL_PREFIX,\nMESON_INSTALL_DESTDIR_PREFIX, and MESONINTROSPECT set.\nAll positional arguments are passed as parameters.\n(since 0.54.0) If meson install is called with the --quiet option, the\nenvironment variable MESON_INSTALL_QUIET will be set.\n(since 0.55.0) The output of configure_file, files, find_program,\ncustom_target, indexes of custom_target, executable, library, and\nother built targets as well as strings.\n(since 0.57.0) file objects and the output of configure_file may be\n*used as the script_name parameter.\nMeson uses the DESTDIR environment variable as set by the\ninherited environment to determine the (temporary) installation\nlocation for files. Your install script must be aware of this while\nmanipulating and installing files. The correct way to handle this is\nwith the MESON_INSTALL_DESTDIR_PREFIX variable which is always set\nand contains DESTDIR (if set) and prefix joined together. This\nis useful because both are usually absolute paths and there are\nplatform-specific edge-cases in joining two absolute paths.\nIn case it is needed, MESON_INSTALL_PREFIX is also always set and\nhas the value of the prefix option passed to Meson.\nMESONINTROSPECT contains the path to the introspect command that\ncorresponds to the meson executable that was used to configure the\nbuild. (This might be a different path than the first executable\nfound in PATH.) It can be used to query build configuration. Note\nthat the value will contain many parts, f.ex., it may be python3 /path/to/meson.py introspect. The user is responsible for splitting\nthe string to an array if needed by splitting lexically like a UNIX\nshell would. If your script uses Python, shlex.split() is the\neasiest correct way to do this.\n\n\nadd_postconf_script(script_name, arg1, arg2, ...): runs the\nexecutable given as an argument after all project files have been\ngenerated. This script will have the environment variables\nMESON_SOURCE_ROOT and MESON_BUILD_ROOT set.\n(since 0.55.0) The output of configure_file, files, and find_program\nas well as strings.\n(since 0.57.0) file objects and the output of configure_file may be\n*used as the script_name parameter.\n\n\nbackend() (since 0.37.0): returns a string representing the\ncurrent backend: ninja, vs2010, vs2015, vs2017, vs2019,\nor xcode.\n\n\nbuild_root(): returns a string with the absolute path to the build\nroot directory. (deprecated since 0.56.0): this function will return the\nbuild root of the parent project if called from a subproject, which is usually\nnot what you want. Try using current_build_dir() or project_build_root().\n\n\nsource_root(): returns a string with the absolute path to the\nsource root directory. Note: you should use the files() function\nto refer to files in the root source directory instead of\nconstructing paths manually with meson.source_root().\n(deprecated since 0.56.0): This function will return the source root of the\nparent project if called from a subproject, which is usually not what you want.\nTry using current_source_dir() or project_source_root().\n\n\nproject_build_root() (since 0.56.0): returns a string with the absolute path\nto the build root directory of the current (sub)project.\n\n\nproject_source_root() (since 0.56.0): returns a string with the absolute path\nto the source root directory of the current (sub)project.\n\n\ncurrent_build_dir(): returns a string with the absolute path to the\ncurrent build directory.\n\n\ncurrent_source_dir(): returns a string to the current source\ndirectory. Note: you do not need to use this function when\npassing files from the current source directory to a function since\nthat is the default. Also, you can use the files() function to\nrefer to files in the current or any other source directory instead\nof constructing paths manually with meson.current_source_dir().\n\n\nget_compiler(language): returns an object describing a\ncompiler, takes one positional argument which is\nthe language to use. It also accepts one keyword argument, native\nwhich when set to true makes Meson return the compiler for the build\nmachine (the \"native\" compiler) and when false it returns the host\ncompiler (the \"cross\" compiler). If native is omitted, Meson\nreturns the \"cross\" compiler if we're currently cross-compiling and\nthe \"native\" compiler if we're not.\n\n\nget_cross_property(propname, fallback_value):\nConsider get_external_property() instead. Returns the given\nproperty from a cross file, the optional fallback_value is returned\nif not cross compiling or the given property is not found.\n\n\nget_external_property(propname, fallback_value, native: true/false)\n(since 0.54.0): returns the given property from a native or cross file.\nThe optional fallback_value is returned if the given property is not found.\nThe optional native: true forces retrieving a variable from the\nnative file, even when cross-compiling.\nIf native: false or not specified, variable is retrieved from the\ncross-file if cross-compiling, and from the native-file when not cross-compiling.\n\n\ncan_run_host_binaries() (since 0.55.0): returns true if the build machine can run\nbinaries compiled for the host. This returns true unless you are\ncross compiling, need a helper to run host binaries, and don't have one.\nFor example when cross compiling from Linux to Windows, one can use wine\nas the helper.\n\n\nhas_exe_wrapper(): (since 0.55.0) (deprecated). Use can_run_host_binaries instead.\n\n\ninstall_dependency_manifest(output_name): installs a manifest file\ncontaining a list of all subprojects, their versions and license\nfiles to the file name given as the argument.\n\n\nis_cross_build(): returns true if the current build is a cross\nbuild and false otherwise.\n\n\nis_subproject(): returns true if the current project is being\nbuilt as a subproject of some other project and false otherwise.\n\n\nis_unity(): returns true when doing a unity\nbuild (multiple sources are combined before\ncompilation to reduce build time) and false otherwise.\n\n\noverride_find_program(progname, program) (since 0.46.0):\nspecifies that whenever find_program is used to find a program\nnamed progname, Meson should not look it up on the system but\ninstead return program, which may either be the result of\nfind_program, configure_file or executable. (since 0.55.0) If a version\ncheck is passed to find_program for a program that has been overridden with\nan executable, the current project version is used.\nIf program is an executable, it cannot be used during configure.\n\n\noverride_dependency(name, dep_object) (since 0.54.0):\nspecifies that whenever dependency(name, ...) is used, Meson should not\nlook it up on the system but instead return dep_object, which may either be\nthe result of dependency() or declare_dependency(). It takes optional\nnative keyword arguments. Doing this in a subproject allows the parent\nproject to retrieve the dependency without having to know the dependency\nvariable name: dependency(name, fallback : subproject_name).\n\n\nproject_version(): returns the version string specified in\nproject function call.\n\n\nproject_license(): returns the array of licenses specified in\nproject function call.\n\n\nproject_name(): returns the project name specified in the project\nfunction call.\n\n\nversion(): return a string with the version of Meson.\n\n\n\n\ncpu_family(): returns the CPU family name. This\ntable contains all known CPU\nfamilies. These are guaranteed to continue working.\n\n\ncpu(): returns a more specific CPU name, such as i686, amd64,\netc.\n\n\nsystem(): returns the operating system name.  This\ntable Lists all of\nthe currently known Operating System names, these are guaranteed to\ncontinue working.\n\n\nendian(): returns big on big-endian systems and little on\nlittle-endian systems.\n\n\n\n\ncontains(string): returns true if string contains the string\nspecified as the argument.\n\n\nendswith(string): returns true if string ends with the string\nspecified as the argument.\n\n\nformat(): formats text, see the Syntax\nmanual for usage info.\n\n\njoin(list_of_strings): the opposite of split, for example\n'.'.join(['a', 'b', 'c'] yields 'a.b.c'.\n\n\nsplit(split_character): splits the string at the specified\ncharacter (or whitespace if not set) and returns the parts in an\narray.\n\n\nstartswith(string): returns true if string starts with the string\nspecified as the argument\n\n\nsubstring(start,end) (since 0.56.0): returns a substring specified from start to end.\nBoth start and end arguments are optional, so, for example, 'foobar'.substring() will return 'foobar'.\n\n\nstrip(): removes whitespace at the beginning and end of the string.\n(since 0.43.0) Optionally can take one positional string argument,\nand all characters in that string will be stripped.\n\n\nto_int(): returns the string converted to an integer (error if string\nis not a number).\n\n\nto_lower(): creates a lower case version of the string.\n\n\nto_upper(): creates an upper case version of the string.\n\n\nunderscorify(): creates a string where every non-alphabetical\nnon-number character is replaced with _.\n\n\nversion_compare(comparison_string): does semantic version\ncomparison, if x = '1.2.3' then x.version_compare('>1.0.0')\nreturns true.\n\n\n\n\nis_even(): returns true if the number is even\n\nis_odd(): returns true if the number is odd\n\nto_string(): returns the value of the number as a string.\n\n\n\nto_int(): returns either 1 or 0.\n\n\nto_string(): returns the string 'true' if the boolean is true or\n'false' otherwise. You can also pass it two strings as positional\narguments to specify what to return for true/false. For instance,\nbool.to_string('yes', 'no') will return yes if the boolean is\ntrue and no if it is false.\n\n\n\n\ncontains(item): returns true if the array contains the object\ngiven as argument, false otherwise\n\n\nget(index, fallback): returns the object at the given index,\nnegative indices count from the back of the array, indexing out of\nbounds returns the fallback value (since 0.38.0) or, if it is\nnot specified, causes a fatal error\n\n\nlength(): the size of the array\n\n\n\n\nhas_key(key): returns true if the dictionary contains the key\ngiven as argument, false otherwise\n\n\nget(key, fallback): returns the value for the key given as first\nargument if it is present in the dictionary, or the optional\nfallback value given as the second argument. If a single argument\nwas given and the key was not found, causes a fatal error\n\n\nkeys(): returns an array of keys in the dictionary\n\n\n\n\nalignment(typename): returns the alignment of the type specified in\nthe positional argument, you can specify external dependencies to\nuse with dependencies keyword argument.\n\n\ncmd_array(): returns an array containing the command arguments for\nthe current compiler.\n\n\ncompiles(code): returns true if the code fragment given in the\npositional argument compiles, you can specify external dependencies\nto use with dependencies keyword argument, code can be either a\nstring containing source code or a file object pointing to the\nsource code.\n\n\ncompute_int(expr, ...'): computes the value of the given expression\n(as an example 1 + 2). When cross compiling this is evaluated with\nan iterative algorithm, you can specify keyword arguments low\n(defaults to -1024), high (defaults to 1024) and guess to\nspecify max and min values for the search and the value to try\nfirst.\n\n\nfind_library(lib_name, ...): tries to find the library specified in\nthe positional argument. The result\nobject can be used just like the return\nvalue of dependency. If the keyword argument required is false,\nMeson will proceed even if the library is not found. By default the\nlibrary is searched for in the system library directory\n(e.g. /usr/lib). This can be overridden with the dirs keyword\nargument, which can be either a string or a list of strings.\n(since 0.47.0) The value of a feature\noption can also be passed to the required keyword argument.\n(since 0.49.0) If the keyword argument disabler is true and the\ndependency couldn't be found, return a disabler object\ninstead of a not-found dependency. (since 0.50.0) The has_headers keyword\nargument can be a list of header files that must be found as well, using\nhas_header() method. All keyword arguments prefixed with header_ will be\npassed down to has_header() method with the prefix removed. (since 0.51.0)\nThe static keyword (boolean) can be set to true to limit the search to\nstatic libraries and false for dynamic/shared.\n\n\nfirst_supported_argument(list_of_strings): given a list of\nstrings, returns the first argument that passes the has_argument\ntest or an empty array if none pass.\n\n\nfirst_supported_link_argument(list_of_strings) (since 0.46.0):\ngiven a list of strings, returns the first argument that passes the\nhas_link_argument test or an empty array if none pass.\n\n\nget_define(definename): returns the given preprocessor symbol's\nvalue as a string or empty string if it is not defined.\n(since 0.47.0) This method will concatenate string literals as\nthe compiler would. E.g. \"a\" \"b\" will become \"ab\".\n\n\nget_id(): returns a string identifying the compiler. For example,\ngcc, msvc, and more.\n\n\nget_argument_syntax() (since 0.49.0): returns a string identifying the type\nof arguments the compiler takes. Can be one of gcc, msvc, or an undefined\nstring value. This method is useful for identifying compilers that are not\ngcc or msvc, but use the same argument syntax as one of those two compilers\nsuch as clang or icc, especially when they use different syntax on different\noperating systems.\n\n\nget_linker_id() (since 0.53.0): returns a string identifying the linker.\nFor example, ld.bfd, link, and more.\n\n\nget_supported_arguments(list_of_string) (since 0.43.0): returns\nan array containing only the arguments supported by the compiler,\nas if has_argument were called on them individually.\n\n\nget_supported_link_arguments(list_of_string) (since 0.46.0): returns\nan array containing only the arguments supported by the linker,\nas if has_link_argument were called on them individually.\n\n\nhas_argument(argument_name): returns true if the compiler accepts\nthe specified command line argument, that is, can compile code\nwithout erroring out or printing a warning about an unknown flag.\n\n\nhas_link_argument(argument_name) (since 0.46.0): returns true if\nthe linker accepts the specified command line argument, that is, can\ncompile and link code without erroring out or printing a warning\nabout an unknown flag. Link arguments will be passed to the\ncompiler, so should usually have the -Wl, prefix. On VisualStudio\na /link argument will be prepended.\n\n\nhas_function(funcname): returns true if the given function is\nprovided by the standard library or a library passed in with the\nargs keyword, you can specify external dependencies to use with\ndependencies keyword argument.\n\n\ncheck_header(header_name) (since 0.47.0): returns true if the\nspecified header is usable with the specified prefix,\ndependencies, and arguments. You can specify external dependencies\nto use with dependencies keyword argument and extra code to put\nabove the header test with the prefix keyword. In order to look\nfor headers in a specific directory you can use args : '-I/extra/include/dir, but this should only be used in exceptional\ncases for includes that can't be detected via pkg-config and passed\nvia dependencies. (since 0.50.0) The required keyword argument\ncan be used to abort if the header cannot be found.\n\n\nhas_header(header_name): returns true if the specified header\nexists, and is faster than check_header() since it only does a\npre-processor check. You can specify external dependencies to use\nwith dependencies keyword argument and extra code to put above the\nheader test with the prefix keyword. In order to look for headers\nin a specific directory you can use args : '-I/extra/include/dir,\nbut this should only be used in exceptional cases for includes that\ncan't be detected via pkg-config and passed via dependencies.\n(since 0.50.0) The required keyword argument can be used to\nabort if the header cannot be found.\n\n\nhas_header_symbol(headername, symbolname): detects\nwhether a particular symbol (function, variable, #define, type\ndefinition, etc) is declared in the specified header, you can\nspecify external dependencies to use with dependencies keyword\nargument. (since 0.50.0) The required keyword argument can be\nused to abort if the symbol cannot be found.\n\n\nhas_member(typename, membername): takes two arguments, type name\nand member name and returns true if the type has the specified\nmember, you can specify external dependencies to use with\ndependencies keyword argument.\n\n\nhas_members(typename, membername1, membername2, ...): takes at\nleast two arguments, type name and one or more member names, returns\ntrue if the type has all the specified members, you can specify\nexternal dependencies to use with dependencies keyword argument.\n\n\nhas_multi_arguments(arg1, arg2, arg3, ...) (since 0.37.0): the same as\nhas_argument but takes multiple arguments and uses them all in a\nsingle compiler invocation.\n\n\nhas_multi_link_arguments(arg1, arg2, arg3, ...) (since 0.46.0):\nthe same as has_link_argument but takes multiple arguments and\nuses them all in a single compiler invocation.\n\n\nhas_type(typename): returns true if the specified token is a type,\nyou can specify external dependencies to use with dependencies\nkeyword argument.\n\n\nlinks(code): returns true if the code fragment given in the\npositional argument compiles and links, you can specify external\ndependencies to use with dependencies keyword argument, code can\nbe either a string containing source code or a file object\npointing to the source code.\n\n\nrun(code): attempts to compile and execute the given code fragment,\nreturns a run result object, you can specify external dependencies\nto use with dependencies keyword argument, code can be either a\nstring containing source code or a file object pointing to the\nsource code.\n\n\nsymbols_have_underscore_prefix() (since 0.37.0): returns true\nif the C symbol mangling is one underscore (_) prefixed to the symbol.\n\n\nsizeof(typename, ...): returns the size of the given type\n(e.g. 'int') or -1 if the type is unknown, to add includes set\nthem in the prefix keyword argument, you can specify external\ndependencies to use with dependencies keyword argument.\n\n\nversion(): returns the compiler's version number as a string.\n\n\nhas_function_attribute(name) (since 0.48.0): returns true if the\ncompiler supports the GNU style (__attribute__(...)) name. This is\npreferable to manual compile checks as it may be optimized for compilers that\ndo not support such attributes.\nThis table lists all of the\nsupported attributes.\n\n\nget_supported_function_attributes(list_of_names) (since 0.48.0):\nreturns an array containing any names that are supported GCC style\nattributes. Equivalent to has_function_attribute was called on each of them\nindividually.\n\n\n\n\nargs: used to pass a list of compiler arguments that are\nrequired to find the header or symbol. For example, you might need\nto pass the include path -Isome/path/to/header if a header is not\nin the default include path. (since 0.38.0) you should use the\ninclude_directories keyword described below. You may also want to\npass a library name -lfoo for has_function to check for a function.\nSupported by all methods except get_id, version, and find_library.\n\n\ninclude_directories (since 0.38.0): specifies extra directories for\nheader searches.\n\n\nname: the name to use for printing a message about the compiler\ncheck. Supported by the methods compiles(), links(), and\nrun(). If this keyword argument is not passed to those methods, no\nmessage will be printed about the check.\n\n\nno_builtin_args: when set to true, the compiler arguments controlled\nby built-in configuration options are not added.\n\n\nprefix: adds #includes and other things that are\nrequired for the symbol to be declared. System definitions should be\npassed via compiler args (eg: _GNU_SOURCE is often required for\nsome symbols to be exposed on Linux, and it should be passed via\nargs keyword argument, see below). Supported by the methods\nsizeof, has_type, has_function, has_member, has_members,\ncheck_header, has_header, has_header_symbol, get_define\n\n\n\n\nextract_all_objects(): is same as extract_objects but returns all\nobject files generated by this target. (since 0.46.0) keyword argument\nrecursive must be set to true to also return objects passed to\nthe object argument of this target. By default only objects built\nfor this target are returned to maintain backward compatibility with\nprevious versions.  The default will eventually be changed to true\nin a future version.\n\n\nextract_objects(source1, source2, ...): takes as its arguments\na number of source files as string or\nfiles() and returns an opaque value representing the\nobject files generated for those source files. This is typically used\nto take single object files and link them to unit tests or to compile\nsome source files with custom flags. To use the object file(s)\nin another build target, use the objects: keyword argument.\n\n\nfull_path(): returns a full path pointing to the result target file.\nNOTE: In most cases using the object itself will do the same job as\nthis and will also allow Meson to setup inter-target dependencies\ncorrectly. Please file a bug if that doesn't work for you.\n\n\nprivate_dir_include(): returns a opaque value that works like\ninclude_directories but points to the private directory of this\ntarget, usually only needed if an another target needs to access\nsome generated internal headers of this target\n\n\nname() (since 0.54.0): returns the target name.\n\n\n\n\nget(varname, default_value): returns the value of varname, if the\nvalue has not been set returns default_value if it is defined\n(since 0.38.0) and errors out if not\n\n\nget_unquoted(varname, default_value) (since 0.44.0): returns the value\nof varname but without surrounding double quotes (\"). If the value has\nnot been set returns default_value if it is defined and errors out if not.\n\n\nhas(varname): returns true if the specified variable is set\n\n\nkeys()(since 0.57.0): returns an array of keys of\nthe configuration data object.\nYou can iterate over this array with the foreach\nstatement.\n\n\nmerge_from(other) (since 0.42.0): takes as argument a different\nconfiguration data object and copies all entries from that object to\nthe current.\n\n\nset(varname, value), sets a variable to a given value\n\n\nset10(varname, boolean_value) is the same as above but the value\nis either true or false and will be written as 1 or 0,\nrespectively\n\n\nset_quoted(varname, value) is same as set but quotes the value\nin double quotes (\")\n\n\n\n\nfull_path(): returns a full path pointing to the result target file\nNOTE: In most cases using the object itself will do the same job as\nthis and will also allow Meson to setup inter-target dependencies\ncorrectly. Please file a bug if that doesn't work for you.\n(since 0.54.0) It can be also called on indexes objects:\ncustom_targets[i].full_path().\n\n\n[index]: returns an opaque object that references this target, and\ncan be used as a source in other targets. When it is used as such it\nwill make that target depend on this custom target, but the only\nsource added will be the one that corresponds to the index of the\ncustom target's output argument.\n\n\nto_list() (since 0.54.0): returns a list of opaque objects that references\nthis target, and can be used as a source in other targets. This can be used to\niterate outputs with foreach loop.\n\n\n\n\nfound(): returns whether the dependency was found.\n\n\nname() (since 0.48.0): returns the name of the dependency that was\nsearched. Returns internal for dependencies created with\ndeclare_dependency().\n\n\nget_pkgconfig_variable(varname) (since 0.36.0): gets the\npkg-config variable specified, or, if invoked on a non pkg-config\ndependency, error out. (since 0.44.0) You can also redefine a\nvariable by passing a list to the define_variable parameter\nthat can affect the retrieved variable: ['prefix', '/']).\n(since 0.45.0) A warning is issued if the variable is not defined,\nunless a default parameter is specified.\n(Deprecated since 0.56.0) use get_variable(pkgconfig : ...) instead\n\n\nget_configtool_variable(varname) (since 0.44.0): gets the\ncommand line argument from the config tool (with -- prepended), or,\nif invoked on a non config-tool dependency, error out.\n(Deprecated since 0.56.0) use get_variable(configtool : ...) instead\n\n\ntype_name(): returns a string describing the type of the\ndependency, the most common values are internal for deps created\nwith declare_dependency() and pkgconfig for system dependencies\nobtained with Pkg-config.\n\n\nversion(): the version number as a string, for example 1.2.8.\nunknown if the dependency provider doesn't support determining the\nversion.\n\n\ninclude_type(): returns whether the value set by the include_type kwarg\n\n\nas_system(value): returns a copy of the dependency object, which has changed\nthe value of include_type to value. The value argument is optional and\ndefaults to 'preserve'.\n\n\nas_link_whole() Since 0.56.0 Only dependencies created with\ndeclare_dependency(), returns a copy of the dependency object with all\nlink_with arguments changed to link_whole. This is useful for example for\nfallback dependency from a subproject built with default_library=static.\nNote that all link_with objects must be static libraries otherwise an error\nwill be raised when trying to link_whole a shared library.\n\n\npartial_dependency(compile_args : false, link_args : false, links : false, includes : false, sources : false) (since 0.46.0): returns\na new dependency object with the same name, version, found status,\ntype name, and methods as the object that called it. This new\nobject will only inherit other attributes from its parent as\ncontrolled by keyword arguments.\nIf the parent has any dependencies, those will be applied to the new\npartial dependency with the same rules. So, given:\ndep1 = declare_dependency(compile_args : '-Werror=foo', link_with : 'libfoo')\ndep2 = declare_dependency(compile_args : '-Werror=bar', dependencies : dep1)\ndep3 = dep2.partial_dependency(compile_args : true)\n\ndep3 will add ['-Werror=foo', '-Werror=bar'] to the compiler args\nof any target it is added to, but libfoo will not be added to the\nlink_args.\nNote: A bug present until 0.50.1 results in the above behavior\nnot working correctly.\nThe following arguments will add the following attributes:\n\ncompile_args: any arguments passed to the compiler\nlink_args: any arguments passed to the linker\nlinks: anything passed via link_with or link_whole\nincludes: any include_directories\nsources: any compiled or static sources the dependency has\n\n\n\nget_variable(cmake : str, pkgconfig : str, configtool : str, internal: str, default_value : str, pkgconfig_define : [str, str])\n(since 0.51.0): a generic variable getter method, which replaces the\nget_type_variable methods. This allows one to get the variable\nfrom a dependency without knowing specifically how that dependency\nwas found. If default_value is set and the value cannot be gotten\nfrom the object then default_value is returned, if it is not set\nthen an error is raised.\n(since 0.54.0) added internal keyword.\n\n\n\ncompile_args: any arguments passed to the compiler\nlink_args: any arguments passed to the linker\nlinks: anything passed via link_with or link_whole\nincludes: any include_directories\nsources: any compiled or static sources the dependency has\n\n\n\nfound(): always returns false.\n\n\n\nfound(): returns whether the executable was found.\n\n\npath(): (since 0.55.0) (deprecated) use full_path() instead.\nReturns a string pointing to the script or executable\nNOTE: You should not need to use this method. Passing the object\nitself should work in all cases. For example: run_command(obj, arg1, arg2).\n\n\nfull_path() (since 0.55.0): which returns a string pointing to the script or\nexecutable NOTE: You should not need to use this method. Passing the object\nitself should work in all cases. For example: run_command(obj, arg1, arg2).\n\n\n\n\nappend(varname, value1, value2, ...): appends the given values to\nthe old value of the environment variable, e.g.  env.append('FOO', 'BAR', 'BAZ', separator : ';') produces BOB;BAR;BAZ if FOO had\nthe value BOB and plain BAR;BAZ if the value was not defined. If\nthe separator is not specified explicitly, the default path\nseparator for the host operating system will be used, i.e. ';' for\nWindows and ':' for UNIX/POSIX systems.\n\n\nprepend(varname, value1, value2, ...): same as append\nexcept that it writes to the beginning of the variable.\n\n\nset(varname, value1, value2): sets the environment variable\nspecified in the first argument to the values in the second argument\njoined by the separator, e.g.  env.set('FOO', 'BAR'), sets envvar\nFOO to value BAR. See append() above for how separators work.\n\n\n\n\nfound(): returns whether the library was found.\n\n\ntype_name() (since 0.48.0): returns a string describing\nthe type of the dependency, which will be library in this case.\n\n\npartial_dependency(compile_args : false, link_args : false, links : false, includes : false, source : false) (since 0.46.0): returns\na new dependency object with the same name, version, found status,\ntype name, and methods as the object that called it. This new\nobject will only inherit other attributes from its parent as\ncontrolled by keyword arguments.\n\n\n\n\nenabled(): returns whether the feature was set to 'enabled'\n\n\ndisabled(): returns whether the feature was set to 'disabled'\n\n\nauto(): returns whether the feature was set to 'auto'\n\n\n\n\nprocess(list_of_files, ...): takes a list of files, causes them to\nbe processed and returns an object containing the result which can\nthen, for example, be passed into a build target definition. The\nkeyword argument extra_args, if specified, will be used to replace\nan entry @EXTRA_ARGS@ in the argument list. The keyword argument\npreserve_path_from, if given, specifies that the output files need\nto maintain their directory structure inside the target temporary\ndirectory. The most common value for this is\nmeson.current_source_dir(). With this value when a file called\nsubdir/one.input is processed it generates a file <target private directory>/subdir/one.out as opposed to <target private directory>/one.out.\n\n\n\nfound() (since 0.48.0): returns whether the subproject was\nsuccessfully setup\n\n\nget_variable(name, fallback): fetches the specified variable from\ninside the subproject. This is useful to, for instance, get a\ndeclared dependency from the\nsubproject.\nIf the variable does not exist, the variable fallback is returned.\nIf a fallback is not specified, then attempting to read a non-existing\nvariable will cause a fatal error.\n\n\n\n\ncompiled(): if true, the compilation succeeded, if false it did not\nand the other methods return unspecified data. This is only available\nfor compiler.run() results.\n\nreturncode(): the return code of executing the compiled binary\n\nstderr(): the standard error produced when the command was run\n\nstdout(): the standard out produced when the command was run\n\n"});