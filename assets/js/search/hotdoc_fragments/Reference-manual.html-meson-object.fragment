fragment_downloaded_cb({"url":"Reference-manual.html#meson-object","fragment":"\nmeson object\nThe meson object allows you to introspect various properties of the\nsystem. This object is always mapped in the meson variable. It has\nthe following methods.\nadd_dist_script(script_name, arg1, arg2, ...) (since 0.48.0): causes the script\ngiven as argument to run during dist operation after the\ndistribution source has been generated but before it is\narchived. Note that this runs the script file that is in the\nstaging directory, not the one in the source directory. If the\nscript file can not be found in the staging directory, it is a hard\nerror. The MESON_DIST_ROOT environment variables is set when dist scripts is\nrun.\n(since 0.49.0) Accepts multiple arguments for the script.\n(since 0.54.0) The MESON_SOURCE_ROOT and MESON_BUILD_ROOT\nenvironment variables are set when dist scripts are run. They are path to the\nroot source and build directory of the main project, even when the script\ncomes from a subproject.\n(since 0.55.0) The output of configure_file, files, and find_program\nas well as strings.\n(since 0.57.0) file objects and the output of configure_file may be\nused as the script_name parameter.\n(since 0.58.0) This command can be invoked from a subproject, it was a hard\nerror in earlier versions. Subproject dist scripts will only be executed\nwhen running meson dist --include-subprojects. MESON_PROJECT_SOURCE_ROOT,\nMESON_PROJECT_BUILD_ROOT and MESON_PROJECT_DIST_ROOT environment\nvariables are set when dist scripts are run. They are identical to\nMESON_SOURCE_ROOT, MESON_BUILD_ROOT and MESON_DIST_ROOT for main project\nscripts, but for subproject scripts they have the path to the root of the\nsubproject appended, usually subprojects/<subproject-name>.\nadd_install_script(script_name, arg1, arg2, ...): causes the script\ngiven as an argument to be run during the install step, this script\nwill have the environment variables MESON_SOURCE_ROOT,\nMESON_BUILD_ROOT, MESON_INSTALL_PREFIX,\nMESON_INSTALL_DESTDIR_PREFIX, and MESONINTROSPECT set.\nAll positional arguments are passed as parameters.\nsince 0.57.0 skip_if_destdir boolean keyword argument (defaults to false)\ncan be specified. If true the script will not be run if DESTDIR is set during\ninstallation. This is useful in the case the script updates system wide\ncache that is only needed when copying files into final destination.\n(since 0.60.0) install_tag string keyword argument can be specified.\nBy default the script has no install tag which means it is not being run when\nmeson install --tags argument is specified.\n(since 0.54.0) If meson install is called with the --quiet option, the\nenvironment variable MESON_INSTALL_QUIET will be set.\n(since 0.55.0) The output of configure_file, files, find_program,\ncustom_target, indexes of custom_target, executable, library, and\nother built targets as well as strings.\n(since 0.57.0) file objects and the output of configure_file may be\n*used as the script_name parameter.\nMeson uses the DESTDIR environment variable as set by the\ninherited environment to determine the (temporary) installation\nlocation for files. Your install script must be aware of this while\nmanipulating and installing files. The correct way to handle this is\nwith the MESON_INSTALL_DESTDIR_PREFIX variable which is always set\nand contains DESTDIR (if set) and prefix joined together. This\nis useful because both are usually absolute paths and there are\nplatform-specific edge-cases in joining two absolute paths.\nIn case it is needed, MESON_INSTALL_PREFIX is also always set and\nhas the value of the prefix option passed to Meson.\nMESONINTROSPECT contains the path to the introspect command that\ncorresponds to the meson executable that was used to configure the\nbuild. (This might be a different path than the first executable\nfound in PATH.) It can be used to query build configuration. Note\nthat the value will contain many parts, f.ex., it may be python3 /path/to/meson.py introspect. The user is responsible for splitting\nthe string to an array if needed by splitting lexically like a UNIX\nshell would. If your script uses Python, shlex.split() is the\neasiest correct way to do this.\nadd_postconf_script(script_name, arg1, arg2, ...): runs the\nexecutable given as an argument after all project files have been\ngenerated. This script will have the environment variables\nMESON_SOURCE_ROOT and MESON_BUILD_ROOT set.\n(since 0.55.0) The output of configure_file, files, and find_program\nas well as strings.\n(since 0.57.0) file objects and the output of configure_file may be\n*used as the script_name parameter.\nbackend() (since 0.37.0): returns a string representing the\ncurrent backend: ninja, vs2010, vs2012, vs2013, vs2015,\nvs2017, vs2019, or xcode.\nbuild_root(): returns a string with the absolute path to the build\nroot directory. (deprecated since 0.56.0): this function will return the\nbuild root of the parent project if called from a subproject, which is usually\nnot what you want. Try using current_build_dir() or project_build_root().\nIn the rare cases where the root of the main project is needed,\nuse global_build_root() that has the same behaviour but with a more explicit\nname.\nsource_root(): returns a string with the absolute path to the\nsource root directory. Note: you should use the files() function\nto refer to files in the root source directory instead of\nconstructing paths manually with meson.source_root().\n(deprecated since 0.56.0): This function will return the source root of the\nparent project if called from a subproject, which is usually not what you want.\nTry using current_source_dir() or project_source_root().\nIn the rare cases where the root of the main project is needed,\nuse global_source_root() that has the same behaviour but with a more explicit\nname.\nproject_build_root() (since 0.56.0): returns a string with the absolute path\nto the build root directory of the current (sub)project.\nproject_source_root() (since 0.56.0): returns a string with the absolute path\nto the source root directory of the current (sub)project.\nglobal_build_root() (since 0.58.0): returns a string with the absolute path\nto the build root directory. This function will return the build root of the\nmain project if called from a subproject, which is usually not what you want.\nIt is usually preferable to use current_build_dir() or project_build_root().\nglobal_source_root() (since 0.58.0): returns a string with the absolute path\nto the source root directory. This function will return the source root of the\nmain project if called from a subproject, which is usually not what you want.\nIt is usually preferable to use current_source_dir() or project_source_root().\ncurrent_build_dir(): returns a string with the absolute path to the\ncurrent build directory.\ncurrent_source_dir(): returns a string to the current source\ndirectory. Note: you do not need to use this function when\npassing files from the current source directory to a function since\nthat is the default. Also, you can use the files() function to\nrefer to files in the current or any other source directory instead\nof constructing paths manually with meson.current_source_dir().\nget_compiler(language): returns an object describing a\ncompiler, takes one positional argument which is\nthe language to use. It also accepts one keyword argument, native\nwhich when set to true makes Meson return the compiler for the build\nmachine (the \"native\" compiler) and when false it returns the host\ncompiler (the \"cross\" compiler). If native is omitted, Meson\nreturns the \"cross\" compiler if we're currently cross-compiling and\nthe \"native\" compiler if we're not.\nget_cross_property(propname, fallback_value):\nDeprecated since 0.58.0, use get_external_property() instead.\nReturns the given property from a cross file, the optional fallback_value\nis returned if not cross compiling or the given property is not found.\nget_external_property(propname, fallback_value, native: true/false)\n(since 0.54.0): returns the given property from a native or cross file.\nThe optional fallback_value is returned if the given property is not found.\nThe optional native: true forces retrieving a variable from the\nnative file, even when cross-compiling.\nIf native: false or not specified, variable is retrieved from the\ncross-file if cross-compiling, and from the native-file when not cross-compiling.\nhas_external_property(propname, native: true/false)\n(since 0.58.0): checks whether the given property exist in a native or\ncross file. The optional native: true forces checking for the variable\nin the native file, even when cross-compiling.\nIf native: false or not specified, the variable is checked for in the\ncross-file if cross-compiling, and in the native-file when not cross-compiling.\ncan_run_host_binaries() (since 0.55.0): returns true if the build machine can run\nbinaries compiled for the host. This returns true unless you are\ncross compiling, need a helper to run host binaries, and don't have one.\nFor example when cross compiling from Linux to Windows, one can use wine\nas the helper.\nhas_exe_wrapper(): (since 0.55.0) (deprecated). Use can_run_host_binaries instead.\ninstall_dependency_manifest(output_name): installs a manifest file\ncontaining a list of all subprojects, their versions and license\nfiles to the file name given as the argument.\nis_cross_build(): returns true if the current build is a cross\nbuild and false otherwise.\nis_subproject(): returns true if the current project is being\nbuilt as a subproject of some other project and false otherwise.\nis_unity(): returns true when doing a unity\nbuild (multiple sources are combined before\ncompilation to reduce build time) and false otherwise.\noverride_find_program(progname, program) (since 0.46.0):\nspecifies that whenever find_program is used to find a program\nnamed progname, Meson should not look it up on the system but\ninstead return program, which may either be the result of\nfind_program, configure_file or executable. (since 0.55.0) If a version\ncheck is passed to find_program for a program that has been overridden with\nan executable, the current project version is used.\nIf program is an executable, it cannot be used during configure.\noverride_dependency(name, dep_object) (since 0.54.0):\nspecifies that whenever dependency(name, ...) is used, Meson should not\nlook it up on the system but instead return dep_object, which may either be\nthe result of dependency() or declare_dependency(). It takes optional\nnative keyword arguments. Doing this in a subproject allows the parent\nproject to retrieve the dependency without having to know the dependency\nvariable name: dependency(name, fallback : subproject_name).\nproject_version(): returns the version string specified in\nproject function call.\nproject_license(): returns the array of licenses specified in\nproject function call.\nproject_name(): returns the project name specified in the project\nfunction call.\nversion(): return a string with the version of Meson.\nadd_devenv(): (Since 0.58.0) add an environment() object\nto the list of environments that will be applied when using meson devenv\ncommand line. This is useful for developpers who wish to use the project without\ninstalling it, it is often needed to set for example the path to plugins\ndirectory, etc. Alternatively, a list or dictionary can be passed as first\nargument.\nAfter configuring and compiling that project, a terminal can be opened with\nthe environment set:\nSee meson devenv command documentation for a list of\nenvironment variables that are set by default by Meson.\n\n\nadd_dist_script(script_name, arg1, arg2, ...) (since 0.48.0): causes the script\ngiven as argument to run during dist operation after the\ndistribution source has been generated but before it is\narchived. Note that this runs the script file that is in the\nstaging directory, not the one in the source directory. If the\nscript file can not be found in the staging directory, it is a hard\nerror. The MESON_DIST_ROOT environment variables is set when dist scripts is\nrun.\n(since 0.49.0) Accepts multiple arguments for the script.\n(since 0.54.0) The MESON_SOURCE_ROOT and MESON_BUILD_ROOT\nenvironment variables are set when dist scripts are run. They are path to the\nroot source and build directory of the main project, even when the script\ncomes from a subproject.\n(since 0.55.0) The output of configure_file, files, and find_program\nas well as strings.\n(since 0.57.0) file objects and the output of configure_file may be\nused as the script_name parameter.\n(since 0.58.0) This command can be invoked from a subproject, it was a hard\nerror in earlier versions. Subproject dist scripts will only be executed\nwhen running meson dist --include-subprojects. MESON_PROJECT_SOURCE_ROOT,\nMESON_PROJECT_BUILD_ROOT and MESON_PROJECT_DIST_ROOT environment\nvariables are set when dist scripts are run. They are identical to\nMESON_SOURCE_ROOT, MESON_BUILD_ROOT and MESON_DIST_ROOT for main project\nscripts, but for subproject scripts they have the path to the root of the\nsubproject appended, usually subprojects/<subproject-name>.\n\n\nadd_install_script(script_name, arg1, arg2, ...): causes the script\ngiven as an argument to be run during the install step, this script\nwill have the environment variables MESON_SOURCE_ROOT,\nMESON_BUILD_ROOT, MESON_INSTALL_PREFIX,\nMESON_INSTALL_DESTDIR_PREFIX, and MESONINTROSPECT set.\nAll positional arguments are passed as parameters.\nsince 0.57.0 skip_if_destdir boolean keyword argument (defaults to false)\ncan be specified. If true the script will not be run if DESTDIR is set during\ninstallation. This is useful in the case the script updates system wide\ncache that is only needed when copying files into final destination.\n(since 0.60.0) install_tag string keyword argument can be specified.\nBy default the script has no install tag which means it is not being run when\nmeson install --tags argument is specified.\n(since 0.54.0) If meson install is called with the --quiet option, the\nenvironment variable MESON_INSTALL_QUIET will be set.\n(since 0.55.0) The output of configure_file, files, find_program,\ncustom_target, indexes of custom_target, executable, library, and\nother built targets as well as strings.\n(since 0.57.0) file objects and the output of configure_file may be\n*used as the script_name parameter.\nMeson uses the DESTDIR environment variable as set by the\ninherited environment to determine the (temporary) installation\nlocation for files. Your install script must be aware of this while\nmanipulating and installing files. The correct way to handle this is\nwith the MESON_INSTALL_DESTDIR_PREFIX variable which is always set\nand contains DESTDIR (if set) and prefix joined together. This\nis useful because both are usually absolute paths and there are\nplatform-specific edge-cases in joining two absolute paths.\nIn case it is needed, MESON_INSTALL_PREFIX is also always set and\nhas the value of the prefix option passed to Meson.\nMESONINTROSPECT contains the path to the introspect command that\ncorresponds to the meson executable that was used to configure the\nbuild. (This might be a different path than the first executable\nfound in PATH.) It can be used to query build configuration. Note\nthat the value will contain many parts, f.ex., it may be python3 /path/to/meson.py introspect. The user is responsible for splitting\nthe string to an array if needed by splitting lexically like a UNIX\nshell would. If your script uses Python, shlex.split() is the\neasiest correct way to do this.\n\n\nadd_postconf_script(script_name, arg1, arg2, ...): runs the\nexecutable given as an argument after all project files have been\ngenerated. This script will have the environment variables\nMESON_SOURCE_ROOT and MESON_BUILD_ROOT set.\n(since 0.55.0) The output of configure_file, files, and find_program\nas well as strings.\n(since 0.57.0) file objects and the output of configure_file may be\n*used as the script_name parameter.\n\n\nbackend() (since 0.37.0): returns a string representing the\ncurrent backend: ninja, vs2010, vs2012, vs2013, vs2015,\nvs2017, vs2019, or xcode.\n\n\nbuild_root(): returns a string with the absolute path to the build\nroot directory. (deprecated since 0.56.0): this function will return the\nbuild root of the parent project if called from a subproject, which is usually\nnot what you want. Try using current_build_dir() or project_build_root().\nIn the rare cases where the root of the main project is needed,\nuse global_build_root() that has the same behaviour but with a more explicit\nname.\n\n\nsource_root(): returns a string with the absolute path to the\nsource root directory. Note: you should use the files() function\nto refer to files in the root source directory instead of\nconstructing paths manually with meson.source_root().\n(deprecated since 0.56.0): This function will return the source root of the\nparent project if called from a subproject, which is usually not what you want.\nTry using current_source_dir() or project_source_root().\nIn the rare cases where the root of the main project is needed,\nuse global_source_root() that has the same behaviour but with a more explicit\nname.\n\n\nproject_build_root() (since 0.56.0): returns a string with the absolute path\nto the build root directory of the current (sub)project.\n\n\nproject_source_root() (since 0.56.0): returns a string with the absolute path\nto the source root directory of the current (sub)project.\n\n\nglobal_build_root() (since 0.58.0): returns a string with the absolute path\nto the build root directory. This function will return the build root of the\nmain project if called from a subproject, which is usually not what you want.\nIt is usually preferable to use current_build_dir() or project_build_root().\n\n\nglobal_source_root() (since 0.58.0): returns a string with the absolute path\nto the source root directory. This function will return the source root of the\nmain project if called from a subproject, which is usually not what you want.\nIt is usually preferable to use current_source_dir() or project_source_root().\n\n\ncurrent_build_dir(): returns a string with the absolute path to the\ncurrent build directory.\n\n\ncurrent_source_dir(): returns a string to the current source\ndirectory. Note: you do not need to use this function when\npassing files from the current source directory to a function since\nthat is the default. Also, you can use the files() function to\nrefer to files in the current or any other source directory instead\nof constructing paths manually with meson.current_source_dir().\n\n\nget_compiler(language): returns an object describing a\ncompiler, takes one positional argument which is\nthe language to use. It also accepts one keyword argument, native\nwhich when set to true makes Meson return the compiler for the build\nmachine (the \"native\" compiler) and when false it returns the host\ncompiler (the \"cross\" compiler). If native is omitted, Meson\nreturns the \"cross\" compiler if we're currently cross-compiling and\nthe \"native\" compiler if we're not.\n\n\nget_cross_property(propname, fallback_value):\nDeprecated since 0.58.0, use get_external_property() instead.\nReturns the given property from a cross file, the optional fallback_value\nis returned if not cross compiling or the given property is not found.\n\n\nget_external_property(propname, fallback_value, native: true/false)\n(since 0.54.0): returns the given property from a native or cross file.\nThe optional fallback_value is returned if the given property is not found.\nThe optional native: true forces retrieving a variable from the\nnative file, even when cross-compiling.\nIf native: false or not specified, variable is retrieved from the\ncross-file if cross-compiling, and from the native-file when not cross-compiling.\n\n\nhas_external_property(propname, native: true/false)\n(since 0.58.0): checks whether the given property exist in a native or\ncross file. The optional native: true forces checking for the variable\nin the native file, even when cross-compiling.\nIf native: false or not specified, the variable is checked for in the\ncross-file if cross-compiling, and in the native-file when not cross-compiling.\n\n\ncan_run_host_binaries() (since 0.55.0): returns true if the build machine can run\nbinaries compiled for the host. This returns true unless you are\ncross compiling, need a helper to run host binaries, and don't have one.\nFor example when cross compiling from Linux to Windows, one can use wine\nas the helper.\n\n\nhas_exe_wrapper(): (since 0.55.0) (deprecated). Use can_run_host_binaries instead.\n\n\ninstall_dependency_manifest(output_name): installs a manifest file\ncontaining a list of all subprojects, their versions and license\nfiles to the file name given as the argument.\n\n\nis_cross_build(): returns true if the current build is a cross\nbuild and false otherwise.\n\n\nis_subproject(): returns true if the current project is being\nbuilt as a subproject of some other project and false otherwise.\n\n\nis_unity(): returns true when doing a unity\nbuild (multiple sources are combined before\ncompilation to reduce build time) and false otherwise.\n\n\noverride_find_program(progname, program) (since 0.46.0):\nspecifies that whenever find_program is used to find a program\nnamed progname, Meson should not look it up on the system but\ninstead return program, which may either be the result of\nfind_program, configure_file or executable. (since 0.55.0) If a version\ncheck is passed to find_program for a program that has been overridden with\nan executable, the current project version is used.\nIf program is an executable, it cannot be used during configure.\n\n\noverride_dependency(name, dep_object) (since 0.54.0):\nspecifies that whenever dependency(name, ...) is used, Meson should not\nlook it up on the system but instead return dep_object, which may either be\nthe result of dependency() or declare_dependency(). It takes optional\nnative keyword arguments. Doing this in a subproject allows the parent\nproject to retrieve the dependency without having to know the dependency\nvariable name: dependency(name, fallback : subproject_name).\n\n\nproject_version(): returns the version string specified in\nproject function call.\n\n\nproject_license(): returns the array of licenses specified in\nproject function call.\n\n\nproject_name(): returns the project name specified in the project\nfunction call.\n\n\nversion(): return a string with the version of Meson.\n\n\nadd_devenv(): (Since 0.58.0) add an environment() object\nto the list of environments that will be applied when using meson devenv\ncommand line. This is useful for developpers who wish to use the project without\ninstalling it, it is often needed to set for example the path to plugins\ndirectory, etc. Alternatively, a list or dictionary can be passed as first\nargument.\ndevenv = environment()\ndevenv.set('PLUGINS_PATH', meson.current_build_dir())\n...\nmeson.add_devenv(devenv)\n\nAfter configuring and compiling that project, a terminal can be opened with\nthe environment set:\n$ meson devenv -C <builddir>\n$ echo $PLUGINS_PATH\n/path/to/source/subdir\n\nSee meson devenv command documentation for a list of\nenvironment variables that are set by default by Meson.\n\n\n"});