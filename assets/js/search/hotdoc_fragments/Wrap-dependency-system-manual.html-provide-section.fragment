fragment_downloaded_cb({"url":"Wrap-dependency-system-manual.html#provide-section","fragment":"\nprovide section\n*Since 0.55.0\nWrap files can define the dependencies it provides in the [provide]\nsection.\nWhen a wrap file provides the dependency foo-1.0, as above, any call to\ndependency('foo-1.0') will automatically fallback to that subproject even if\nno fallback keyword argument is given. A wrap file named foo.wrap implicitly\nprovides the dependency name foo even when the [provide] section is missing.\nOptional dependencies, like dependency('foo-1.0', required: get_option('foo_opt'))\nwhere foo_opt is a feature option set to auto, will not fallback to the\nsubproject defined in the wrap file, for 2 reasons:\nIf it is desired to fallback for an optional dependency, the\nfallback or allow_fallback keyword arguments must be passed\nexplicitly. Since 0.56.0, dependency('foo-1.0', required: get_option('foo_opt'), allow_fallback: true) will use the fallback\neven when foo_opt is set to auto. On version 0.55.0 the same\neffect could be achieved with dependency('foo-1.0', required: get_option('foo_opt'), fallback: 'foo').\nThis mechanism assumes the subproject calls\nmeson.override_dependency('foo-1.0', foo_dep) so Meson knows which\ndependency object should be used as fallback. Since that method was\nintroduced in version 0.54.0, as a transitional aid for projects\nthat do not yet make use of it the variable name can be provided in\nthe wrap file with entries in the format foo-1.0 = foo_dep.\nFor example when using a recent enough version of glib that uses\nmeson.override_dependency() to override glib-2.0, gobject-2.0\nand gio-2.0, a wrap file would look like:\nWith older version of glib dependency variable names need to be\nspecified:\nPrograms can also be provided by wrap files, with the program_names\nkey:\nWith such wrap file, find_program('myprog') will automatically\nfallback to use the subproject, assuming it uses\nmeson.override_find_program('myprog').\n\nIt allows for looking the dependency in other ways first, for example using\ncc.find_library('foo'), and only fallback if that fails:\n\n\nSometimes not-found dependency is preferable to a fallback when the\nfeature is not explicitly requested by the user. In that case\ndependency('foo-1.0', required: get_option('foo_opt')) will only\nfallback when the user sets foo_opt to enabled instead of\nauto.\nSince 0.58.0 optional dependency like above will fallback to the subproject\ndefined in the wrap file in the case wrap_mode is set to forcefallback\nor force_fallback_for contains the subproject.\n\n"});