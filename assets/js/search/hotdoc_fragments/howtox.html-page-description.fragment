fragment_downloaded_cb({"url":"howtox.html#page-description","fragment":"This page lists code snippets for common tasks. These are written\nmostly using the C compiler, but the same approach should work on\nalmost all other compilers.\nWhen first running Meson, set it in an environment variable.\nNote that environment variables like CC only works in native builds.\nThe CC refers to the compiler for the host platform, that is the\ncompiler used to compile programs that run on the machine we will\neventually install the project on. The compiler used to build things\nthat run on the machine we do the building can be specified with\nCC_FOR_BUILD. You can use it in cross builds.\nNote that environment variables are never the idiomatic way to do\nanything with Meson, however. It is better to use the native and cross\nfiles. And the tools for the host platform in cross builds can only be\nspecified with a cross file.\nThere is a table of all environment variables supported\nHere\nNew in 0.53.0\nLike the compiler, the linker is selected via the <compiler variable>_LD environment variable, or through the <compiler entry>_ld entry in a native or cross file. You must be aware of\nwhether you're using a compiler that invokes the linker itself (most\ncompilers including GCC and Clang) or a linker that is invoked\ndirectly (when using MSVC or compilers that act like it, including\nClang-Cl). With the former c_ld or CC_LD should be the value to\npass to the compiler's special argument (such as -fuse-ld with clang\nand gcc), with the latter it should be an executable, such as\nlld-link.exe.\nNOTE In Meson 0.53.0 the ld entry in the cross/native file and the\nLD environment variable were used, this resulted in a large number\nof regressions and was changed in 0.53.1 to <lang>_ld and <comp variable>_LD.\nor\nor in a cross or native file:\nThere is a table of all environment variables supported\nHere\nThe language version can also be set on a per-target basis.\nLots of people seem to do this manually with find_library('pthread')\nor something similar. Do not do that. It is not portable. Instead do\nthis.\nThe behavior is the same as with other build systems, with environment\nvariables during first invocation. Do not use these when you need to\nrebuild the source\nFirst check which arguments to use.\nThen use it in a target.\nIf you want to use the arguments on all targets, then do this.\nThe [fs module](#Fs-modules) offers thereadfunction which enables adding\nthe contents of arbitrary files to configuration data (among other uses):\nconfigure_file preserves metadata so if your template file has\nexecute permissions, the generated file will have them too.\nFirst initialize the build directory with this command.\nThen issue the following commands.\nThe coverage report can be found in the meson-logs subdirectory.\nNew in 0.55.0 llvm-cov support for use with clang\nBy default the debug build does not use any optimizations. This is the\ndesired approach most of the time. However some projects benefit from\nhaving some minor optimizations enabled. GCC even has a specific\ncompiler flag -Og for this. To enable its use, just issue the\nfollowing command.\nThis causes all subsequent builds to use this command line argument.\nClang comes with a selection of analysis tools such as the address\nsanitizer. Meson\nhas native support for these with the b_sanitize option.\nAfter this you just compile your code and run the test suite. Address\nsanitizer will abort executables which have bugs so they show up as\ntest failures.\nInstall scan-build program, then do this:\nYou can use the SCANBUILD environment variable to choose the\nscan-build executable.\nYou can use it for passing arguments to scan-build program by\ncreating a script, for example:\nAnd then pass it through the variable (remember to use absolute path):\nUsing profile guided optimization with GCC is a two phase\noperation. First we set up the project with profile measurements\nenabled and compile it.\nThen we need to run the program with some representative input. This\nstep depends on your project.\nOnce that is done we change the compiler flags to use the generated\ninformation and rebuild.\nAfter these steps the resulting binary is fully optimized.\nSome platforms (e.g. Linux) have a standalone math library. Other\nplatforms (pretty much everyone else) do not. How to specify that m\nis used only when needed?\nMeson can use the CMake find_package() ecosystem if CMake is\ninstalled. To find a dependency with custom Find<name>.cmake, set\nthe cmake_module_path property to the path in your project where the\nCMake scripts are stored.\nExample for a FindCmakeOnlyDep.cmake in a cmake subdirectory:\nThe cmake_module_path property is only needed for custom CMake scripts. System\nwide CMake scripts are found automatically.\nMore information can be found here\nThis can be used in cases where you want a default value, but might override it\nlater.\n"});