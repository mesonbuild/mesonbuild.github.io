fragment_downloaded_cb({"url":"Wrap-dependency-system-manual.html#page-description","fragment":"One of the major problems of multiplatform development is wrangling\nall your dependencies. This is awkward on many platforms, especially\non ones that do not have a built-in package manager. The latter problem\nhas been worked around by having third party package managers. They\nare not really a solution for end user deployment, because you can't\ntell them to install a package manager just to use your app. On these\nplatforms you must produce self-contained applications. Same applies\nwhen destination platform is missing (up-to-date versions of) your\napplication's dependencies.\nThe traditional approach to this has been to bundle dependencies\ninside your own project. Either as prebuilt libraries and headers or\nby embedding the source code inside your source tree and rewriting\nyour build system to build them as part of your project.\nThis is both tedious and error prone because it is always done by\nhand. The Wrap dependency system of Meson aims to provide an automated\nway to do this.\nMeson has a concept of subprojects. They are a way\nof nesting one Meson project inside another. Any project that builds\nwith Meson can detect that it is built as a subproject and build\nitself in a way that makes it easy to use (usually this means as a\nstatic library).\nTo use this kind of a project as a dependency you could just copy and\nextract it inside your project's subprojects directory.\nHowever there is a simpler way. You can specify a Wrap file that tells\nMeson how to download it for you. If you then use this subproject in\nyour build, Meson will automatically download and extract it during\nbuild. This makes subproject embedding extremely easy.\nAll wrap files must have a name of <project_name>.wrap form and be\nin subprojects dir.\nCurrently Meson has four kinds of wraps:\nWrap files are written in ini format, with a single header containing\nthe type of wrap, followed by properties describing how to obtain the\nsources, validate them, and modify them if needed. An example\nwrap-file for the wrap named libfoobar would have a filename\nlibfoobar.wrap and would look like this:\nAn example wrap-git will look like this:\nSince 0.55.0 those can be used in all wrap types, they were\npreviously reserved to wrap-file:\nSince 0.55.0 it is possible to use only the source_filename and\npatch_filename value in a .wrap file (without source_url and\npatch_url) to specify a local archive in the\nsubprojects/packagefiles directory. The *_hash entries are\noptional when using this method. This method should be preferred over\nthe old packagecache approach described below.\nSince 0.49.0 if source_filename or patch_filename is found in the\nproject's subprojects/packagecache directory, it will be used instead\nof downloading the file, even if --wrap-mode option is set to\nnodownload. The file's hash will be checked.\nUnfortunately most software projects in the world do not build with\nMeson. Because of this Meson allows you to specify a patch URL.\nFor historic reasons this is called a \"patch\", however, it serves as an\noverlay to add or replace files rather than modifying them. The file\nmust be an archive; it is downloaded and automatically extracted into\nthe subproject. The extracted files will include a Meson build\ndefinition for the given subproject.\nThis approach makes it extremely simple to embed dependencies that\nrequire build system changes. You can write the Meson build definition\nfor the dependency in total isolation. This is a lot better than doing\nit inside your own source tree, especially if it contains hundreds of\nthousands of lines of code. Once you have a working build definition,\njust zip up the Meson build files (and others you have changed) and\nput them somewhere where you can download them.\nPrior to 0.55.0 Meson build patches were only supported for\nwrap-file mode. When using wrap-git, the repository must contain all\nMeson build definitions. Since 0.55.0 Meson build patches are\nsupported for any wrap modes, including wrap-git.\n*Since 0.55.0\nWrap files can define the dependencies it provides in the [provide]\nsection.\nWhen a wrap file provides the dependency foo-1.0, as above, any call to\ndependency('foo-1.0') will automatically fallback to that subproject even if\nno fallback keyword argument is given. A wrap file named foo.wrap implicitly\nprovides the dependency name foo even when the [provide] section is missing.\nOptional dependencies, like dependency('foo-1.0', required: get_option('foo_opt'))\nwhere foo_opt is a feature option set to auto, will not fallback to the\nsubproject defined in the wrap file, for 2 reasons:\nIf it is desired to fallback for an optional dependency, the\nfallback or allow_fallback keyword arguments must be passed\nexplicitly. Since 0.56.0, dependency('foo-1.0', required: get_option('foo_opt'), allow_fallback: true) will use the fallback\neven when foo_opt is set to auto. On version 0.55.0 the same\neffect could be achieved with dependency('foo-1.0', required: get_option('foo_opt'), fallback: 'foo').\nThis mechanism assumes the subproject calls\nmeson.override_dependency('foo-1.0', foo_dep) so Meson knows which\ndependency object should be used as fallback. Since that method was\nintroduced in version 0.54.0, as a transitional aid for projects\nthat do not yet make use of it the variable name can be provided in\nthe wrap file with entries in the format foo-1.0 = foo_dep.\nFor example when using a recent enough version of glib that uses\nmeson.override_dependency() to override glib-2.0, gobject-2.0\nand gio-2.0, a wrap file would look like:\nWith older version of glib dependency variable names need to be\nspecified:\nPrograms can also be provided by wrap files, with the program_names\nkey:\nWith such wrap file, find_program('myprog') will automatically\nfallback to use the subproject, assuming it uses\nmeson.override_find_program('myprog').\nWraps provide a convenient way of obtaining a project into your\nsubproject directory. Then you use it as a regular subproject (see\nsubprojects).\nUsually you don't want to write your wraps by hand.\nThere is an online repository called\nWrapDB that provides many\ndependencies ready to use. You can read more about WrapDB\nhere.\nThere is also a Meson subcommand to get and manage wraps (see using\nwraptool).\n\nwrap-file\nwrap-git\nwrap-hg\nwrap-svn\n\n\n\ndirectory - name of the subproject root directory, defaults to the\nname of the wrap.\n\n\n\npatch_url - download url to retrieve an optional overlay archive\n\npatch_fallback_url - fallback URL to be used when download from patch_url fails Since: 0.55.0\n\n\npatch_filename - filename of the downloaded overlay archive\n\npatch_hash - sha256 checksum of the downloaded overlay archive\n\npatch_directory - Since 0.55.0 Overlay directory, alternative to patch_filename in the case\nfiles are local instead of a downloaded archive. The directory must be placed in\nsubprojects/packagefiles.\n\n\n\nsource_url - download url to retrieve the wrap-file source archive\n\nsource_fallback_url - fallback URL to be used when download from source_url fails Since: 0.55.0\n\n\nsource_filename - filename of the downloaded source archive\n\nsource_hash - sha256 checksum of the downloaded source archive\n\nlead_directory_missing - for wrap-file create the leading\ndirectory name. Needed when the source file does not have a leading\ndirectory.\n\n\n\nurl - name of the wrap-git repository to clone. Required.\n\nrevision - name of the revision to checkout. Must be either: a\nvalid value (such as a git tag) for the VCS's checkout command, or\n(for git) head to track upstream's default branch. Required.\n\n\n\ndepth - shallowly clone the repository to X number of commits. Note\nthat git always allow shallowly cloning branches, but in order to\nclone commit ids shallowly, the server must support\nuploadpack.allowReachableSHA1InWant=true.  (since 0.52.0)\n\n\npush-url - alternative url to configure as a git push-url. Useful if\nthe subproject will be developed and changes pushed upstream.\n(since 0.37.0)\n\n\nclone-recursive - also clone submodules of the repository\n(since 0.48.0)\n\n\n\nIt allows for looking the dependency in other ways first, for example using\ncc.find_library('foo'), and only fallback if that fails:\n\n\nSometimes not-found dependency is preferable to a fallback when the\nfeature is not explicitly requested by the user. In that case\ndependency('foo-1.0', required: get_option('foo_opt')) will only\nfallback when the user sets foo_opt to enabled instead of\nauto.\nSince 0.58.0 optional dependency like above will fallback to the subproject\ndefined in the wrap file in the case wrap_mode is set to forcefallback\nor force_fallback_for contains the subproject.\n\n"});