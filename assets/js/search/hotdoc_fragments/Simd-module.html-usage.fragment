fragment_downloaded_cb({"url":"Simd-module.html#usage","fragment":"Usage\nThis module is designed for the use case where you have an algorithm\nwith one or more SIMD implementation and you choose which one to use\nat runtime.\nThe module provides one method, check, which is used like this:\nHere the individual files contain the accelerated versions of the\nfunctions in question. The compiler keyword argument takes the\ncompiler you are going to use to compile them. The function returns an\narray with two values. The first value is a bunch of libraries that\ncontain the compiled code. Any SIMD code that the compiler can't\ncompile (for example, Neon instructions on an x86 machine) are\nignored. You should pass this value to the desired target using\nlink_with. The second value is a configuration_data object that\ncontains true for all the values that were supported. For example if\nthe compiler did support sse2 instructions, then the object would have\nHAVE_SSE2 set to 1.\nGenerating code to detect the proper instruction set at runtime is\nstraightforward. First you create a header with the configuration\nobject and then a chooser function that looks like this:\nEach source file provides two functions, the xxx_available function\nto query whether the CPU currently in use supports the instruction set\nand xxx_accelerated_function that is the corresponding accelerated\nimplementation.\nAt the end of this function the function pointer points to the fastest\navailable implementation and can be invoked to do the computation.\n"});