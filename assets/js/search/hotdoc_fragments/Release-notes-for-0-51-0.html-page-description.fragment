fragment_downloaded_cb({"url":"Release-notes-for-0-51-0.html#page-description","fragment":"Meson previously stored CPPFLAGS and per-language compilation flags\nseparately. (That latter would come from CFLAGS, CXXFLAGS, etc.,\nalong with <lang>_args options whether specified no the command-line\ninterface (-D..), meson.build (default_options), or cross file\n([properties]).) This was mostly unobservable, except for certain\npreprocessor-only checks like check_header would only use the\npreprocessor flags, leading to confusion if some -isystem was in\nCFLAGS but not CPPFLAGS. Now, they are lumped together, and\nCPPFLAGS, for the languages which are deemed to care to about, is\njust another source of compilation flags along with the others already\nlisted.\nSanity checks previously only used user-specified flags for cross\ncompilers, but now do in all cases.\nAll compilers meson might decide to use for the build are \"sanity\nchecked\" before other tests are run. This usually involves building\nsimple executable and trying to run it. Previously user flags\n(compilation and/or linking flags) were used for sanity checking cross\ncompilers, but not native compilers. This is because such flags might\nbe essential for a cross binary to succeed, but usually aren't for a\nnative compiler.\nIn recent releases, there has been an effort to minimize the\nspecial-casing of cross or native builds so as to make building more\npredictable in less-tested cases. Since this the user flags are\nnecessary for cross, but not harmful for native, it makes more sense\nto use them in all sanity checks than use them in no sanity checks, so\nthis is what we now do.\nA new module, sourceset, was added to help building many binaries\nfrom the same source files. Source sets associate source files and\ndependencies to keys in a configuration_data object or a dictionary;\nthey then take multiple configuration_data objects or dictionaries,\nand compute the set of source files and dependencies for each of those\nconfigurations.\nPreviously if this combination was used then assertions were enabled,\nwhich is fairly surprising behavior.\nThe target_type keyword argument in build_target() now accepts the\nvalue 'shared_module'.\nThe statement\nis equivalent to this:\nThis mirrors the modules argument that some kinds of dependencies\n(such as qt, llvm, and cmake based dependencies) take, allowing you to\ncheck that a particular module is available when getting a python\nversion.\nSupport has been added for ICL.EXE and ifort on windows. The support\nshould be on part with ICC support on Linux/MacOS. The ICL C/C++\ncompiler behaves like Microsoft's CL.EXE rather than GCC/Clang like\nICC does, and has a different id, intel-cl to differentiate it.\nYou can now use xt-xcc, xt-xc++, xt-nm, etc... on your cross\ncompilation file and meson won't complain about an unknown toolchain.\nThis is a generic replacement for type specific variable getters such as\nConfigToolDependency.get_configtool_variable and\nPkgConfigDependency.get_pkgconfig_variable, and is the only way to query\nsuch variables from cmake dependencies.\nThis method allows you to get variables without knowing the kind of\ndependency you have.\nWhen using pkg-config as a dependency resolver we can pass\n-Dpkg_config_path=$somepath to extend or overwrite where pkg-config\nwill search for dependencies. Now cmake can do the same, as long as\nthe dependency uses a ${Name}Config.cmake file (not a\nFind{$Name}.cmake file), by passing\n-Dcmake_prefix_path=list,of,paths. It is important that point this\nat the prefix that the dependency is installed into, not the cmake\npath.\nIf you have installed something to /tmp/dep, which has a layout like:\nthen invoke meson as meson builddir/ -Dcmake_prefix_path=/tmp/dep\nYou can tag a test as needing to fail like this:\nIf the test passes the problem is reported in the error logs but due\nto a bug it was not reported in the test runner's exit code. Starting\nfrom this release the unexpected passes are properly reported in the\ntest runner's exit code. This means that test runs that were passing\nin earlier versions of Meson will report failures with the current\nversion. This is a good thing, though, since it reveals an error in\nyour test suite that has, until now, gone unnoticed.\nThere may be situations for which the user wishes to manually specify\nthe linking language.  For example, a C++ target may link C, Fortran,\netc. and perhaps the automatic detection in Meson does not pick the\ndesired compiler.  The user can manually choose the linker by language\nper-target like this example of a target where one wishes to link with\nthe Fortran compiler:\nA specific case this option fixes is where for example the main\nprogram is Fortran that calls C and/or C++ code. The automatic\nlanguage detection of Meson prioritizes C/C++, and so an compile-time\nerror results like undefined reference to main, because the linker\nis C or C++ instead of Fortran, which is fixed by this per-target\noverride.\nThe new module unstable-kconfig adds the ability to parse and use\nkconfig output files from meson.build.\nmeson subprojects has learned a new foreach command which accepts\na command with arguments and executes it in each subproject directory.\nFor example this can be useful to check the status of subprojects\n(e.g. with git status or git diff) before performing other actions\non them.\nFor gcc version 8.0 and later, the values c17, c18, gnu17, and gnu18\nwere added to the accepted values for built-in compiler option c_std.\nFor Clang version 10.0 and later on Apple OSX (Darwin), and for\nversion 7.0 and later on other platforms, the values c17 and gnu17\nwere added as c_std values.\nPreviously, we could only detect GPGME with custom invocations of\ngpgme-config or when the GPGME version was recent enough (>=1.13.0)\nto install pkg-config files. Now we added support to Meson allowing us\nto use dependency('gpgme') and fall back on gpgme-config parsing.\nThe output of custom_target and custom_target[i] can be used in\nlink_with and link_whole keyword arguments. This is useful for\nintegrating custom code generator steps, but note that there are many\nlimitations:\nMeson can not know about link dependencies of the custom target. If\nthe target requires further link libraries, you need to add them manually\nThe user is responsible for ensuring that the code produced by\ndifferent toolchains are compatible.\ncustom_target may only be used when it has a single output file.\nUse custom_target[i] when dealing with multiple output files.\nThe output file must have the correct file name extension.\nThe --target-files introspection API is now no longer available. The same\ninformation can be queried with the --targets API introduced in 0.50.0.\nGenerators can now specify extra dependencies with the depends\nkeyword argument. It matches the behaviour of the same argument in\nother functions and specifies that the given targets must be built\nbefore the generator can be run. This is used in cases such as this\none where you need to tell a generator to indirectly invoke a\ndifferent program.\nPreviously, no cross builds were controllable from the command line.\nMachine-specific options like the pkg-config path and compiler options\nonly affected native targets, that is to say all targets in native\nbuilds, and native: true targets in cross builds. Now, prefix the\noption with build. to affect build machine targets, and leave it\nunprefixed to affect host machine targets.\nFor those trying to ensure native and cross builds to the same\nplatform produced the same result, the old way was frustrating because\nvery different invocations were needed to affect the same targets, if\nit was possible at all. Now, the same command line arguments affect\nthe same targets everywhere --- Meson is closer to ignoring whether\nthe \"overall\" build is native or cross, and just caring about whether\nindividual targets are for the build or host machines.\nSimilar to get_variable, a fallback argument can now be passed to\nsubproject.get_variable(), it will be returned if the requested\nvariable name did not exist.\nfind_library has learned the static keyword. They keyword must be\na boolean, where true only searches for static libraries and false\nonly searches for dynamic/shared. Leaving the keyword unset will keep\nthe old behavior of first searching for dynamic and then falling back\nto static.\nWhile non-standard and generally not recommended, some legacy Fortran\nprograms use include directives to inject code inline. Since v0.51,\nMeson can handle Fortran include directives recursively.\nDO NOT list include files as sources for a target, as in general\ntheir syntax is not correct as a standalone target. In general\ninclude files are meant to be injected inline as if they were copy\nand pasted into the source file.\ninclude was never standard and was superceded by Fortran 90 module.\nThe include file is only recognized by Meson if it has a Fortran\nfile suffix, such as .f .F .f90 .F90 or similar. This is to\navoid deeply nested scanning of large external legacy C libraries that\nonly interface to Fortran by include biglib.h or similar.\nMeson can now directly consume CMake based subprojects with the\nCMake module.\nUsing CMake subprojects is similar to using the \"normal\" meson\nsubprojects. They also have to be located in the subprojects\ndirectory.\nExample:\nIt should be noted that not all projects are guaranteed to work. The\nsafest approach would still be to create a meson.build for the\nsubprojects in question.\n--cross-file can be passed multiple times, with the configuration files overlaying the same way as --native-file.\n\n\nMeson can not know about link dependencies of the custom target. If\nthe target requires further link libraries, you need to add them manually\n\n\nThe user is responsible for ensuring that the code produced by\ndifferent toolchains are compatible.\n\n\ncustom_target may only be used when it has a single output file.\nUse custom_target[i] when dealing with multiple output files.\n\n\nThe output file must have the correct file name extension.\n\n\n"});