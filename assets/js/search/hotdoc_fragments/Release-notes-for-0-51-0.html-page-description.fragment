fragment_downloaded_cb({"url":"Release-notes-for-0-51-0.html#page-description","fragment":"Meson previously stored CPPFLAGS and per-language compilation flags\nseparately. (That latter would come from CFLAGS, CXXFLAGS, etc., along with\n<lang>_args options whether specified no the command-line interface (-D..),\nmeson.build (default_options), or cross file ([properties]).) This was\nmostly unobservable, except for certain preprocessor-only checks like\ncheck_header would only use the preprocessor flags, leading to confusion if\nsome -isystem was in CFLAGS but not CPPFLAGS. Now, they are lumped\ntogether, and CPPFLAGS, for the languages which are deemed to care to about,\nis just another source of compilation flags along with the others already\nlisted.\nSanity checks previously only used user-specified flags for cross compilers, but\nnow do in all cases.\nAll compilers meson might decide to use for the build are \"sanity checked\"\nbefore other tests are run. This usually involves building simple executable and\ntrying to run it. Previously user flags (compilation and/or linking flags) were\nused for sanity checking cross compilers, but not native compilers.  This is\nbecause such flags might be essential for a cross binary to succeed, but usually\naren't for a native compiler.\nIn recent releases, there has been an effort to minimize the special-casing of\ncross or native builds so as to make building more predictable in less-tested\ncases. Since this the user flags are necessary for cross, but not harmful for\nnative, it makes more sense to use them in all sanity checks than use them in no\nsanity checks, so this is what we now do.\nA new module, sourceset, was added to help building many binaries\nfrom the same source files.  Source sets associate source files and\ndependencies to keys in a configuration_data object or a dictionary;\nthey then take multiple configuration_data objects or dictionaries,\nand compute the set of source files and dependencies for each of those\nconfigurations.\nPreviously if this combination was used then assertions were enabled,\nwhich is fairly surprising behavior.\nThe target_type keyword argument in build_target() now accepts the\nvalue 'shared_module'.\nThe statement\nis equivalent to this:\nThis mirrors the modules argument that some kinds of dependencies (such as\nqt, llvm, and cmake based dependencies) take, allowing you to check that a\nparticular module is available when getting a python version.\nSupport has been added for ICL.EXE and ifort on windows. The support should be\non part with ICC support on Linux/MacOS. The ICL C/C++ compiler behaves like\nMicrosoft's CL.EXE rather than GCC/Clang like ICC does, and has a different id,\nintel-cl to differentiate it.\nYou can now use xt-xcc, xt-xc++, xt-nm, etc... on your cross compilation\nfile and meson won't complain about an unknown toolchain.\nThis is a generic replacement for type specific variable getters such as\nConfigToolDependency.get_configtool_variable and\nPkgConfigDependency.get_pkgconfig_variable, and is the only way to query\nsuch variables from cmake dependencies.\nThis method allows you to get variables without knowing the kind of\ndependency you have.\nWhen using pkg-config as a dependency resolver we can pass\n-Dpkg_config_path=$somepath to extend or overwrite where pkg-config will\nsearch for dependencies. Now cmake can do the same, as long as the dependency\nuses a ${Name}Config.cmake file (not a Find{$Name}.cmake file), by passing\n-Dcmake_prefix_path=list,of,paths. It is important that point this at the\nprefix that the dependency is installed into, not the cmake path.\nIf you have installed something to /tmp/dep, which has a layout like:\nthen invoke meson as meson builddir/ -Dcmake_prefix_path=/tmp/dep\nYou can tag a test as needing to fail like this:\nIf the test passes the problem is reported in the error logs but due\nto a bug it was not reported in the test runner's exit code. Starting\nfrom this release the unexpected passes are properly reported in the\ntest runner's exit code. This means that test runs that were passing\nin earlier versions of Meson will report failures with the current\nversion. This is a good thing, though, since it reveals an error in\nyour test suite that has, until now, gone unnoticed.\nThere may be situations for which the user wishes to manually specify\nthe linking language.  For example, a C++ target may link C, Fortran,\netc. and perhaps the automatic detection in Meson does not pick the\ndesired compiler.  The user can manually choose the linker by language\nper-target like this example of a target where one wishes to link with\nthe Fortran compiler:\nA specific case this option fixes is where for example the main\nprogram is Fortran that calls C and/or C++ code.  The automatic\nlanguage detection of Meson prioritizes C/C++, and so an compile-time\nerror results like undefined reference to main, because the linker\nis C or C++ instead of Fortran, which is fixed by this per-target\noverride.\nThe new module unstable-kconfig adds the ability to parse and use\nkconfig output files from meson.build.\nmeson subprojects has learned a new foreach command which accepts a command\nwith arguments and executes it in each subproject directory.\nFor example this can be useful to check the status of subprojects (e.g. with\ngit status or git diff) before performing other actions on them.\nFor gcc version 8.0 and later, the values c17, c18, gnu17, and gnu18\nwere added to the accepted values for built-in compiler option c_std.\nFor Clang version 10.0 and later on Apple OSX (Darwin), and for\nversion 7.0 and later on other platforms, the values c17 and gnu17\nwere added as c_std values.\nPreviously, we could only detect GPGME with custom invocations of\ngpgme-config or when the GPGME version was recent enough (>=1.13.0)\nto install pkg-config files. Now we added support to Meson allowing us\nto use dependency('gpgme') and fall back on gpgme-config parsing.\nThe output of custom_target and custom_target[i] can be used in\nlink_with and link_whole keyword arguments. This is useful for\nintegrating custom code generator steps, but note that there are many\nlimitations:\nMeson can not know about link dependencies of the custom target. If\nthe target requires further link libraries, you need to add them manually\nThe user is responsible for ensuring that the code produced by\ndifferent toolchains are compatible.\ncustom_target may only be used when it has a single output file.\nUse custom_target[i] when dealing with multiple output files.\nThe output file must have the correct file name extension.\nThe --target-files introspection API is now no longer available. The same\ninformation can be queried with the --targets API introduced in 0.50.0.\nGenerators can now specify extra dependencies with the depends\nkeyword argument. It matches the behaviour of the same argument in\nother functions and specifies that the given targets must be built\nbefore the generator can be run. This is used in cases such as this\none where you need to tell a generator to indirectly invoke a\ndifferent program.\nPreviously, no cross builds were controllable from the command line.\nMachine-specific options like the pkg-config path and compiler options only\naffected native targets, that is to say all targets in native builds, and\nnative: true targets in cross builds. Now, prefix the option with build. to\naffect build machine targets, and leave it unprefixed to affect host machine\ntargets.\nFor those trying to ensure native and cross builds to the same platform produced\nthe same result, the old way was frustrating because very different invocations\nwere needed to affect the same targets, if it was possible at all. Now, the same\ncommand line arguments affect the same targets everywhere --- Meson is closer to\nignoring whether the \"overall\" build is native or cross, and just caring about\nwhether individual targets are for the build or host machines.\nSimilar to get_variable, a fallback argument can now be passed to\nsubproject.get_variable(), it will be returned if the requested\nvariable name did not exist.\nfind_library has learned the static keyword. They keyword must be a boolean,\nwhere true only searches for static libraries and false only searches for\ndynamic/shared. Leaving the keyword unset will keep the old behavior of first\nsearching for dynamic and then falling back to static.\nWhile non-standard and generally not recommended, some legacy Fortran\nprograms use include directives to inject code inline.  Since v0.51,\nMeson can handle Fortran include directives recursively.\nDO NOT list include files as sources for a target, as in general\ntheir syntax is not correct as a standalone target.  In general\ninclude files are meant to be injected inline as if they were copy\nand pasted into the source file.\ninclude was never standard and was superceded by Fortran 90 module.\nThe include file is only recognized by Meson if it has a Fortran\nfile suffix, such as .f .F .f90 .F90 or similar.  This is to\navoid deeply nested scanning of large external legacy C libraries that\nonly interface to Fortran by include biglib.h or similar.\nMeson can now directly consume CMake based subprojects with the\nCMake module.\nUsing CMake subprojects is similar to using the \"normal\" meson\nsubprojects. They also have to be located in the subprojects\ndirectory.\nExample:\nIt should be noted that not all projects are guaranteed to work. The\nsafest approach would still be to create a meson.build for the\nsubprojects in question.\n--cross-file can be passed multiple times, with the configuration files overlaying the same way as --native-file.\n\n\nMeson can not know about link dependencies of the custom target. If\nthe target requires further link libraries, you need to add them manually\n\n\nThe user is responsible for ensuring that the code produced by\ndifferent toolchains are compatible.\n\n\ncustom_target may only be used when it has a single output file.\nUse custom_target[i] when dealing with multiple output files.\n\n\nThe output file must have the correct file name extension.\n\n\n"});