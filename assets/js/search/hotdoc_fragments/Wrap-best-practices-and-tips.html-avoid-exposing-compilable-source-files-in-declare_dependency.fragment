fragment_downloaded_cb({"url":"Wrap-best-practices-and-tips.html#avoid-exposing-compilable-source-files-in-declare_dependency","fragment":"Avoid exposing compilable source files in declare_dependency\nThe main use for the sources argument in declare_dependency is to\nconstruct the correct dependency graph for the backends, as\ndemonstrated in the previous section. It is extremely important to\nnote that it should not be used to directly expose compilable\nsources (.c, .cpp, etc.) of dependencies, and should rather only\nbe used for header/config files. The following example will illustrate\nwhat can go wrong if you accidentally expose compilable source files.\nSo you've read about unity builds and how Meson natively supports\nthem. You decide to expose the sources of dependencies in order to\nhave unity builds that include their dependencies. For your support\nlibrary you do\nAnd for your main project you do:\nThis is extremely dangerous. When building, mylibrary will build and\nlink the support sources my_support_sources into the resulting\nshared library. Then, for myexe, these same support sources will be\ncompiled again, will be linked into the resulting executable, in\naddition to them being already present in mylibrary. This can\nquickly run afoul of the One Definition Rule\n(ODR) in C++, as\nyou have more than one definition of a symbol, yielding undefined\nbehavior. While C does not have a strict ODR rule, there is no\nlanguage in the standard which guarantees such behavior to work.\nViolations of the ODR can lead to weird idiosyncratic failures such as\nsegfaults. In the overwhelming number of cases, exposing library\nsources via the sources argument in declare_dependency is thus\nincorrect. If you wish to get full cross-library performance, consider\nbuilding mysupportlib as a static library instead and employing LTO.\nThere are exceptions to this rule. If there are some natural\nconstraints on how your library is to be used, you can expose sources.\nFor instance, the WrapDB module for GoogleTest directly exposes the\nsources of GTest and GMock. This is valid, as GTest and GMock will\nonly ever be used in terminal link targets. A terminal target is the\nfinal target in a dependency link chain, for instance myexe in the\nlast example, whereas mylibrary is an intermediate link target. For\nmost libraries this rule is not applicable though, as you cannot in\ngeneral control how others consume your library, and as such should\nnot expose sources.\n"});