fragment_downloaded_cb({"url":"Using-multiple-build-directories.html#page-description","fragment":"One of the main design goals of Meson has been to build all projects\nout-of-source. This means that all files generated during the build\nare placed in a separate subdirectory. This goes against common Unix\ntradition where you build your projects in-source. Building out of\nsource gives two major advantages.\nFirst of all this makes for very simple .gitignore files. In\nclassical build systems you may need to have tens of lines of\ndefinitions, most of which contain wildcards. When doing out of source\nbuilds all of this busywork goes away. A common ignore file for a\nMeson project only contains a few lines that are the build directory\nand IDE project files.\nSecondly this makes it very easy to clean your projects: just delete\nthe build subdirectory and you are done. There is no need to guess\nwhether you need to run make clean, make distclean, make mrproper or something else. When you delete a build subdirectory\nthere is no possible way to have any lingering state from your old\nbuilds.\nThe true benefit comes from somewhere else, though.\nSince a build directory is fully self contained and treats the source\ntree as a read-only piece of data, it follows that you can have\narbitrarily many build trees for any source tree at the same time.\nSince all build trees can have different configuration, this is\nextremely powerful. Now you might be wondering why one would want to\nhave multiple build setups at the same time. Let's examine this by\nsetting up a hypothetical project.\nThe first thing to do is to set up the default build, that is, the one\nwe are going to use over 90% of the time. In this we use the system\ncompiler and build with debug enabled and no optimizations so it\nbuilds as fast as possible. This is the default project type for\nMeson, so setting it up is simple.\nAnother common setup is to build with debug and optimizations to, for\nexample, run performance tests. Setting this up is just as simple.\nFor systems where the default compiler is GCC, we would like to\ncompile with Clang, too. So let's do that.\nYou can add cross builds, too. As an example, let's set up a Linux ->\nWindows cross compilation build using MinGW.\nThe cross compilation file sets up Wine so that not only can you\ncompile your application, you can also run the unit test suite just by\nissuing the command meson test.\nTo compile any of these build types, just cd into the corresponding\nbuild directory and run meson compile or instruct your IDE to do the\nsame. Note that once you have set up your build directory once, you\ncan just run Ninja and Meson will ensure that the resulting build is\nfully up to date according to the source. Even if you have not touched\none of the directories in weeks and have done major changes to your\nbuild configuration, Meson will detect this and bring the build\ndirectory up to date (or print an error if it can't do that). This\nallows you to do most of your work in the default directory and use\nthe others every now and then without having to babysit your build\ndirectories.\nSeparate build directories allows easy integration for various\ndifferent kinds of tools. As an example, Clang comes with a static\nanalyzer. It is meant to be run from scratch on a given source tree.\nThe steps to run it with Meson are very simple.\nThese commands are the same for every single Meson project, so they\ncould even be put in a script turning static analysis into a single\ncommand.\n"});