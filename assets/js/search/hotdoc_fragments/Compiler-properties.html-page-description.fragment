fragment_downloaded_cb({"url":"Compiler-properties.html#page-description","fragment":"Not all compilers and platforms are alike. Therefore Meson provides\nthe tools to detect properties of the system during configure time. To\nget most of this information, you first need to extract the compiler\nobject from the main meson variable.\nHere we extract the C compiler. We could also have given the argument\ncpp to get the C++ compiler, objc to get the objective C compiler\nand so on. The call is valid for all languages specified in the\nproject declaration. Trying to obtain some other compiler will lead\nto an unrecoverable error.\nThis is a bit complex and more thoroughly explained on the page on\ncross compilation. But if you just want to\nknow the operating system your code will run on, issue this command:\nThe compiler object method get_id returns a\nlower case string describing the \"family\" of the compiler. Since 0.53.0\nget_linker_id returns a lower case string with the linker name. Since\ncompilers can often choose from multiple linkers depending on operating\nsystem, get_linker_id can be useful for handling or mitigating effects\nof particular linkers.\nThe compiler object also has a method get_argument_syntax which\nreturns a lower case string of gcc, msvc, or another undefined string\nvalue; identifying whether the compiler arguments use the same syntax as\neither gcc or msvc, or that its arguments are not like either. This should\nonly be used to select the syntax of the arguments, such as those to test\nwith has_argument.\nSee reference tables for a list of supported compiler\nids and their argument type.\nSometimes the only way to test the system is to try to compile some\nsample code and see if it works. For example, this can test that a\n\"C++17\" compiler actually supports a particular C++17 feature,\nwithout resorting to maintaining a feature list vs. compiler vendor,\ncompiler version and operating system.\nTesting that a code snippet runs is a two-phase operation. First\nwe define some code using the multiline string operator:\nThen we can run the test.\nThe variable result will now contain either true or false\ndepending on whether the compilation succeeded or not. The keyword\nargument name is optional. If it is specified, Meson will write the\nresult of the check to its log.\nSometimes it is necessary to check whether a certain code fragment not\nonly compiles, but also links successfully, e.g. to check if a symbol\nis actually present in a library. This can be done using the\n'''.links()''' method on a compiler object like this:\nThen we can run the test.\nThe variable result will now contain either true or false\ndepending on whether the compilation and linking succeeded or not. The\nkeyword argument name is optional. If it is specified, Meson will\nwrite the result of the check to its log.\nHere is how you would compile and run a small test application.\nTesting if a code snippets runs versus merely that it links\nis particularly important for some dependencies such as MPI.\nThe result variable encapsulates the state of the test, which can be\nextracted with the following methods. The name keyword argument\nworks the same as with compiles.\nHere is an example usage:\nHeader files provided by different platforms vary quite a lot. Meson\nhas functionality to detect whether a given header file is available\non the system. The test is done by trying to compile a simple test\nprogram that includes the specified header. The following snippet\ndescribes how this feature can be used.\nOften you need to determine the size of a particular element (such as\nint, wchar_t or char*). Using the compiler variable mentioned\nabove, the check can be done like this.\nThis will put the size of wchar_t as reported by sizeof into\nvariable wcharsize. The keyword argument prefix is optional. If\nspecified its contents is put at the top of the source file. This\nargument is typically used for setting #include directives in\nconfiguration files.\nIn older versions (<= 0.30) meson would error out if the size could\nnot be determined. Since version 0.31 it returns -1 if the size could\nnot be determined.\nJust having a header doesn't say anything about its\ncontents. Sometimes you need to explicitly check if some function\nexists. This is how we would check whether the function open_memstream\nexists in header stdio.h\nNote that, on macOS programs can be compiled targeting older macOS\nversions than the one that the program is compiled on. It can't be\nassumed that the OS version that is compiled on matches the OS\nversion that the binary will run on.\nTherefore when detecting function availability with has_function, it\nis important to specify the correct header in the prefix argument.\nIn the example above, the function open_memstream is detected, which\nwas introduced in macOS 10.13. When the user builds on macOS 10.13, but\ntargeting macOS 10.11 (-mmacosx-version-min=10.11), this will correctly\nreport the function as missing. Without the header however, it would lack\nthe necessary availability information and incorrectly report the function\nas available.\nSome platforms have different standard structures. Here's how one\nwould check if a struct called mystruct from header myheader.h\ncontains a member called some_member.\nMost platforms can't access some data types at any address. For\nexample it is common that a char can be at any address but a 32 bit\ninteger only at locations which are divisible by four. Determining the\nalignment of data types is simple.\nThis method tests if the compiler supports a given command line\nargument. This is implemented by compiling a small file with the given\nargument.\nNote: some compilers silently swallow command line arguments they do\nnot understand. Thus this test can not be made 100% reliable.\n\n\n\n Method\n Return value\n\n\n\n\n compiled\n True if compilation succeeded. If false then all other methods return undefined values.\n\n\n returncode\n The return code of the application as an integer\n\n\n stdout\n Program's standard out as text.\n\n\n stderr\n Program's standard error as text.\n\n\n\n"});