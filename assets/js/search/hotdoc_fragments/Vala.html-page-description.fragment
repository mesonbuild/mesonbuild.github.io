fragment_downloaded_cb({"url":"Vala.html#page-description","fragment":"Meson supports compiling applications and libraries written in\nVala and\nGenie . A skeleton meson.build file:\nYou must always specify the glib-2.0 and gobject-2.0 libraries as\ndependencies, because all current Vala applications use them.\nGLib is used for basic data types\nand GObject is used for the\nruntime type system.\nMeson uses the dependency()\nfunction to find the relevant VAPI, C headers and linker flags when it\nencounters a Vala source file in a build target. Vala needs a VAPI\nfile and a C header or headers to use a library. The VAPI file helps\nmap Vala code to the library's C programming interface. It is the\npkg-config\ntool that makes finding these installed files all work seamlessly\nbehind the scenes. When a pkg-config file doesn't exist for the\nlibrary then the find_library()\nmethod of the compiler object\nneeds to be used. Examples are given later.\nNote Vala uses libraries that follow the C Application Binary Interface (C ABI).\nThe library, however, could be written in C, Vala, Rust, Go, C++ or any other\nlanguage that can generate a binary compatible with the C ABI and so provides C\nheaders.\nThis first example is a simple addition to the meson.build file because:\nEverything works seamlessly in the background and only a single extra line is\nneeded:\nGTK+ is the graphical toolkit used by GNOME, elementary OS and other\ndesktop environments. The binding to the library, the VAPI file, is\ndistributed with Vala.\nOther libraries may have a VAPI that is distributed with the library\nitself. Such libraries will have their VAPI file installed along with\ntheir other development files. The VAPI is installed in Vala's\nstandard search path and so works just as seamlessly using the\ndependency() function.\nMeson's dependency() function\nallows a version check of a library. This is often used to check a\nminimum version is installed. When setting a minimum version of GLib,\nMeson will also pass this to the Vala compiler using the\n--target-glib option.\nThis is needed when using GTK+'s user interface definition files with\nVala's [GtkTemplate], [GtkChild] and [GtkCallback] attributes.\nThis requires --target-glib 2.38, or a newer version, to be passed\nto Vala. With Meson this is simply done with:\nUsing [GtkTemplate] also requires the GTK+ user interface definition\nfiles to be built in to the binary as GResources. For completeness,\nthe next example shows this:\nSo far we have covered the cases where the VAPI file is either\ndistributed with Vala or the library. A VAPI can also be included in\nthe source files of your project. The convention is to put it in the\nvapi directory of your project.\nThis is needed when a library does not have a VAPI or your project\nneeds to link to another component in the project that uses the C ABI.\nFor example if part of the project is written in C.\nThe Vala compiler's --vapidir option is used to add the project\ndirectory to the VAPI search path. In Meson this is done with the\nadd_project_arguments() function:\nIf the VAPI is for an external library then make sure that the VAPI\nname corresponds to the pkg-config file name.\nThe vala-extra-vapis\nrepository is a\ncommunity maintained repository of VAPIs that are not distributed.\nDevelopers use the repository to share early work on new bindings and\nimprovements to existing bindings. So the VAPIs can frequently change.\nIt is recommended VAPIs from this repository are copied in to your\nproject's source files.\nThis also works well for starting to write new bindings before they\nare shared with the vala-extra-vapis repository.\nA library that does not have a corresponding pkg-config file may mean\ndependency() is unsuitable for finding the C and Vala interface\nfiles. In this case it is necessary to use the find_library() method\nof the compiler object.\nThe first example uses Vala's POSIX binding. There is no pkg-config\nfile because POSIX includes the standard C library on Unix systems.\nAll that is needed is the VAPI file, posix.vapi. This is included\nwith Vala and installed in Vala's standard search path. Meson just\nneeds to be told to only find the library for the Vala compiler:\nThe next example shows how to link with a C library where no\nadditional VAPI is needed. The standard maths functions are already\nbound in glib-2.0.vapi, but the GNU C library requires linking to\nthe maths library separately. In this example Meson is told to find\nthe library only for the C compiler:\nThe required: false means the build will continue when using another\nC library that does not separate the maths library. See Add math\nlibrary (-lm) portably.\nThe final example shows how to use a library that does not have a\npkg-config file and the VAPI is in the vapi directory of your\nproject source files:\nThe find_library() method of the C compiler object will try to find the C\nheader files and the library to link with.\nThe find_library() method of the Vala compiler object needs to have the dir\nkeyword added to include the project VAPI directory. This is not added\nautomatically by add_project_arguments().\nPassing arguments to Vala's\npreprocessor\nrequires specifying the language as vala. For example, the following\nstatement sets the preprocessor symbol USE_FUSE:\nIf you need to pass an argument to the C pre-processor then specify\nthe language as c. For example to set FUSE_USE_VERSION to 26 use:\nMeson's library target automatically\noutputs the C header and the VAPI. They can be renamed by setting the\nvala_header and vala_vapi arguments respectively:\nIn this example, the second and third elements of the install_dir\narray indicate the destination with true to use default directories\n(i.e. include and share/vala/vapi).\nA 'binding' allows another programming language to use a library\nwritten in Vala. Because Vala uses the GObject type system as its\nruntime type system it is very easy to use introspection to generate a\nbinding. A Meson build of a Vala library can generate the GObject\nintrospection metadata. The metadata is then used in separate projects\nwith language specific\ntools to\ngenerate a binding.\nThe main form of metadata is a GObject Introspection Repository (GIR)\nXML file. GIRs are mostly used by languages that generate bindings at\ncompile time. Languages that generate bindings at runtime mostly use a\ntypelib file, which is generated from the GIR.\nMeson can generate a GIR as part of the build. For a Vala library the\nvala_gir option has to be set for the library:\nThe true value in install_dir tells Meson to use the default\ndirectory (i.e. share/gir-1.0 for GIRs). The fourth element in the\ninstall_dir array indicates where the GIR file will be installed.\nTo then generate a typelib file use a custom target with the\ng-ir-compiler program and a dependency on the library:\n\nthe library has a pkg-config file, gtk+-3.0.pc\n\nthe VAPI is distributed with Vala and so installed with the Vala compiler\nthe VAPI is installed in Vala's standard search path\nthe VAPI, gtk+-3.0.vapi, has the same name as the pkg-config file\n\n"});