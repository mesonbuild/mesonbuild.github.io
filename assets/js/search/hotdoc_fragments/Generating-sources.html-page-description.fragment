fragment_downloaded_cb({"url":"Generating-sources.html#page-description","fragment":"Sometimes source files need to be preprocessed before they are passed\nto the actual compiler. As an example you might want build an IDL\ncompiler and then run some files through that to generate actual\nsource files. In Meson this is done with\ngenerator() or\ncustom_target().\nLet's say you have a build target that must be built using sources\ngenerated by a compiler. The compiler can either be a built target:\nOr an external program provided by the system, or script inside the\nsource tree:\nCustom targets can take zero or more input files and use them to\ngenerate one or more output files. Using a custom target, you can run\nthis compiler at build time to generate the sources:\nThe @INPUT@ there will be transformed to 'somefile1.c' 'file2.c'. Just like the output, you can also refer to each input\nfile individually by index.\nThen you just put that in your program and you're done.\nAdding a generated header to a source list will ensure that the header is\ngenerated and that the proper include paths are created for the target:\nEach target that depends on a generated header should add that header to it's sources,\nas seen above with libfoo and myexe. This is because there is no way for\nmeson or the backend to know that myexe depends on foo.h just because\nlibfoo does, it could be a private header.\nSometimes it makes sense for a single generator to create two or more files at\na time, (perhaps a header and source file), meson has this case covered as\nwell. custom_targets can be indexed like a list to get each output file\nseparately. The order is the same as the order of the output argument to\ncustom_target\nIn this case libfoo depends on both foo.c and foo.h but myexe only\ndepends on foo.h, the second output.\nIn some cases it might be easier to use declare_dependency to \"bundle\" the header\nand library dependency, especially if there are many generated headers:\nSee dependencies, and\nreference for more information.\nGenerators are similar to custom targets, except that we define a\ngenerator, which defines how to transform an input file into one or\nmore output files, and then use that on as many input files as we\nwant.\nNote that generators should only be used for outputs that will only be\nused as inputs for a build target or a custom target. When you use the\nprocessed output of a generator in multiple targets, the generator\nwill be run multiple times to create outputs for each target. Each\noutput will be created in a target-private directory @BUILD_DIR@.\nIf you want to generate files for general purposes such as for\ngenerating headers to be used by several sources, or data that will be\ninstalled, and so on, use a\ncustom_target() instead.\nThe first argument is the executable file to run. The next file\nspecifies a name generation rule. It specifies how to build the output\nfile name for a given input name. @BASENAME@ is a placeholder for\nthe input file name without preceding path or suffix (if any). So if\nthe input file name were some/path/filename.idl, then the output\nname would be filename.c. You can also use @PLAINNAME@, which\npreserves the suffix which would result in a file called\nfilename.idl.c. The last line specifies the command line arguments\nto pass to the executable. @INPUT@ and @OUTPUT@ are placeholders\nfor the input and output files, respectively, and will be\nautomatically filled in by Meson. If your rule produces multiple\noutput files and you need to pass them to the command line, append the\nlocation to the output holder like this: @OUTPUT0@, @OUTPUT1@ and\nso on.\nWith this rule specified we can generate source files and add them to\na target.\nGenerators can also generate multiple output files with unknown names:\nIn this case you can not use the plain @OUTPUT@ variable, as it\nwould be ambiguous. This program only needs to know the output\ndirectory, it will generate the file names by itself.\nTo make passing different additional arguments to the generator\nprogram at each use possible, you can use the @EXTRA_ARGS@ string in\nthe arguments list. Note that this placeholder can only be present\nas a whole string, and not as a substring. The main reason is that it\nrepresents a list of strings, which may be empty, or contain multiple\nelements; and in either case, interpolating it into the middle of a\nsingle string would be troublesome. If there are no extra arguments\npassed in from a process() invocation, the placeholder is entirely\nomitted from the actual list of arguments, so an empty string won't be\npassed to the generator program because of this. If there are multiple\nelements in extra_args, they are inserted into to the actual\nargument list as separate elements.\n"});