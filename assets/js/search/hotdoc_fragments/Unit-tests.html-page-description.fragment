fragment_downloaded_cb({"url":"Unit-tests.html#page-description","fragment":"Meson comes with a fully functional unit test system. To use it simply\nbuild an executable and then use it in a test.\nYou can add as many tests as you want. They are run with the command meson test.\nMeson captures the output of all tests and writes it in the log file\nmeson-logs/testlog.txt.\nSome tests require the use of command line arguments or environment\nvariables. These are simple to define.\nNote how you need to specify multiple values as an array.\nBy default, environment variable\nMALLOC_PERTURB_ is\nset to a random value between 1..255. This can help find memory leaks on\nconfigurations using glibc, including with non-GCC compilers. This feature\ncan be disabled as discussed in test().\nIf you enable coverage measurements by giving Meson the command line\nflag -Db_coverage=true, you can generate coverage reports after\nrunning the tests (running the tests is required to gather the list of\nfunctions that get called). Meson will autodetect what coverage\ngenerator tools you have installed and will generate the corresponding\ntargets. These targets are coverage-xml and coverage-text which\nare both provided by Gcovr (version 3.3 or higher)\nand coverage-html, which requires\nLcov and\nGenHTML or\nGcovr. As a convenience, a high-level coverage\ntarget is also generated which will produce all 3 coverage report\ntypes, if possible.\nThe output of these commands is written to the log directory meson-logs in\nyour build directory.\nTo reduce test times, Meson will by default run multiple unit tests in\nparallel. It is common to have some tests which can not be run in\nparallel because they require unique hold on some resource such as a\nfile or a D-Bus name. You have to specify these tests with a keyword\nargument.\nMeson will then make sure that no other unit test is running at the\nsame time. Non-parallel tests take longer to run so it is recommended\nthat you write your unit tests to be parallel executable whenever\npossible.\nBy default Meson uses as many concurrent processes as there are cores\non the test machine. You can override this with the environment\nvariable MESON_TESTTHREADS like this.\n(added in version 0.52.0)\nTests can be assigned a priority that determines when a test is\nstarted. Tests with higher priority are started first, tests with\nlower priority started later. The default priority is 0, Meson makes\nno guarantee on the ordering of tests with identical priority.\nNote that the test priority only affects the starting order of tests\nand subsequent tests are affected by how long it takes previous tests\nto complete. It is thus possible that a higher-priority test is still\nrunning when lower-priority tests with a shorter runtime have\ncompleted.\nSometimes a test can only determine at runtime that it can not be run.\nFor the default exitcode testing protocol, the GNU standard approach\nin this case is to exit the program with error code 77. Meson will\ndetect this and report these tests as skipped rather than failed. This\nbehavior was added in version 0.37.0.\nFor TAP-based tests, skipped tests should print a single line starting\nwith 1..0 # SKIP.\nIn addition, sometimes a test fails set up so that it should fail even\nif it is marked as an expected failure. The GNU standard approach in\nthis case is to exit the program with error code 99. Again, Meson will\ndetect this and report these tests as ERROR, ignoring the setting of\nshould_fail. This behavior was added in version 0.50.0.\nThe goal of the Meson test tool is to provide a simple way to run\ntests in a variety of different ways. The tool is designed to be run\nin the build directory.\nThe simplest thing to do is just to run all tests.\nFor clarity, consider the meson.build containing:\nSpecify test(s) by name like:\nTests belonging to a suite suite can be run as follows\nSince version 0.46, (sub)project_name can be omitted if it is the\ntop-level project.\nMultiple suites are specified like:\nNOTE: If you choose to specify both suite(s) and specific test\nname(s), the test name(s) must be contained in the suite(s). This\nhowever is redundant-- it would be more useful to specify either\nspecific test names or suite(s).\nSometimes you need to run the tests multiple times, which is done like this:\nInvoking tests via a helper executable such as Valgrind can be done with the\n--wrap argument\nArguments to the wrapper binary can be given like this:\nMeson also supports running the tests under GDB. Just doing this:\nMeson will launch gdb all set up to run the test. Just type run in\nthe GDB command prompt to start the program.\nThe second use case is a test that segfaults only rarely. In this case\nyou can invoke the following command:\nThis runs the test up to 10 000 times under GDB automatically. If the\nprogram crashes, GDB will halt and the user can debug the application.\nNote that testing timeouts are disabled in this case so meson test\nwill not kill gdb while the developer is still debugging it. The\ndownside is that if the test binary freezes, the test runner will wait\nforever.\nSometimes, the GDB binary is not in the PATH variable or the user\nwants to use a GDB replacement. Therefore, the invoked GDB program can\nbe specified (added 0.52.0):\nMeson will report the output produced by the failing tests along with\nother useful information as the environmental variables. This is\nuseful, for example, when you run the tests on Travis-CI, Jenkins and\nthe like.\nFor further information see the command line help of Meson by running\nmeson test -h.\nIf meson test does not work for you, you likely have a old version\nof Meson. In that case you should call mesontest instead. If\nmesontest doesn't work either you have a very old version prior to\n0.37.0 and should upgrade.\nMeson will write several different files with detailed results of\nrunning tests. These will be written into $builddir/meson-logs/\nThis is not a proper json file, but a file containing one valid json\nobject per line. This is file is designed so each line is streamed out\nas each test is run, so it can be read as a stream while the test\nharness is running\nThis is a valid JUnit XML description of all tests run. It is not\nstreamed out, and is written only once all tests complete running.\nWhen tests use the tap protocol each test will be recorded as a\ntestsuite container, with each case named by the number of the result.\nWhen tests use the gtest protocol Meson will inject arguments to the\ntest to generate it's own JUnit XML, which Meson will include as part\nof this XML file.\nNew in 0.55.0\n"});