fragment_downloaded_cb({"url":"Cross-compilation.html#page-description","fragment":"Meson has full support for cross compilation. Since cross compiling is\nmore complicated than native building, let's first go over some\nnomenclature. The three most important definitions are traditionally\ncalled build, host and target. This is confusing because those\nterms are used for quite many different things. To simplify the issue,\nwe are going to call these the build machine, host machine and\ntarget machine. Their definitions are the following:\nThe tl/dr summary is the following: if you are doing regular cross\ncompilation, you only care about build_machine and\nhost_machine. Just ignore target_machine altogether and you will\nbe correct 99% of the time. Only compilers and similar tools care\nabout the target machine. In fact, for so-called \"multi-target\" tools\nthe target machine need not be fixed at build-time like the others but\nchosen at runtime, so target_machine still doesn't matter. If your\nneeds are more complex or you are interested in the actual details, do\nread on.\nThis might be easier to understand through examples. Let's start with\nthe regular, not cross-compiling case. In these cases all of these\nthree machines are the same. Simple so far.\nLet's next look at the most common cross-compilation setup. Let's\nsuppose you are on a 64 bit OSX machine and you are cross compiling a\nbinary that will run on a 32 bit ARM Linux board. In this case your\nbuild machine is 64 bit OSX, your host machine is 32 bit ARM Linux\nand your target machine is irrelevant (but defaults to the same value\nas the host machine). This should be quite understandable as well.\nThe usual mistake in this case is to call the OSX system the host and\nthe ARM Linux board the target. That's because these were their actual\nnames when the cross-compiler itself was compiled!  Let's assume the\ncross-compiler was created on OSX too. When that happened the build\nand host machines were the same OSX and different from the ARM Linux\ntarget machine.\nIn a nutshell, the typical mistake assumes that the terms build,\nhost and target refer to some fixed positions whereas they're\nactually relative to where the current compiler is running. Think of\nhost as a child of the current compiler and target as an optional\ngrand-child. Compilers don't change their terminology when they're\ncreating another compiler, that would at the very least make their user\ninterface much more complex.\nThe most complicated case is when you cross-compile a cross\ncompiler. As an example you can, on a Linux machine, generate a cross\ncompiler that runs on Windows but produces binaries on MIPS Linux. In\nthis case build machine is x86 Linux, host machine is x86 Windows\nand target machine is MIPS Linux. This setup is known as the\nCanadian\nCross. As\na side note, be careful when reading cross compilation articles on\nWikipedia or the net in general. It is very common for them to get\nbuild, host and target mixed up, even in consecutive sentences, which\ncan leave you puzzled until you figure it out.\nAgain note that when you cross-compile something,\nthe 3 systems (build, host, and target) used when\nbuilding the cross compiler don't align with the ones used when\nbuilding something with that newly-built cross compiler. To take our\nCanadian Cross scenario from above (for full generality), since its\nhost machine is x86 Windows, the build machine of anything we\nbuild with it is x86 Windows. And since its target machine is MIPS\nLinux, the host machine of anything we build with it is MIPS\nLinux. Only the target machine of whatever we build with it can be\nfreely chosen by us, say if we want to build another cross compiler\nthat runs on MIPS Linux and targets Aarch64 iOS. As this example\nhopefully makes clear to you, the machine names are relative and\nshifted over to the left by one position.\nIf you did not understand all of the details, don't worry. For most\npeople it takes a while to wrap their head around these\nconcepts. Don't panic, it might take a while to click, but you will\nget the hang of it eventually.\nMeson requires you to write a cross build definition file. It defines\nvarious properties of the cross build environment. The cross file\nconsists of different sections.\nThere are a number of options shared by cross and native files,\nhere. It is assumed that you have read that section already,\nas this documentation will only call out options specific to cross files.\nThe exe_wrapper option defines a wrapper command that can be used to run\nexecutables for this host. In this case we can use Wine, which runs Windows\napplications on Linux. Other choices include running the application with\nqemu or a hardware simulator. If you have this kind of a wrapper, these lines\nare all you need to write. Meson will automatically use the given wrapper\nwhen it needs to run host binaries. This happens e.g. when running the\nproject's test suite.\nIn addition to the properites allowed in all machine\nfiles, the cross file may contain specific\ninformation about the cross compiler or the host machine. It looks like this:\nIn most cases you don't need the size and alignment settings, Meson\nwill detect all these by compiling and running some sample\nprograms. If your build requires some piece of data that is not listed\nhere, Meson will stop and write an error message describing how to fix\nthe issue. If you need extra compiler arguments to be used during\ncross compilation you can set them with [langname]_args = [args]. Just remember to specify the args as an array and not as a\nsingle string (i.e. not as '-DCROSS=1 -DSOMETHING=3').\nSince 0.52.0 The sys_root property may point to the root of the host\nsystem path (the system that will run the compiled binaries). This is used\ninternally by Meson to set the PKG_CONFIG_SYSROOT_DIR environment variable\nfor pkg-config. If this is unset the host system is assumed to share a root\nwith the build system.\nSince 0.54.0 The pkg_config_libdir property may point to a list of path used\ninternally by Meson to set the PKG_CONFIG_LIBDIR environment variable for pkg-config.\nThis prevents pkg-config from searching cross dependencies in system directories.\nOne important thing to note, if you did not define an exe_wrapper in\nthe previous section, is that Meson will make a best-effort guess at\nwhether it can run the generated binaries on the build machine. It\ndetermines whether this is possible by looking at the system and\ncpu_family of build vs host. There will however be cases where they\ndo match up, but the build machine is actually not compatible with the\nhost machine. Typically this will happen if the libc used by the build\nand host machines are incompatible, or the code relies on kernel\nfeatures not available on the build machine. One concrete example is a\nmacOS build machine producing binaries for an iOS Simulator x86-64\nhost. They're both darwin and the same architecture, but their\nbinaries are not actually compatible. In such cases you may use the\nneeds_exe_wrapper property to override the auto-detection:\nThe next bit is the definition of host and target machines. Every\ncross build definition must have one or both of them. If it had\nneither, the build would not be a cross build but a native build. You\ndo not need to define the build machine, as all necessary information\nabout it is extracted automatically. The definitions for host and\ntarget machines look the same. Here is a sample for host machine.\nThese values define the machines sufficiently for cross compilation\npurposes. The corresponding target definition would look the same but\nhave target_machine in the header. These values are available in\nyour Meson scripts. There are three predefined variables called,\nsurprisingly, build_machine, host_machine and\ntarget_machine. Determining the operating system of your host\nmachine is simply a matter of calling host_machine.system().\nThere are two different values for the CPU. The first one is cpu_family. It\nis a general type of the CPU. This should have a value from the CPU Family\ntable. Note that meson does not add\nel to end cpu_family value for little endian systems. Big endian and little\nendian mips are both just mips, with the endian field set approriately.\nThe second value is cpu which is\na more specific subtype for the CPU. Typical values for a x86 CPU family\nmight include i386 or i586 and for arm family armv5 or armv7hl.\nNote that CPU type strings are very system dependent. You might get a\ndifferent value if you check its value on the same machine but with different\noperating systems.\nIf you do not define your host machine, it is assumed to be the build\nmachine. Similarly if you do not specify target machine, it is assumed\nto be the host machine.\nOnce you have the cross file, starting a build is simple\nOnce configuration is done, compilation is started by invoking Ninja\nin the usual way.\nThe main meson object provides two functions to determine cross\ncompilation status.\nNote that the latter gives undefined return value when doing a native\nbuild.\nYou can run system checks on both the system compiler or the cross\ncompiler. You just have to specify which one to use.\nSometimes you need to build a tool which is used to generate source\nfiles. These are then compiled for the actual target. For this you\nwould want to build some targets with the system's native\ncompiler. This requires only one extra keyword argument.\nYou can then take native_exe and use it as part of a generator rule or anything else you might want.\nSometimes in cross compilation you need to build your own standard\nlibrary instead of using the one provided by the compiler. Meson has\nbuilt-in support for switching standard libraries transparently. The\ninvocation to use in your cross file is the following:\nThis specifies that C standard library is provided in the Meson\nsubproject mylibc in internal dependency variable mylibc_dep. It\nis used on every cross built C target in the entire source tree\n(including subprojects) and the standard library is disabled. The\nbuild definitions of these targets do not need any modification.\nCross file settings are only read when the build directory is set up\nthe first time. Any changes to them after the fact will be\nignored. This is the same as regular compiles where you can't change\nthe compiler once a build tree has been set up. If you need to edit\nyour cross file, then you need to wipe your build tree and recreate it\nfrom scratch.\nYou can store arbitrary data in properties and access them from your\nMeson files. As an example if you cross file has this:\nthen you can access that using the meson object like this:\nAs of version 0.44.0 meson supports loading cross files from system locations\n(except on Windows).  This will be $XDG_DATA_DIRS/meson/cross, or if\nXDG_DATA_DIRS is undefined, then /usr/local/share/meson/cross and\n/usr/share/meson/cross will be tried in that order, for system wide cross\nfiles. User local files can be put in $XDG_DATA_HOME/meson/cross, or\n~/.local/share/meson/cross if that is undefined.\nThe order of locations tried is as follows:\nDistributions are encouraged to ship cross files either with\ntheir cross compiler toolchain packages or as a standalone package, and put\nthem in one of the system paths referenced above.\nThese files can be loaded automatically without adding a path to the cross\nfile. For example, if a ~/.local/share/meson/cross contains a file called x86-linux,\nthen the following command would start a cross build using that cross files:\n\n\nbuild machine is the computer that is doing the actual compiling.\n\nhost machine is the machine on which the compiled binary will run.\n\ntarget machine is the machine on which the compiled binary's\noutput will run, only meaningful if the program produces\nmachine-specific output.\n\n\nA file relative to the local dir\nThe user local location\nThe system wide locations in order\n\n"});