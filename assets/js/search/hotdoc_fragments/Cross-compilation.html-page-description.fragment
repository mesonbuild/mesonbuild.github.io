fragment_downloaded_cb({"url":"Cross-compilation.html#page-description","fragment":"Meson has full support for cross compilation. Since cross compiling is\nmore complicated than native building, let's first go over some\nnomenclature. The three most important definitions are traditionally\ncalled build, host and target. This is confusing because those\nterms are used for quite many different things. To simplify the issue,\nwe are going to call these the build machine, host machine and\ntarget machine. Their definitions are the following:\nThe tl/dr summary is the following: if you are doing regular cross\ncompilation, you only care about build_machine and\nhost_machine. Just ignore target_machine altogether and you will\nbe correct 99% of the time. Only compilers and similar tools care\nabout the target machine. In fact, for so-called \"multi-target\" tools\nthe target machine need not be fixed at build-time like the others but\nchosen at runtime, so target_machine still doesn't matter. If your\nneeds are more complex or you are interested in the actual details, do\nread on.\nThis might be easier to understand through examples. Let's start with\nthe regular, not cross-compiling case. In these cases all of these\nthree machines are the same. Simple so far.\nLet's next look at the most common cross-compilation setup. Let's\nsuppose you are on a 64 bit OSX machine and you are cross compiling a\nbinary that will run on a 32 bit ARM Linux board. In this case your\nbuild machine is 64 bit OSX, your host machine is 32 bit ARM Linux\nand your target machine is irrelevant (but defaults to the same\nvalue as the host machine). This should be quite understandable as\nwell.\nThe usual mistake in this case is to call the OSX system the host\nand the ARM Linux board the target. That's because these were their\nactual names when the cross-compiler itself was compiled! Let's assume\nthe cross-compiler was created on OSX too. When that happened the\nbuild and host machines were the same OSX and different from the\nARM Linux target machine.\nIn a nutshell, the typical mistake assumes that the terms build,\nhost and target refer to some fixed positions whereas they're\nactually relative to where the current compiler is running. Think of\nhost as a child of the current compiler and target as an\noptional grand-child. Compilers don't change their terminology when\nthey're creating another compiler, that would at the very least make\ntheir user interface much more complex.\nThe most complicated case is when you cross-compile a cross compiler.\nAs an example you can, on a Linux machine, generate a cross compiler\nthat runs on Windows but produces binaries on MIPS Linux. In this case\nbuild machine is x86 Linux, host machine is x86 Windows and\ntarget machine is MIPS Linux. This setup is known as the Canadian\nCross.\nAs a side note, be careful when reading cross compilation articles on\nWikipedia or the net in general. It is very common for them to get\nbuild, host and target mixed up, even in consecutive sentences, which\ncan leave you puzzled until you figure it out.\nAgain note that when you cross-compile something, the 3 systems\n(build, host, and target) used when building the cross compiler\ndon't align with the ones used when building something with that\nnewly-built cross compiler. To take our Canadian Cross scenario from\nabove (for full generality), since its host machine is x86 Windows,\nthe build machine of anything we build with it is x86 Windows. And\nsince its target machine is MIPS Linux, the host machine of\nanything we build with it is MIPS Linux. Only the target machine\nof whatever we build with it can be freely chosen by us, say if we\nwant to build another cross compiler that runs on MIPS Linux and\ntargets Aarch64 iOS. As this example hopefully makes clear to you, the\nmachine names are relative and shifted over to the left by one\nposition.\nIf you did not understand all of the details, don't worry. For most\npeople it takes a while to wrap their head around these concepts.\nDon't panic, it might take a while to click, but you will get the hang\nof it eventually.\nMeson requires you to write a cross build definition file. It defines\nvarious properties of the cross build environment. The cross file\nconsists of different sections.\nThere are a number of options shared by cross and native files,\nhere. It is assumed that you have read that\nsection already, as this documentation will only call out options\nspecific to cross files.\nThe exe_wrapper option defines a wrapper command that can be used\nto run executables for this host. In this case we can use Wine, which\nruns Windows applications on Linux. Other choices include running the\napplication with qemu or a hardware simulator. If you have this kind\nof a wrapper, these lines are all you need to write. Meson will\nautomatically use the given wrapper when it needs to run host\nbinaries. This happens e.g. when running the project's test suite.\nIn addition to the properties allowed in all machine\nfiles, the cross file may contain\nspecific information about the cross compiler or the host machine. It\nlooks like this:\nIn most cases you don't need the size and alignment settings, Meson\nwill detect all these by compiling and running some sample programs.\nIf your build requires some piece of data that is not listed here,\nMeson will stop and write an error message describing how to fix the\nissue. If you need extra compiler arguments to be used during cross\ncompilation you can set them with [langname]_args = [args]. Just\nremember to specify the args as an array and not as a single string\n(i.e. not as '-DCROSS=1 -DSOMETHING=3').\nSince 0.52.0 The sys_root property may point to the root of the\nhost system path (the system that will run the compiled binaries).\nThis is used internally by Meson to set the PKG_CONFIG_SYSROOT_DIR\nenvironment variable for pkg-config. If this is unset the host system\nis assumed to share a root with the build system.\nSince 0.54.0 The pkg_config_libdir property may point to a list of\npath used internally by Meson to set the PKG_CONFIG_LIBDIR environment\nvariable for pkg-config. This prevents pkg-config from searching cross\ndependencies in system directories.\nOne important thing to note, if you did not define an exe_wrapper in\nthe previous section, is that Meson will make a best-effort guess at\nwhether it can run the generated binaries on the build machine. It\ndetermines whether this is possible by looking at the system and\ncpu_family of build vs host. There will however be cases where they\ndo match up, but the build machine is actually not compatible with the\nhost machine. Typically this will happen if the libc used by the build\nand host machines are incompatible, or the code relies on kernel\nfeatures not available on the build machine. One concrete example is a\nmacOS build machine producing binaries for an iOS Simulator x86-64\nhost. They're both darwin and the same architecture, but their\nbinaries are not actually compatible. In such cases you may use the\nneeds_exe_wrapper property to override the auto-detection:\nThe next bit is the definition of host and target machines. Every\ncross build definition must have one or both of them. If it had\nneither, the build would not be a cross build but a native build. You\ndo not need to define the build machine, as all necessary information\nabout it is extracted automatically. The definitions for host and\ntarget machines look the same. Here is a sample for host machine.\nThese values define the machines sufficiently for cross compilation\npurposes. The corresponding target definition would look the same but\nhave target_machine in the header. These values are available in\nyour Meson scripts. There are three predefined variables called,\nsurprisingly, build_machine, host_machine and target_machine.\nDetermining the operating system of your host machine is simply a\nmatter of calling host_machine.system().\nThere are two different values for the CPU. The first one is\ncpu_family. It is a general type of the CPU. This should have a\nvalue from the CPU Family table.\nNote that Meson does not add el to end cpu_family value for little\nendian systems. Big endian and little endian mips are both just\nmips, with the endian field set approriately.\nThe second value is cpu which is a more specific subtype for the\nCPU. Typical values for a x86 CPU family might include i386 or\ni586 and for arm family armv5 or armv7hl. Note that CPU type\nstrings are very system dependent. You might get a different value if\nyou check its value on the same machine but with different operating\nsystems.\nIf you do not define your host machine, it is assumed to be the build\nmachine. Similarly if you do not specify target machine, it is assumed\nto be the host machine.\nOnce you have the cross file, starting a build is simple\nOnce configuration is done, compilation is started by invoking meson compile\nin the usual way.\nThe main meson object provides two functions to determine cross\ncompilation status.\nYou can run system checks on both the system compiler or the cross\ncompiler. You just have to specify which one to use.\nSometimes you need to build a tool which is used to generate source\nfiles. These are then compiled for the actual target. For this you\nwould want to build some targets with the system's native compiler.\nThis requires only one extra keyword argument.\nYou can then take native_exe and use it as part of a generator rule or anything else you might want.\nSometimes in cross compilation you need to build your own standard\nlibrary instead of using the one provided by the compiler. Meson has\nbuilt-in support for switching standard libraries transparently. The\ninvocation to use in your cross file is the following:\nThis specifies that C standard library is provided in the Meson\nsubproject mylibc in internal dependency variable mylibc_dep. It\nis used on every cross built C target in the entire source tree\n(including subprojects) and the standard library is disabled. The\nbuild definitions of these targets do not need any modification.\nNote that it is supported for any language, not only c, using <lang>_stdlib\nproperty.\nSince 0.56.0 the variable name parameter is no longer required as long as the\nsubproject calls meson.override_dependency('c_stdlib', mylibc_dep).\nThe above example becomes:\nCross file settings are only read when the build directory is set up\nthe first time. Any changes to them after the fact will be ignored.\nThis is the same as regular compiles where you can't change the\ncompiler once a build tree has been set up. If you need to edit your\ncross file, then you need to wipe your build tree and recreate it from\nscratch.\nYou can store arbitrary data in properties and access them from your\nMeson files. As an example if you cross file has this:\nthen you can access that using the meson object like this:\nAs of version 0.44.0 Meson supports loading cross files from system\nlocations (except on Windows). This will be\n$XDG_DATA_DIRS/meson/cross, or if XDG_DATA_DIRS is undefined, then\n/usr/local/share/meson/cross and /usr/share/meson/cross will be tried\nin that order, for system wide cross files. User local files can be\nput in $XDG_DATA_HOME/meson/cross, or ~/.local/share/meson/cross if\nthat is undefined.\nThe order of locations tried is as follows:\nDistributions are encouraged to ship cross files either with their\ncross compiler toolchain packages or as a standalone package, and put\nthem in one of the system paths referenced above.\nThese files can be loaded automatically without adding a path to the\ncross file. For example, if a ~/.local/share/meson/cross contains a\nfile called x86-linux, then the following command would start a cross\nbuild using that cross files:\n\n\nbuild machine is the computer that is doing the actual compiling.\n\nhost machine is the machine on which the compiled binary will run.\n\ntarget machine is the machine on which the compiled binary's\noutput will run, only meaningful if the program produces\nmachine-specific output.\n\n\nA file relative to the local dir\nThe user local location\nThe system wide locations in order\n\n"});