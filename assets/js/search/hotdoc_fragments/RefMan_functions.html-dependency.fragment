fragment_downloaded_cb({"url":"RefMan_functions.html#dependency","fragment":"dependency()\nFinds an external dependency (usually a library installed on your\nsystem) with the given name with pkg-config and with\nCMake if pkg-config fails. Additionally,\nframeworks (OSX only) and library-specific fallback detection\nlogic\nare also supported.\nSince 0.60.0 more than one name can be provided, they will be tried in order\nand the first name to be found will be used. The fallback subproject will be\nused only if none of the names are found on the system. Once one of the name has\nbeen found, all other names are added into the cache so subsequent calls for any\nof those name will return the same value. This is useful in case a dependency\ncould have different names, such as png and libpng.\nDependencies can also be resolved in two other ways:\nif the same name was used in a meson.override_dependency prior to\nthe call to dependency, the overriding dependency will be returned\nunconditionally; that is, the overriding dependency will be used\nindependent of whether an external dependency is installed in the system.\nTypically, meson.override_dependency will have been used by a\nsubproject.\nby a fallback subproject which, if needed, will be brought into the current\nbuild specification as if subproject() had been called.\nThe subproject can be specified with the fallback argument.  Alternatively,\nif the fallback argument is absent, since 0.55.0 Meson can\nautomatically identify a subproject as a fallback if a wrap file\nprovides the\ndependency, or if a subproject has the same name as the dependency.\nIn the latter case, the subproject must use meson.override_dependency to\nspecify the replacement, or Meson will report a hard error.  See the\nWrap documentation\nfor more details.  This automatic search can be controlled using the\nallow_fallback keyword argument.\nIf dependency_name is '', the dependency is always not found. So\nwith required: false, this always returns a dependency object for\nwhich the found() method returns false, and which can be passed\nlike any other dependency to the dependencies: keyword argument of a\nbuild_target. This can be used to implement a dependency which is\nsometimes not required e.g. in some branches of a conditional, or with\na fallback: kwarg, can be used to declare an optional dependency\nthat only looks in the specified subproject, and only if that's\nallowed by --wrap-mode.\nThe returned object dep also has additional methods.\n\nThis function supports additional library-specific keyword arguments that may also be accepted (e.g. modules specifies submodules to use for dependencies such as Qt5 or Boost. components allows the user to manually add CMake COMPONENTS for the find_package lookup)\n\n\n\nif the same name was used in a meson.override_dependency prior to\nthe call to dependency, the overriding dependency will be returned\nunconditionally; that is, the overriding dependency will be used\nindependent of whether an external dependency is installed in the system.\nTypically, meson.override_dependency will have been used by a\nsubproject.\n\n\nby a fallback subproject which, if needed, will be brought into the current\nbuild specification as if subproject() had been called.\nThe subproject can be specified with the fallback argument.  Alternatively,\nif the fallback argument is absent, since 0.55.0 Meson can\nautomatically identify a subproject as a fallback if a wrap file\nprovides the\ndependency, or if a subproject has the same name as the dependency.\nIn the latter case, the subproject must use meson.override_dependency to\nspecify the replacement, or Meson will report a hard error.  See the\nWrap documentation\nfor more details.  This automatic search can be controlled using the\nallow_fallback keyword argument.\n\n\n"});