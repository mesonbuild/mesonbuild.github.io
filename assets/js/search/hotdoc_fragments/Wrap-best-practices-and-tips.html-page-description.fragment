fragment_downloaded_cb({"url":"Wrap-best-practices-and-tips.html#page-description","fragment":"There are several things you need to take into consideration when\nwriting a Meson build definition for a project. This is especially\ntrue when the project will be used as a subproject. This page lists a\nfew things to consider when writing your definitions.\nMany projects use a config.h header file that they use for\nconfiguring their project internally. These files are never installed\nto the system header files so there are no inclusion collisions. This\nis not the case with subprojects, your project tree may have an\narbitrary number of configuration files, so we need to ensure they\ndon't clash.\nThe basic problem is that the users of the subproject must be able to\ninclude subproject headers without seeing its config.h file. The\nmost correct solution is to rename the config.h file into something\nunique, such as foobar-config.h. This is usually not feasible unless\nyou are the maintainer of the subproject in question.\nThe pragmatic solution is to put the config header in a directory that\nhas no other header files and then hide that from everyone else. One\nway is to create a top level subdirectory called internal and use\nthat to build your own sources, like this:\nMany projects keep their config.h in the top level directory that\nhas no other source files in it. In that case you don't need to move\nit but can just do this instead:\nSome platforms (e.g. iOS) requires linking everything in your main app\nstatically. In other cases you might want shared libraries. They are\nalso faster during development due to Meson's relinking optimization.\nHowever building both library types on all builds is slow and\nwasteful.\nYour project should use the library method that can be toggled\nbetween shared and static with the default_library builtin option.\nMeson's Ninja backend works differently from Make and other\nsystems. Rather than processing things directory per directory, it\nlooks at the entire build definition at once and runs the individual\ncompile jobs in what might look to the outside as a random order.\nThe reason for this is that this is much more efficient so your builds\nfinish faster. The downside is that you have to be careful with your\ndependencies. The most common problem here is headers that are\ngenerated at compile time with e.g. code generators. If these headers\nare needed when building code that uses these libraries, the compile\njob might be run before the code generation step. The fix is to make\nthe dependency explicit like this:\nAnd then you can use the dependency in the usual way:\nMeson will ensure that the header file has been built before compiling main.c.\nThe main use for the sources argument in declare_dependency is to\nconstruct the correct dependency graph for the backends, as\ndemonstrated in the previous section. It is extremely important to\nnote that it should not be used to directly expose compilable\nsources (.c, .cpp, etc.) of dependencies, and should rather only\nbe used for header/config files. The following example will illustrate\nwhat can go wrong if you accidentally expose compilable source files.\nSo you've read about unity builds and how Meson natively supports\nthem. You decide to expose the sources of dependencies in order to\nhave unity builds that include their dependencies. For your support\nlibrary you do\nAnd for your main project you do:\nThis is extremely dangerous. When building, mylibrary will build and\nlink the support sources my_support_sources into the resulting\nshared library. Then, for myexe, these same support sources will be\ncompiled again, will be linked into the resulting executable, in\naddition to them being already present in mylibrary. This can\nquickly run afoul of the One Definition Rule\n(ODR) in C++, as\nyou have more than one definition of a symbol, yielding undefined\nbehavior. While C does not have a strict ODR rule, there is no\nlanguage in the standard which guarantees such behavior to work.\nViolations of the ODR can lead to weird idiosyncratic failures such as\nsegfaults. In the overwhelming number of cases, exposing library\nsources via the sources argument in declare_dependency is thus\nincorrect. If you wish to get full cross-library performance, consider\nbuilding mysupportlib as a static library instead and employing LTO.\nThere are exceptions to this rule. If there are some natural\nconstraints on how your library is to be used, you can expose sources.\nFor instance, the WrapDB module for GoogleTest directly exposes the\nsources of GTest and GMock. This is valid, as GTest and GMock will\nonly ever be used in terminal link targets. A terminal target is the\nfinal target in a dependency link chain, for instance myexe in the\nlast example, whereas mylibrary is an intermediate link target. For\nmost libraries this rule is not applicable though, as you cannot in\ngeneral control how others consume your library, and as such should\nnot expose sources.\n"});