fragment_downloaded_cb({"fragment": "Defining the environment \nMeson requires you to write a cross build definition file. It defines various properties of the cross build environment. The cross file consists of different sections. The first one is the list of executables that we are going to use. A sample snippet might look like this \nThe entries are pretty self explanatory but the last line is special. It defines a wrapper command that can be used to run executables for this host. In this case we can use Wine which runs Windows applications on Linux. Other choices include running the application with qemu or a hardware simulator. If you have this kind of a wrapper these lines are all you need to write. Meson will automatically use the given wrapper when it needs to run host binaries. This happens e.g. when running the project s test suite. \nThe next section lists properties of the cross compiler and thus of the target system. It looks like this \nIn most cases you don t need the size and alignment settings Meson will detect all these by compiling and running some sample programs. If your build requires some piece of data that is not listed here Meson will stop and write an error message describing how to fix the issue. If you need extra compiler arguments to be used during cross compilation you can set them with langname _args args Just remember to specify the args as an array and not as a single string i.e. not as DCROSS DSOMETHING \nOne important thing to note if you did not define an exe_wrapper in the previous section is that Meson will make a best effort guess at whether it can run the generated binaries on the build machine. It determines whether this is possible by looking at the system and cpu_family of build vs host. There will however be cases where they do match up but the build machine is actually not compatible with the host machine. Typically this will happen if the libc used by the build and host machines are incompatible or the code relies on kernel features not available on the build machine. One concrete example is a macOS build machine producing binaries for an iOS Simulator x86 host. They re both darwin and the same architecture but their binaries are not actually compatible. In such cases you may use the needs_exe_wrapper property to override the auto detection \nThe last bit is the definition of host and target machines. Every cross build definition must have one or both of them. If it had neither the build would not be a cross build but a native build. You do not need to define the build machine as all necessary information about it is extracted automatically. The definitions for host and target machines look the same. Here is a sample for host machine. \nThese values define the machines sufficiently for cross compilation purposes. The corresponding target definition would look the same but have target_machine in the header. These values are available in your Meson scripts. There are three predefined variables called surprisingly build_machine host_machine and target_machine. Determining the operating system of your host machine is simply a matter of calling host_machine.system \nThere are two different values for the CPU. The first one is cpu_family. It is a general type of the CPU. Common values might include x86 arm or x86_64. The second value is cpu which is a more specific subtype for the CPU. Typical values for a x86 CPU family might include i386 or i586 and for arm family armv5 or armv7hl. Note that CPU type strings are very system dependent. You might get a different value if you check its value on the same machine but with different operating systems. \nIf you do not define your host machine it is assumed to be the build machine. Similarly if you do not specify target machine it is assumed to be the host machine. \n", "url": "Cross-compilation.html#defining-the-environment"});