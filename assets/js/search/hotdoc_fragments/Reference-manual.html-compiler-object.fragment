fragment_downloaded_cb({"url": "Reference-manual.html#compiler-object", "fragment": "compiler object \nThis object is returned by meson.get_compiler lang It represents a compiler for a given language and allows you to query its properties. It has the following methods \nThe following keyword arguments can be used \nname the name to use for printing a message about the compiler check. Supported by the methods compiles links and run If this keyword argument is not passed to those methods no message will be printed about the check. \nprefix can be used to add includes and other things that are required for the symbol to be declared. System definitions should be passed via compiler args eg _GNU_SOURCE is often required for some symbols to be exposed on Linux and it should be passed via args keyword argument see below Supported by the methods sizeof has_type has_function has_member has_members has_header_symbol. \ninclude_directories specifies extra directories for header searches. added \nargs can be used to pass a list of compiler arguments that are required to find the header or symbol. For example you might need to pass the include path Isome path to header if a header is not in the default include path. In versions newer than you should use the include_directories keyword described above. You may also want to pass a library name lfoo for has_function to check for a function. Supported by all methods except get_id version and find_library. \nNote that if you have a single prefix with all your dependencies you might find it easier to append to the environment variables C_INCLUDE_PATH with GCC Clang and INCLUDE with MSVC to expand the default include path and LIBRARY_PATH with GCC Clang and LIB with MSVC to expand the default library search path. \nHowever with GCC these variables will be ignored when cross compiling. In that case you need to use a specs file. See http www.mingw.org wiki SpecsFileHOWTO \n"});