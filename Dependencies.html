<!DOCTYPE html>
<html lang="en">
<head>

<base href=".">

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>Dependencies</title>

<link rel="stylesheet" href="assets/css/custom_bootstrap.css" type="text/css">
<link rel="stylesheet" href="assets/css/bootstrap-toc.min.css" type="text/css">
<link rel="stylesheet" href="assets/css/frontend.css" type="text/css">
<link rel="stylesheet" href="assets/css/jquery.mCustomScrollbar.min.css">
<link rel="stylesheet" href="assets/js/search/enable_search.css" type="text/css">

<link rel="stylesheet" href="assets/css/prism-tomorrow.css" type="text/css">

<script src="assets/js/mustache.min.js"></script>
<script src="assets/js/jquery.js"></script>
<script src="assets/js/scrollspy.js"></script>
<script src="assets/js/bootstrap.js"></script>
<script src="assets/js/typeahead.jquery.min.js"></script>
<script src="assets/js/search.js"></script>
<script src="assets/js/isotope.pkgd.min.js"></script>
<script src="assets/js/compare-versions.js"></script>
<script src="assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
<script src="assets/js/bootstrap-toc.min.js"></script>
<script src="assets/js/jquery.touchSwipe.min.js"></script>
<script src="assets/js/anchor.min.js"></script>
<script src="assets/js/tag_filtering.js"></script>
<script src="assets/js/language_switching.js"></script>

<script src="assets/js/lines_around_headings.js"></script>

<script src="assets/js/trie.js"></script>
<script src="assets/js/prism-core.js"></script>
<script src="assets/js/prism-autoloader.js"></script>
<script src="assets/js/prism_autoloader_path_override.js"></script>

<link rel="icon" type="image/png" href="assets/images/favicon.png">
<link rel="shortcut icon" href="assets/images/favicon.png">

</head>

<body class="no-script
" data-spy="scroll" data-target="#toc" data-offset="70">

<script>
$('body').removeClass('no-script');
</script>

<nav class="navbar navbar-fixed-top navbar-default" id="topnav">
	<div class="container-fluid">
		<div class="navbar-right">
			<a id="toc-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-wrapper" aria-expanded="false">
				<span class="sr-only">Toggle navigation</span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
				<span class="icon-bar"></span>
			</button>
			<form class="navbar-form pull-right" id="navbar-search-form">
                               <div class="form-group has-feedback">
                                       <input type="text" class="form-control input-sm" name="search" id="sidenav-lookup-field" placeholder="search" disabled>
				       <span class="glyphicon glyphicon-search form-control-feedback" id="search-mgn-glass"></span>
                               </div>
                        </form>
		</div>
		<div class="navbar-header">
			<a id="sidenav-toggle">
				<span class="glyphicon glyphicon-menu-right"></span>
				<span class="glyphicon glyphicon-menu-left"></span>
			</a>
			<a id="home-link" href="index.html" class="hotdoc-navbar-brand">
				<img src="assets/images/meson_logo.png" alt="Home">
			</a>
		</div>
		<div class="navbar-collapse collapse" id="navbar-wrapper">
			<ul class="nav navbar-nav" id="menu">
				
<li class="dropdown">
  <a class="dropdown-toggle" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
    Modules <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" id="modules-menu">
			<li>
				<a href="CMake-module.html">CMake</a>
			</li>
					<li>
				<a href="Cuda-module.html">CUDA</a>
			</li>
					<li>
				<a href="Dlang-module.html">Dlang</a>
			</li>
					<li>
				<a href="Fs-module.html">Filesystem</a>
			</li>
					<li>
				<a href="Gnome-module.html">GNOME</a>
			</li>
					<li>
				<a href="Hotdoc-module.html">Hotdoc</a>
			</li>
					<li>
				<a href="i18n-module.html">i18n</a>
			</li>
					<li>
				<a href="Icestorm-module.html">Icestorm</a>
			</li>
					<li>
				<a href="Keyval-module.html">Keyval</a>
			</li>
					<li>
				<a href="Pkgconfig-module.html">Pkgconfig</a>
			</li>
					<li>
				<a href="Python-module.html">Python</a>
			</li>
					<li>
				<a href="Python-3-module.html">Python 3</a>
			</li>
					<li>
				<a href="Qt4-module.html">Qt4</a>
			</li>
					<li>
				<a href="Qt5-module.html">Qt5</a>
			</li>
					<li>
				<a href="RPM-module.html">RPM</a>
			</li>
					<li>
				<a href="SourceSet-module.html">SourceSet</a>
			</li>
					<li>
				<a href="Windows-module.html">Windows</a>
			</li>
			</ul>
</li>
<li class="dropdown">
	<a class="dropdown-toggle" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
		Quick References <span class="caret"></span>
	</a>
	<ul class="dropdown-menu" id="quick-refs-menu">
					<li>
				<a href="Reference-manual.html">Functions</a>
			</li>
					<li>
				<a href="Build-options.html">Options</a>
			</li>
					<li>
				<a href="Configuration.html">Configuration</a>
			</li>
					<li>
				<a href="Dependencies.html">Dependencies</a>
			</li>
					<li>
				<a href="Unit-tests.html">Tests</a>
			</li>
					<li>
				<a href="Syntax.html">Syntax</a>
			</li>
			</ul>
</li>
			</ul>
			<div class="hidden-xs hidden-sm navbar-text navbar-center">
				<p><b>The Meson Build System</b></p>
			</div>
		</div>
	</div>
</nav>

<main>
<div data-extension="core" data-hotdoc-in-toplevel="True" data-hotdoc-project="Meson-documentation" data-hotdoc-ref="Dependencies.html" class="page_container" id="page-wrapper">
<script src="assets/js/utils.js"></script>

<div class="panel panel-collapse oc-collapsed" id="sidenav" data-hotdoc-role="navigation">
	<script src="assets/js/navigation.js"></script>
	<script src="assets/js/sitemap.js"></script>
</div>

<div id="body">
	<div id="main">
				    <div id="page-description" data-hotdoc-role="main">
        <h1 id="dependencies">Dependencies</h1>
<p>Very few applications are fully self-contained, but rather they use
external libraries and frameworks to do their work. Meson makes it
very easy to find and use external dependencies. Here is how one would
use the zlib compression library.</p>
<pre><code class="language-meson">zdep = dependency('zlib', version : '&gt;=1.2.8')
exe = executable('zlibprog', 'prog.c', dependencies : zdep)
</code></pre>
<p>First Meson is told to find the external library <code>zlib</code> and error out
if it is not found. The <code>version</code> keyword is optional and specifies a
version requirement for the dependency. Then an executable is built
using the specified dependency. Note how the user does not need to
manually handle compiler or linker flags or deal with any other
minutiae.</p>
<p>If you have multiple dependencies, pass them as an array:</p>
<pre><code class="language-meson">executable('manydeps', 'file.c', dependencies : [dep1, dep2, dep3, dep4])
</code></pre>
<p>If the dependency is optional, you can tell Meson not to error out if
the dependency is not found and then do further configuration.</p>
<pre><code class="language-meson">opt_dep = dependency('somedep', required : false)
if opt_dep.found()
  # Do something.
else
  # Do something else.
endif
</code></pre>
<p>You can pass the <code>opt_dep</code> variable to target construction functions
whether the actual dependency was found or not. Meson will ignore
non-found dependencies.</p>
<p>Meson also allows to get variables that are defined in the
<code>pkg-config</code> file. This can be done by using the
<code>get_pkgconfig_variable</code> function.</p>
<pre><code class="language-meson">zdep_prefix = zdep.get_pkgconfig_variable('prefix')
</code></pre>
<p>These variables can also be redefined by passing the <code>define_variable</code>
parameter, which might be useful in certain situations:</p>
<pre><code class="language-meson">zdep_prefix = zdep.get_pkgconfig_variable('libdir', define_variable: ['prefix', '/tmp'])
</code></pre>
<p>The dependency detector works with all libraries that provide a
<code>pkg-config</code> file. Unfortunately several packages don't provide
pkg-config files. Meson has autodetection support for some of these,
and they are described <a href="Dependencies.html#dependencies-with-custom-lookup-functionality">later in this
page</a>.</p>
<h1 id="arbitrary-variables-from-dependencies-that-can-be-found-multiple-ways">Arbitrary variables from dependencies that can be found multiple ways</h1>
<p><em>Note</em> new in 0.51.0
<em>new in 0.54.0, the <code>internal</code> keyword</em></p>
<p>When you need to get an arbitrary variables from a dependency that can be
found multiple ways and you don't want to constrain the type you can use
the generic <code>get_variable</code> method. This currently supports cmake, pkg-config,
and config-tool based variables.</p>
<pre><code class="language-meson">foo_dep = dependency('foo')
var = foo_dep.get_variable(cmake : 'CMAKE_VAR', pkgconfig : 'pkg-config-var', configtool : 'get-var', default_value : 'default')
</code></pre>
<p>It accepts the keywords 'cmake', 'pkgconfig', 'pkgconfig_define',
'configtool', 'internal', and 'default_value'. 'pkgconfig_define' works just
like the 'define_variable' argument to <code>get_pkgconfig_variable</code>. When this
method is invoked the keyword corresponding to the underlying type of the
dependency will be used to look for a variable. If that variable cannot be
found or if the caller does not provide an argument for the type of
dependency, one of the following will happen: If 'default_value' was provided
that value will be returned, if 'default_value' was not provided then an
error will be raised.</p>
<h1 id="declaring-your-own">Declaring your own</h1>
<p>You can declare your own dependency objects that can be used
interchangeably with dependency objects obtained from the system. The
syntax is straightforward:</p>
<pre><code class="language-meson">my_inc = include_directories(...)
my_lib = static_library(...)
my_dep = declare_dependency(link_with : my_lib,
  include_directories : my_inc)
</code></pre>
<p>This declares a dependency that adds the given include directories and
static library to any target you use it in.</p>
<h1 id="building-dependencies-as-subprojects">Building dependencies as subprojects</h1>
<p>Many platforms do not provide a system package manager. On these
systems dependencies must be compiled from source. Meson's subprojects
make it simple to use system dependencies when they are available and
to build dependencies manually when they are not.</p>
<p>To make this work, the dependency must have Meson build definitions
and it must declare its own dependency like this:</p>
<pre><code class="language-meson">    foo_dep = declare_dependency(...)
</code></pre>
<p>Then any project that wants to use it can write out the following
declaration in their main <code>meson.build</code> file.</p>
<pre><code class="language-meson">    foo_dep = dependency('foo', fallback : ['foo', 'foo_dep'])
</code></pre>
<p>What this declaration means is that first Meson tries to look up the
dependency from the system (such as by using pkg-config). If it is not
available, then it builds subproject named <code>foo</code> and from that
extracts a variable <code>foo_dep</code>. That means that the return value of
this function is either an external or an internal dependency
object. Since they can be used interchangeably, the rest of the build
definitions do not need to care which one it is. Meson will take care
of all the work behind the scenes to make this work.</p>
<h1 id="dependency-method">Dependency method</h1>
<p>You can use the keyword <code>method</code> to let meson know what method to use
when searching for the dependency. The default value is <code>auto</code>.
Additional dependencies methods are <code>pkg-config</code>, <code>config-tool</code>, <code>cmake</code>,
<code>system</code>, <code>sysconfig</code>, <code>qmake</code>, <code>extraframework</code> and <code>dub</code>.</p>
<pre><code class="language-meson">cups_dep = dependency('cups', method : 'pkg-config')
</code></pre>
<p>The dependency method order for <code>auto</code> is:</p>
<ol>
<li><code>pkg-config</code></li>
<li><code>cmake</code></li>
<li>
<code>extraframework</code> (OSX only)</li>
</ol>
<h2 id="cmake">CMake</h2>
<p>Meson can use the CMake <code>find_package()</code> function to detect
dependencies with the builtin <code>Find&lt;NAME&gt;.cmake</code> modules and exported
project configurations (usually in <code>/usr/lib/cmake</code>). Meson is able
to use both the old-style <code>&lt;NAME&gt;_LIBRARIES</code> variables as well as
imported targets.</p>
<p>It is possible to manually specify a list of CMake targets that should
be used with the <code>modules</code> property. However, this step is optional
since meson tries to automatically guess the correct target based on the
name of the dependency.</p>
<p>Depending on the dependency it may be necessary to explicitly specify
a CMake target with the <code>modules</code> property if meson is unable to guess
it automatically.</p>
<pre><code class="language-meson">    cmake_dep = dependency('ZLIB', method : 'cmake', modules : ['ZLIB::ZLIB'])
</code></pre>
<p>Support for adding additional <code>COMPONENTS</code> for the CMake <code>find_package</code> lookup
is provided with the <code>components</code> kwarg (<em>introduced in 0.54.0</em>). All specified
componets will be passed directly to <code>find_package(COMPONENTS)</code>.</p>
<p>It is also possible to reuse existing <code>Find&lt;name&gt;.cmake</code> files with the
<code>cmake_module_path</code> property. Using this property is equivalent to setting the
<code>CMAKE_MODULE_PATH</code> variable in CMake. The path(s) given to <code>cmake_module_path</code>
should all be relative to the project source directory. Absolute paths
should only be used if the CMake files are not stored in the project itself.</p>
<p>Additional CMake parameters can be specified with the <code>cmake_args</code> property.</p>
<h2 id="dub">Dub</h2>
<p>Please understand that meson is only able to find dependencies that
exist in the local Dub repository. You need to manually fetch and
build the target dependencies.</p>
<p>For <code>urld</code>.</p>
<pre><code>dub fetch urld
dub build urld
</code></pre>
<p>Other thing you need to keep in mind is that both meson and Dub need
to be using the same compiler. This can be achieved using Dub's
<code>-compiler</code> argument and/or manually setting the <code>DC</code> environment
variable when running meson.</p>
<pre><code>dub build urld --compiler=dmd
DC="dmd" meson builddir
</code></pre>
<h1 id="dependencies-with-custom-lookup-functionality">Dependencies with custom lookup functionality</h1>
<p>Some dependencies have specific detection logic.</p>
<p>Generic dependency names are case-sensitive<sup><a href="Dependencies.html#footnote1">1</a></sup>,
but these dependency names are matched case-insensitively.  The
recommended style is to write them in all lower-case.</p>
<p>In some cases, more than one detection method exists, and the <code>method</code> keyword
may be used to select a detection method to use.  The <code>auto</code> method uses any
checking mechanisms in whatever order meson thinks is best.</p>
<p>e.g. libwmf and CUPS provide both pkg-config and config-tool support. You can
force one or another via the <code>method</code> keyword:</p>
<pre><code class="language-meson">cups_dep = dependency('cups', method : 'pkg-config')
wmf_dep = dependency('libwmf', method : 'config-tool')
</code></pre>
<h2 id="dependencies-using-config-tools">Dependencies using config tools</h2>
<p><a href="Dependencies.html#cups">CUPS</a>, <a href="Dependencies.html#llvm">LLVM</a>, <a href="Dependencies.html#pcap">pcap</a>, <a href="Dependencies.html#wxwidgets">WxWidgets</a>,
<a href="Dependencies.html#libwmf">libwmf</a>, <a href="Dependencies.html#libgcrypt">GCrypt</a>, <a href="Dependencies.html#gpgme">GPGME</a>, and GnuStep either do not provide pkg-config
modules or additionally can be detected via a config tool
(cups-config, llvm-config, libgcrypt-config, etc). Meson has native support for these
tools, and they can be found like other dependencies:</p>
<pre><code class="language-meson">pcap_dep = dependency('pcap', version : '&gt;=1.0')
cups_dep = dependency('cups', version : '&gt;=1.4')
llvm_dep = dependency('llvm', version : '&gt;=4.0')
libgcrypt_dep = dependency('libgcrypt', version: '&gt;= 1.8')
gpgme_dep = dependency('gpgme', version: '&gt;= 1.0')
</code></pre>
<p><em>Since 0.55.0</em> Meson won't search $PATH any more for a config tool binary when
cross compiling if the config tool did not have an entry in the cross file.</p>
<h2 id="appleframeworks">AppleFrameworks</h2>
<p>Use the <code>modules</code> keyword to list frameworks required, e.g.</p>
<pre><code class="language-meson">dep = dependency('appleframeworks', modules : 'foundation')
</code></pre>
<p>These dependencies can never be found for non-OSX hosts.</p>
<h2 id="blocks">Blocks</h2>
<p>Enable support for Clang's blocks extension.</p>
<pre><code class="language-meson">dep = dependency('blocks')
</code></pre>
<p><em>(added 0.52.0)</em></p>
<h2 id="boost">Boost</h2>
<p>Boost is not a single dependency but rather a group of different
libraries. To use Boost headers-only libraries, simply add Boost as a
dependency.</p>
<pre><code class="language-meson">boost_dep = dependency('boost')
exe = executable('myprog', 'file.cc', dependencies : boost_dep)
</code></pre>
<p>To link against boost with Meson, simply list which libraries you
would like to use.</p>
<pre><code class="language-meson">boost_dep = dependency('boost', modules : ['thread', 'utility'])
exe = executable('myprog', 'file.cc', dependencies : boost_dep)
</code></pre>
<p>You can call <code>dependency</code> multiple times with different modules and
use those to link against your targets.</p>
<p>If your boost headers or libraries are in non-standard locations you
can set the <code>BOOST_ROOT</code>, or the <code>BOOST_INCLUDEDIR</code> and <code>BOOST_LIBRARYDIR</code>
environment variables. <em>(added in 0.56.0)</em> You can also set these
parameters as <code>boost_root</code>, <code>boost_include</code>, and <code>boost_librarydir</code> in your
native or cross machine file. Note that machine file variables are
preferred to environment variables, and that specifying any of these
disables system-wide search for boost.</p>
<p>You can set the argument <code>threading</code> to <code>single</code> to use boost
libraries that have been compiled for single-threaded use instead.</p>
<h2 id="cuda">CUDA</h2>
<p><em>(added 0.53.0)</em></p>
<p>Enables compiling and linking against the CUDA Toolkit. The <code>version</code>
and <code>modules</code> keywords may be passed to request the use of a specific
CUDA Toolkit version and/or additional CUDA libraries, correspondingly:</p>
<pre><code class="language-meson">dep = dependency('cuda', version : '&gt;=10', modules : ['cublas'])
</code></pre>
<p>Note that explicitly adding this dependency is only necessary if you are
using CUDA Toolkit from a C/C++ file or project, or if you are utilizing
additional toolkit libraries that need to be explicitly linked to.</p>
<h2 id="cups">CUPS</h2>
<p><code>method</code> may be <code>auto</code>, <code>config-tool</code>, <code>pkg-config</code>, <code>cmake</code> or <code>extraframework</code>.</p>
<h2 id="fortran-coarrays">Fortran Coarrays</h2>
<p><em>(added 0.50.0)</em></p>
<p>Coarrays are a Fortran language intrinsic feature, enabled by
<code>dependency('coarray')</code>.</p>
<p>GCC will use OpenCoarrays if present to implement coarrays, while Intel and NAG
use internal coarray support.</p>
<h2 id="gl">GL</h2>
<p>This finds the OpenGL library in a way appropriate to the platform.</p>
<p><code>method</code> may be <code>auto</code>, <code>pkg-config</code> or <code>system</code>.</p>
<h2 id="gtest-and-gmock">GTest and GMock</h2>
<p>GTest and GMock come as sources that must be compiled as part of your
project. With Meson you don't have to care about the details, just
pass <code>gtest</code> or <code>gmock</code> to <code>dependency</code> and it will do everything for
you. If you want to use GMock, it is recommended to use GTest as well,
as getting it to work standalone is tricky.</p>
<p>You can set the <code>main</code> keyword argument to <code>true</code> to use the <code>main()</code>
function provided by GTest:</p>
<pre><code class="language-meson">gtest_dep = dependency('gtest', main : true, required : false)
e = executable('testprog', 'test.cc', dependencies : gtest_dep)
test('gtest test', e)
</code></pre>
<h2 id="hdf5">HDF5</h2>
<p><em>(added 0.50.0)</em></p>
<p>HDF5 is supported for C, C++ and Fortran. Because dependencies are
language-specific, you must specify the requested language using the
<code>language</code> keyword argument, i.e.,</p>
<ul>
<li>
<code>dependency('hdf5', language: 'c')</code> for the C HDF5 headers and libraries</li>
<li>
<code>dependency('hdf5', language: 'cpp')</code> for the C++ HDF5 headers and libraries</li>
<li>
<code>dependency('hdf5', language: 'fortran')</code> for the Fortran HDF5 headers and libraries</li>
</ul>
<p>Meson uses pkg-config to find HDF5. The standard low-level HDF5 function and the <code>HL</code> high-level HDF5 functions are linked for each language.</p>
<p><code>method</code> may be <code>auto</code>, <code>config-tool</code> or <code>pkg-config</code>.</p>
<p><em>New in 0.56.0</em> the <code>config-tool</code> method.
<em>New in 0.56.0</em> the dependencies now return proper dependency types and <code>get_variable</code> and similar methods should work as expected.</p>
<h2 id="libwmf">libwmf</h2>
<p><em>(added 0.44.0)</em></p>
<p><code>method</code> may be <code>auto</code>, <code>config-tool</code> or <code>pkg-config</code>.</p>
<h2 id="llvm">LLVM</h2>
<p>Meson has native support for LLVM going back to version LLVM version 3.5.
It supports a few additional features compared to other config-tool based
dependencies.</p>
<p>As of 0.44.0 Meson supports the <code>static</code> keyword argument for
LLVM. Before this LLVM &gt;= 3.9 would always dynamically link, while
older versions would statically link, due to a quirk in <code>llvm-config</code>.</p>
<p><code>method</code> may be <code>auto</code>, <code>config-tool</code>, or <code>cmake</code>.</p>
<h3 id="modules-aka-components">Modules, a.k.a. Components</h3>
<p>Meson wraps LLVM's concept of components in it's own modules concept.
When you need specific components you add them as modules as meson
will do the right thing:</p>
<pre><code class="language-meson">llvm_dep = dependency('llvm', version : '&gt;= 4.0', modules : ['amdgpu'])
</code></pre>
<p>As of 0.44.0 it can also take optional modules (these will affect the arguments
generated for a static link):</p>
<pre><code class="language-meson">llvm_dep = dependency(
  'llvm', version : '&gt;= 4.0', modules : ['amdgpu'], optional_modules : ['inteljitevents'],
)
</code></pre>
<h3 id="using-llvm-tools">Using LLVM tools</h3>
<p>When using LLVM as library but also needing its tools, it is often beneficial to use the same version.
This can partially be achieved with the <code>version</code> argument of <code>find_program()</code>.
However, distributions tend to package different LLVM versions in rather different ways.
Therefore, it is often better to use the llvm dependency directly to retrieve the tools:</p>
<pre><code class="language-meson">llvm_dep = dependency('llvm', version : ['&gt;= 8', '&lt; 9'])
llvm_link = find_program(llvm_dep.get_variable(configtool: 'bindir') / 'llvm-link')
</code></pre>
<h2 id="mpi">MPI</h2>
<p><em>(added 0.42.0)</em></p>
<p>MPI is supported for C, C++ and Fortran. Because dependencies are
language-specific, you must specify the requested language using the
<code>language</code> keyword argument, i.e.,</p>
<ul>
<li>
<code>dependency('mpi', language: 'c')</code> for the C MPI headers and libraries</li>
<li>
<code>dependency('mpi', language: 'cpp')</code> for the C++ MPI headers and libraries</li>
<li>
<code>dependency('mpi', language: 'fortran')</code> for the Fortran MPI headers and libraries</li>
</ul>
<p>Meson prefers pkg-config for MPI, but if your MPI implementation does
not provide them, it will search for the standard wrapper executables,
<code>mpic</code>, <code>mpicxx</code>, <code>mpic++</code>, <code>mpifort</code>, <code>mpif90</code>, <code>mpif77</code>. If these
are not in your path, they can be specified by setting the standard
environment variables <code>MPICC</code>, <code>MPICXX</code>, <code>MPIFC</code>, <code>MPIF90</code>, or
<code>MPIF77</code>, during configuration. It will also try to use the Microsoft
implementation on windows via the <code>system</code> method.</p>
<p><code>method</code> may be <code>auto</code>, <code>config-tool</code>, <code>pkg-config</code> or <code>system</code>.</p>
<p><em>New in 0.54.0</em> The <code>config-tool</code> and <code>system</code> method values. Previous
versions would always try <code>pkg-config</code>, then <code>config-tool</code>, then <code>system</code>.</p>
<h2 id="netcdf">NetCDF</h2>
<p><em>(added 0.50.0)</em></p>
<p>NetCDF is supported for C, C++ and Fortran. Because NetCDF dependencies are
language-specific, you must specify the requested language using the
<code>language</code> keyword argument, i.e.,</p>
<ul>
<li>
<code>dependency('netcdf', language: 'c')</code> for the C NetCDF headers and libraries</li>
<li>
<code>dependency('netcdf', language: 'cpp')</code> for the C++ NetCDF headers and libraries</li>
<li>
<code>dependency('netcdf', language: 'fortran')</code> for the Fortran NetCDF headers and libraries</li>
</ul>
<p>Meson uses pkg-config to find NetCDF.</p>
<h2 id="openmp">OpenMP</h2>
<p><em>(added 0.46.0)</em></p>
<p>This dependency selects the appropriate compiler flags and/or libraries to use
for OpenMP support.</p>
<p>The <code>language</code> keyword may used.</p>
<h2 id="pcap">pcap</h2>
<p><em>(added 0.42.0)</em></p>
<p><code>method</code> may be <code>auto</code>, <code>config-tool</code> or <code>pkg-config</code>.</p>
<h2 id="libgcrypt">libgcrypt</h2>
<p><em>(added 0.49.0)</em></p>
<p><code>method</code> may be <code>auto</code>, <code>config-tool</code> or <code>pkg-config</code>.</p>
<h2 id="gpgme">GPGME</h2>
<p><em>(added 0.51.0)</em></p>
<p><code>method</code> may be <code>auto</code>, <code>config-tool</code> or <code>pkg-config</code>.</p>
<h2 id="python3">Python3</h2>
<p>Python3 is handled specially by meson:</p>
<ol>
<li>Meson tries to use <code>pkg-config</code>.</li>
<li>If <code>pkg-config</code> fails meson uses a fallback:
<ul>
<li>On Windows the fallback is the current <code>python3</code> interpreter.</li>
<li>On OSX the fallback is a framework dependency from <code>/Library/Frameworks</code>.</li>
</ul>
</li>
</ol>
<p>Note that <code>python3</code> found by this dependency might differ from the one used in
<code>python3</code> module because modules uses the current interpreter, but dependency tries
<code>pkg-config</code> first.</p>
<p><code>method</code> may be <code>auto</code>, <code>extraframework</code>, <code>pkg-config</code> or <code>sysconfig</code></p>
<h2 id="qt4-qt5">Qt4 &amp; Qt5</h2>
<p>Meson has native Qt support. Its usage is best demonstrated with an
example.</p>
<pre><code class="language-meson">qt5_mod = import('qt5')
qt5widgets = dependency('qt5', modules : 'Widgets')

processed = qt5_mod.preprocess(
  moc_headers : 'mainWindow.h',   # Only headers that need moc should be put here
  moc_sources : 'helperFile.cpp', # must have #include"moc_helperFile.cpp"
  ui_files    : 'mainWindow.ui',
  qresources  : 'resources.qrc',
)

q5exe = executable('qt5test',
  sources     : ['main.cpp',
                 'mainWindow.cpp',
                 processed],
  dependencies: qt5widgets)
</code></pre>
<p>Here we have an UI file created with Qt Designer and one source and
header file each that require preprocessing with the <code>moc</code> tool. We
also define a resource file to be compiled with <code>rcc</code>. We just have to
tell Meson which files are which and it will take care of invoking all
the necessary tools in the correct order, which is done with the
<code>preprocess</code> method of the <code>qt5</code> module. Its output is simply put in
the list of sources for the target. The <code>modules</code> keyword of
<code>dependency</code> works just like it does with Boost. It tells which
subparts of Qt the program uses.</p>
<p>You can set the <code>main</code> keyword argument to <code>true</code> to use the <code>WinMain()</code>
function provided by qtmain static library (this argument does nothing on platforms
other than Windows).</p>
<p>Setting the optional <code>private_headers</code> keyword to true adds the private header
include path of the given module(s) to the compiler flags.  (since v0.47.0)</p>
<p><strong>Note</strong> using private headers in your project is a bad idea, do so at your own
risk.</p>
<p><code>method</code> may be <code>auto</code>, <code>pkg-config</code> or <code>qmake</code>.</p>
<h2 id="sdl2">SDL2</h2>
<p>SDL2 can be located using <code>pkg-confg</code>, the <code>sdl2-config</code> config tool, or as an
OSX framework.</p>
<p><code>method</code> may be <code>auto</code>, <code>config-tool</code>, <code>extraframework</code> or <code>pkg-config</code>.</p>
<h2 id="threads">Threads</h2>
<p>This dependency selects the appropriate compiler flags and/or libraries to use
for thread support.</p>
<p>See <a href="Threads.html">threads</a>.</p>
<h2 id="valgrind">Valgrind</h2>
<p>Meson will find valgrind using <code>pkg-config</code>, but only uses the compilation flags
and avoids trying to link with it's non-PIC static libs.</p>
<h2 id="vulkan">Vulkan</h2>
<p><em>(added 0.42.0)</em></p>
<p>Vulkan can be located using <code>pkg-config</code>, or the <code>VULKAN_SDK</code> environment variable.</p>
<p><code>method</code> may be <code>auto</code>, <code>pkg-config</code> or <code>system</code>.</p>
<h2 id="wxwidgets">WxWidgets</h2>
<p>Similar to <a href="Dependencies.html#boost">Boost</a>, WxWidgets is not a single library but rather
a collection of modules. WxWidgets is supported via <code>wx-config</code>.
Meson substitutes <code>modules</code> to <code>wx-config</code> invocation, it generates</p>
<ul>
<li>
<code>compile_args</code> using <code>wx-config --cxxflags $modules...</code>
</li>
<li>
<code>link_args</code> using <code>wx-config --libs $modules...</code>
</li>
</ul>
<h3 id="example">Example</h3>
<pre><code class="language-meson">wx_dep = dependency(
  'wxwidgets', version : '&gt;=3.0.0', modules : ['std', 'stc'],
)
</code></pre>
<pre><code class="language-shell"># compile_args:
$ wx-config --cxxflags std stc

# link_args:
$ wx-config --libs std stc
</code></pre>
<h2 id="shaderc">Shaderc</h2>
<p><em>(added 0.51.0)</em></p>
<p>Shaderc currently does not ship with any means of detection. Nevertheless, Meson
can try to detect it using <code>pkg-config</code>, but will default to looking for the
appropriate library manually. If the <code>static</code> keyword argument is <code>true</code>,
<code>shaderc_combined</code> is preferred. Otherwise, <code>shaderc_shared</code> is preferred. Note
that it is not possible to obtain the shaderc version using this method.</p>
<p><code>method</code> may be <code>auto</code>, <code>pkg-config</code> or <code>system</code>.</p>
<h2 id="zlib">Zlib</h2>
<p>Zlib ships with pkg-config and cmake support, but on some operating systems
(windows, macOs, FreeBSD, dragonflybsd), it is provided as part of the base
operating system without pkg-config support. The new System finder can be used
on these OSes to link with the bundled version.</p>
<p><code>method</code> may be <code>auto</code>, <code>pkg-config</code>, <code>cmake</code>, or <code>system</code>.</p>
<p><em>New in 0.54.0</em> the <code>system</code> method.</p>
<h2 id="curses">Curses</h2>
<p><em>(Since 0.54.0)</em></p>
<p>Curses (and ncurses) are a cross platform pain in the butt. Meson wraps up
these dependencies in the <code>curses</code> dependency. This covers both <code>ncurses</code>
(preferred) and other curses implementations.</p>
<p><code>method</code> may be <code>auto</code>, <code>pkg-config</code>, <code>config-tool</code>, or <code>system</code>.</p>
<p><em>New in 0.56.0</em> The <code>config-tool</code> and <code>system</code> methods.</p>
<hr>
<a name="footnote1">1</a>: They may appear to be case-insensitive, if the
    underlying file system happens to be case-insensitive.

    </div>
        




		
	</div>
	<div id="search_results">
		<p>The results of the search are</p>
	</div>
	<div id="footer">
		    
        
<hr>

<div class="license-description">
    Website licensing information are available on the <a href="legal.html">Legal</a> page.
</div>


	</div>
</div>

<div id="toc-column">
	
		<div class="edit-button">
		<a href="https://github.com/mesonbuild/meson//edit/master/docs/builddir/markdown/Dependencies.md" data-hotdoc-role="edit-button">Edit on github</a>

	</div>
		<div id="toc-wrapper">
		<nav id="toc"></nav>
	</div>
</div>
</div>
</main>


<script src="assets/js/navbar_offset_scroller.js"></script>
</body>
</html>
